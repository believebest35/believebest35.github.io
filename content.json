{"meta":{"title":"Xinrui Tang","subtitle":"","description":"这里是我写一些无聊的东西的地方","author":"Xinrui Tang","url":"http://believebest35.github.io","root":"/"},"pages":[{"title":"about me","date":"2020-07-22T11:26:47.000Z","updated":"2020-07-22T12:20:53.959Z","comments":false,"path":"about/index.html","permalink":"http://believebest35.github.io/about/index.html","excerpt":"","text":"Hello, this is Xinrui Tang’s blog by hexo."},{"title":"","date":"2020-07-22T11:24:27.000Z","updated":"2020-07-22T12:12:41.598Z","comments":false,"path":"categories/index.html","permalink":"http://believebest35.github.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2020-10-13T11:42:13.000Z","updated":"2020-10-13T11:42:13.660Z","comments":true,"path":"about/index-1.html","permalink":"http://believebest35.github.io/about/index-1.html","excerpt":"","text":""},{"title":"tags","date":"2020-10-13T11:38:43.000Z","updated":"2020-10-13T11:38:43.060Z","comments":true,"path":"tags/index-1.html","permalink":"http://believebest35.github.io/tags/index-1.html","excerpt":"","text":""},{"title":"","date":"2020-07-22T11:26:00.000Z","updated":"2020-07-22T12:12:13.920Z","comments":false,"path":"tags/index.html","permalink":"http://believebest35.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java_基础","slug":"Java-1","date":"2020-10-26T02:25:15.000Z","updated":"2020-10-26T08:42:38.228Z","comments":true,"path":"2020/10/26/Java-1/","link":"","permalink":"http://believebest35.github.io/2020/10/26/Java-1/","excerpt":"参照廖雪峰的Java教程进行学习。 JDK和JRE JDK：Java Development Kit JRE：Java Runtime Environment","text":"参照廖雪峰的Java教程进行学习。 JDK和JRE JDK：Java Development Kit JRE：Java Runtime Environment 1234567891011 ┌─ ┌──────────────────────────────────┐ │ │ Compiler, debugger, etc. │ │ └──────────────────────────────────┘JDK ┌─ ┌──────────────────────────────────┐ │ │ │ │ │ JRE │ JVM + Runtime Library │ │ │ │ │ └─ └─ └──────────────────────────────────┘ ┌───────┐┌───────┐┌───────┐┌───────┐ │Windows││ Linux ││ macOS ││others │ └───────┘└───────┘└───────┘└───────┘ JAVA_HOME的bin目录 java：这个可执行程序其实就是JVM，运行Java程序，就是启动JVM，然后让JVM执行指定的编译后的代码； javac：这是Java的编译器，它用于把Java源码文件（以.java后缀结尾）编译为Java字节码文件（以.class后缀结尾）； jar：用于把一组.class文件打包成一个.jar文件，便于发布； javadoc：用于从Java源码中自动提取注释并生成文档； jdb：Java调试器，用于开发阶段的运行调试。 第一个Java程序1234567public class Hello&#123; public static void main(String[] args) &#123; System.out.println(\"hello world\"); &#125;&#125; 定义了一个公开类Hello（为了规范，类名首字母一般大写）。 程序从名为main()的公开静态方法开始进入（一般成员函数名称首字母小写）。 System.out.println()向终端进行打印。 一些Java程序基础以第一个Java程序为例，定义了名为Hello的公开类，定义了名为main的公开静态方法，即程序入口。 注释Java的三种注释 1234567891011// 单行注释/* 多行注释...*/ /** 用于自动创建文档的注释**/ 其中最后的一种特殊的多行注释格式一般写在类和方法的定义处，用于自动创建文档。 Mac下eclipse按⌘+⇧+F（Windows下按Ctrl+Shift+F）可以格式化代码。 变量基本类型 整数类型：byte，short，int，long 浮点数类型：float，double 字符类型：char 布尔类型：boolean 大小 123456789101112131415161718192021 ┌───┐ byte │ │ └───┘ ┌───┬───┐ short │ │ │ └───┴───┘ ┌───┬───┬───┬───┐ int │ │ │ │ │ └───┴───┴───┴───┘ ┌───┬───┬───┬───┬───┬───┬───┬───┐ long │ │ │ │ │ │ │ │ │ └───┴───┴───┴───┴───┴───┴───┴───┘ ┌───┬───┬───┬───┐ float │ │ │ │ │ └───┴───┴───┴───┘ ┌───┬───┬───┬───┬───┬───┬───┬───┐double │ │ │ │ │ │ │ │ │ └───┴───┴───┴───┴───┴───┴───┴───┘ ┌───┬───┐ char │ │ │ └───┴───┘ 整型，与C++不同，Java只有带符号的整型数，最高位为为符号位（0正1负），表示范围： byte：-128 ~ 127 （1字节） short: -32768 ~ 32767 （2字节） int: -2147483648 ~ 2147483647 （4字节） long: -9223372036854775808 ~ 9223372036854775807 （8字节） 1234int a = 2_000_000; // 下划线分割，实际为2000000int b = 0xff001; // 16进制int c = 0b10101; // 二进制long d = 9000000000000000000L; // long型结尾需要加L 浮点型 float：4字节，结尾加f进行标志 double：8字节 12float a = 1.0f;double b = 1.0; 字符型 使用单引号 boolean型 只表示true或者false。JVM一般将其用4个字节进行存储。（同C++，和int互相转）。 引用类型引用类似C++中的引用，实际记录的是某个对象在内存的位置。最为常用的： 1String str = \"hello world\"; 需要注意引用类型的比较，需要使用equals成员函数进行比较，使用==仅是在判断所引用的对象是否一致。 12345String s1 = \"hello\";String s2 = \"Hello\".toLowerCase();boolean res1 = s1 == s2; // falseboolean res2 = s1.equals(s2); // true final和var使用final可以定义常量类型，不可以被修改（类似C++ const），使用var可进行自动类型推断（类似C++ auto）。 12final int a = 1;var b = new StringBuilder(); 运算 + - * / % ++ -- += -= /= *= &gt; &lt; == &gt;= &lt;= != &amp;&amp; || ! &gt;&gt; &lt;&lt; &gt;&gt;&gt; 最后一个为无符号右移，最高位补0 &amp; | ! ^ = b ? x : y 类型转换自动的类型转换都是从小范围到大范围，强转类似C++。 StringJava提供了自带的字符串类型，引用类型。 12345String s1 = \"test\";String s2 = s1 + \" \" + \"test\"; // 拼接String s3 = \"\"; // 空串String s4 = null; // 空引用String s5; // 空引用 数组与C++数组类型不同，Java的数组类型需要动态声明大小，为引用类型。 采用类型[] 数组名的形式进行声明。 12345678int[] arr = new int[10];arr[0] = 1;// ...int size = 100;int[] arr_2 = new int[size];int size_2 = arr_2.length;String[] str_arr = new String[size]; // 字符串数组每个元素都是引用类型 流程控制输入输出1System.out.println();// 简单的输出 输出可使用格式化参数。 输出相对C++而言更复杂，一般使用Scanner类。 123456import java.util.Scanner;Scanner scanner = new Scanner(System.in); // 新建Scanner对象String str = scanner.nextLine(); // 读一行字符串String str_2 = scanner.next(); // 读字符串直到遇到空格、换行等int a = scanner.nextInt(); // 读整数 if else, switch case, while, do while, for, continue, break同C++ 类似C++11，Java也有基于范围（for each）的循环。 12345678int[] arr = &#123;1, 2, 3, 4, 5, 6&#125;;for (var num : arr) &#123; System.out.println(num);&#125;for (int num : arr) &#123; System.out.println(num);&#125; for each循环也适用于其他的可迭代类型。 数组操作 遍历 排序 JDK提供Arrays.sort()进行排序 1234import java.util.Arrays;int[] nums = &#123;5, 3, 4, 2, 1&#125;;Arrays.sort(nums); 多维数组 123int[][] arr = new int[3][5];System.out.println(arr.length); // 3System.out.println(arr[1].length); // 5","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://believebest35.github.io/tags/Java/"}]},{"title":"一些Linux的基础知识","slug":"Linux","date":"2020-10-19T08:55:19.000Z","updated":"2020-10-26T02:24:51.598Z","comments":true,"path":"2020/10/19/Linux/","link":"","permalink":"http://believebest35.github.io/2020/10/19/Linux/","excerpt":"由于自己薄弱的Linux基础，需要快速的补充一下自己有关Linux知识，以下内容简单总结于鸟叔的Linux私房菜。","text":"由于自己薄弱的Linux基础，需要快速的补充一下自己有关Linux知识，以下内容简单总结于鸟叔的Linux私房菜。 日期的指令 date 显示日期 cal 显示日历 12345678910111213--- ~ » date2020年10月19日 星期一 17时12分03秒 CST--- ~ » cal 十月 2020日 一 二 三 四 五 六 1 2 3 4 5 6 7 8 9 1011 12 13 14 15 16 1718 19 20 21 22 23 2425 26 27 28 29 30 31--- ~ » cal 2020# ......--- ~ » cal 10 2020 ls ls 显示当前目录下文件 12345678910111213141516--- ~ » ls -ltotal 8drwxr-xr-x 5 xinrui_tang staff 160 10 5 16:26 Applicationsdrwxr-xr-x 3 xinrui_tang staff 96 3 21 2019 Cloud Drivedrwx------@ 44 xinrui_tang staff 1408 10 19 09:27 Desktopdrwx------+ 8 xinrui_tang staff 256 8 3 15:53 Documentsdrwx------@ 6 xinrui_tang staff 192 10 19 09:26 Downloadsdrwx------@ 82 xinrui_tang staff 2624 7 20 12:16 Librarydrwx------+ 6 xinrui_tang staff 192 11 26 2019 Moviesdrwx------+ 8 xinrui_tang staff 256 10 10 2019 Musicdrwx------+ 5 xinrui_tang staff 160 8 10 2019 Picturesdrwxr-xr-x+ 5 xinrui_tang staff 160 9 14 2019 Publicdrwxr-xr-x 4 xinrui_tang staff 128 10 15 20:54 eclipsedrwxr-xr-x 3 xinrui_tang staff 96 10 15 20:17 javasharedresourcesdrwxr-xr-x 3 xinrui_tang staff 96 6 28 20:23 nltk_data-rw-rw-rw- 1 xinrui_tang staff 18 6 16 2019 sockets.log 第一个字符可以为 1234d 表示为目录- 表示为文件| 表示为链接文件... 接下来三个均为”rwx”的字符组合，r表示可读，w表示可写，x表示可执行，若没有权限则用 ‘-‘ 代替 第一组为文件拥有者可具备的权限。 第二组为加入此群组的帐号的权限。 第三组为非本人且没有加入本群组的其他帐号的权限。 第二栏的数字表示有多少文件名链接到此节点 第三栏表示拥有者 第四栏表示所属群组 第五栏为这个文件的容量大小，默认单位为Bytes 第六栏为这个文件的创建日期或者是最近的修改日期 第七栏是文件名 改变文件属性和权限 chown 改变文件拥有者 chmod 改变文件权限 chgrp 改变群组 以上三个命令请另行查阅文档。 目录处理 cd 变换目录 pwd 显示当前路径 mkdir 创建文件夹 rmdir 删除空文件夹 复制移动和删除 cp 复制 rm 删除 mv 移动 查阅文件内容 cat od 可显示文件的二进制编码 head [-n, number] filename 指定显示文件的前几行 tail 同head，指定显示文件的后几行 to do","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://believebest35.github.io/tags/Linux/"}]},{"title":"面向对象_STL进阶","slug":"OOP-THU-8","date":"2020-10-14T02:52:25.000Z","updated":"2020-10-14T14:06:43.358Z","comments":true,"path":"2020/10/14/OOP-THU-8/","link":"","permalink":"http://believebest35.github.io/2020/10/14/OOP-THU-8/","excerpt":"stringSTL提供string类型用以替代C语言自带的char型数组。","text":"stringSTL提供string类型用以替代C语言自带的char型数组。 12345678910111213141516171819202122232425262728293031323334353637383940string first_name = \"xinrui\", last_name = \"tang\";string full_name = first_name + \" \" + last_name; // string拼接//初始化string s0(\"Hello World!\");string s1(); // 空串//转换为C风格字符串s0.c_str(); // 返回的是字符串常量string s;// 与vector类似s[i]; // 下标访问int len = s.size();int len = s.length(); // 求长度，vector没有s.clear(); // 清空bool is_empty = s.empty(); // 查询是否为空for (auto ch : s)&#123; // ... 迭代，同vector&#125;s.push_back('a'); // 尾部加字符s.append(\"aa\"); // 尾部加字符串s += 'a';s += \"aa\"; // += 运算符进行拼接cin &gt;&gt; s; // 遇到空格停止读入getline(cin, s); // 读一行getline(cin, s, '#'); // 读到遇见指定分隔符s0 &lt; s1; // 比较字典序s = to_string(123); // 整型数转strings = to_string(3.14); // 浮点数转strings = to_string(3.1415926); // 3.141593 损失精度int a = stoi(\"123\"); // string转intdouble b = stod(\"3.14\"); // string转double iostream 输入输出流ostream输出流，重载了所有基础类型的”&lt;&lt;”运算，将printf相对混乱的输入格式统一做了简化，”&lt;&lt;”运算左结合。 12345678910111213141516171819202122class my_ostream // 定义自己的输出流&#123;public: my_ostream&amp; operator&lt;&lt; (char c) &#123; printf(\"%c\", c); return *this; &#125; my_ostream&amp; operator&lt;&lt; (const char *str) &#123; printf(\"%s\", str); return *this; &#125;&#125;;int main()&#123; my_ostream my_cout; my_cout &lt;&lt; 'a' &lt;&lt; \"aaa\"; // 运算为左结合 return 0;&#125; 格式化输出，借助流操纵算子： 123456789101112131415#include&lt;iomanip&gt;cout &lt;&lt; fixed &lt;&lt; 2018.0 &lt;&lt; \" \" &lt;&lt; 0.0001 &lt;&lt; endl; //浮点数，小数有效6位 -&gt; 2018.000000 0.000100cout &lt;&lt; scientific &lt;&lt; 2018.0 &lt;&lt; \" \" &lt;&lt; 0.0001 &lt;&lt; endl; //科学计数法 -&gt; 2.018000e+03 1.000000e-04cout &lt;&lt; defaultfloat; //还原默认输出格式cout &lt;&lt; setprecision(2) &lt;&lt; 3.1415926 &lt;&lt; endl; //输出精度设置为2，包括整数+小数 -&gt; 3.1cout &lt;&lt; oct &lt;&lt; 12 &lt;&lt; \" \" &lt;&lt; hex &lt;&lt; 12 &lt;&lt; endl; //八进制输出 -&gt; 14 十六进制输出 -&gt; ccout &lt;&lt; dec; //还原十进制cout &lt;&lt; setw(3) &lt;&lt; setfill('*') &lt;&lt; 5 &lt;&lt; endl; //设置对齐长度为3，对齐字符为* -&gt; **5 endl基本等于输出’\\n’后再刷新缓冲区，是一个函数，同时也是流操纵算子。 cout无法复制，是一个全局对象。 注意重载流运算符的方式: 12ostream&amp; operator&lt;&lt;(const char &amp;c)friend ostream&amp; operator&lt;&lt;(ostream&amp; os, MyClass obj) 重载 ‘&lt;&lt;’ 返回引用以防进行复制。 观察ostream的拷贝构造函数 12ostream (const ostream&amp;) = delete;ostream (ostream&amp;&amp; x); 拷贝构造函数被删除，只允许移动，防止复制。 文件输入输出流以ifstream为例，是istream子类。 打开文件 123456ifstream ifs(\"input.txt\");ifstream ifs(\"binary.bin\", ifstream::binary);//以二进制形式打开文件ifstream ifs;ifs.open(\"file_path\")//do somethingifs.close() 字符串输入输出流stringstream对象内部维护了一个buffer，使用流输出函数可以将数据写入buffer，使用流输入函数可以从buffer中读出数据。 123456789101112stringstream ss; //空字符串流stringstream ss(str); //以字符串初始化流// ...stringstream ss;ss &lt;&lt; \"10\";ss &lt;&lt; \"0 200\";int a, b;ss &gt;&gt; a &gt;&gt; b; //a=100 b=200ss.str(); //返回一个string对象,内容为stringstream的buffer 需要注意buffer内容并不是未读取的内容 123456stringstream ss;ss &lt;&lt; \"100 200\";cout &lt;&lt; ss.str() &lt;&lt; endl; //\"100 200\"int a;ss &gt;&gt; a; // a = 100cout &lt;&lt; ss.str() &lt;&lt; endl; //\"100 200\" sort12345std::sort(); // STL提供的排序算法，默认从小到大排序，时间复杂度O(nlogn)// 原型template&lt;class Iterator&gt; void sort(Iterator first, Iterator last); 若想从大到小排序，则 123456789101112131415161718// sort还重载了另一套参数template &lt;class Iterator, class Compare&gt;void sort(Iterator first, Iterator last, Compare comp);// 对于整型bool cmp(int a, int b)&#123; return a &gt; b;&#125;sort(a.begin(), a.end(), cmp); // 从大到小排序// STL提供了预定义的排序函数// 从小到大sort(a.begin(), a.end(), less&lt;int&gt;());// 从大到小sort(a.begin(), a.end(), greater&lt;int&gt;()); 对于自定义的类型，使用sort排序需要自己定义比较规则，可以重载 ‘&lt;’ , ‘&gt;’ 运算符或者定义cmp比较函数。 智能指针与引用计数 shared_ptr 来自memory头文件 1234#include &lt;memory&gt;shared_ptr&lt;int&gt; p1(new int(1));shared_ptr&lt;int&gt; p2; //空指针 通过引用计数知道何时销毁资源 123456789shared_ptr&lt;int&gt; p1(new int(4));cout &lt;&lt; p1.use_count() &lt;&lt; ' ';&#123; shared_ptr&lt;int&gt; p2 = p1; cout &lt;&lt; p1.use_count() &lt;&lt; ' '; cout &lt;&lt; p2.use_count() &lt;&lt; ' ';&#125; //p2出作用域cout &lt;&lt; p1.use_count() &lt;&lt; ' ';// 输出 1 2 2 1 其他用法： 1234p.get() //获取裸指针p.reset() //清除指针并减少引用计数static_pointer_cast&lt;int&gt;(p)dynamic_pointer_cast&lt;Base&gt;(p) 注意不能使用同一裸指针同时初始化多个智能指针 123int* p = new int(); shared_ptr&lt;int&gt; p1(p); shared_ptr&lt;int&gt; p2(p); // wrong !! 关于智能指针的详细介绍需要另外查资料。 weak_ptr 指向对象但不计数 1234567shared_ptr&lt;int&gt; sp(new int(3));weak_ptr&lt;int&gt; wp1 = sp;wp.use_count() //获取引用计数wp.reset() //清除指针wp.expired() //检查对象是否无效sp = wp.lock() //从弱引用获得一个智能指针 栗子： 123456789101112std::weak_ptr&lt;int&gt; wp;&#123; auto sp1 = std::make_shared&lt;int&gt;(20); wp = sp1; cout &lt;&lt; wp.use_count() &lt;&lt; endl; //1 auto sp2 = wp.lock(); //从弱引用中获得一个shared_ptr cout &lt;&lt; wp.use_count() &lt;&lt; endl; //2 sp1.reset(); //sp1释放指针 cout &lt;&lt; wp.use_count() &lt;&lt; endl; //1&#125; //sp2销毁cout &lt;&lt; wp.use_count() &lt;&lt; endl; //0cout &lt;&lt; wp.expired() &lt;&lt; endl; //检查弱引用是否失效：True unique_ptr shared_ptr涉及到共享计数，性能相对较差，使用unique_ptr可以保证每个对象只被唯一的一个指针所引用。 12345auto up1 = std::make_unique&lt;int&gt;(20);unique_ptr&lt;int&gt; up2 = up1; //错误，不能复制unique指针unique_ptr&lt;int&gt; up2 = std::move(up1); //可以移动unique指针int *p = up2.release(); //放弃指针控制权，返回裸指针delete p; lambda表达式C++11引入lambda表达式以创建匿名函数。 语法定义 1[捕获参数] (函数参数列表) mutable 或 exception 声明 -&gt; 返回值类型 &#123;函数体&#125; 一个栗子： 1234567int a = 1;auto func = [a] (int x) -&gt; int &#123;return a + x&#125;; // -&gt; int 显式指定了返回类型，当返回void或者编译器可以自动推断时，可以省略cout &lt;&lt; func(3) &lt;&lt; endl; // 按值捕获输出4auto func_2 = [&amp;a] (int x) &#123;return a + x&#125;;a = 2;cout &lt;&lt; func_2(3) &lt;&lt; endl; // 按引用捕获输出5 [捕获参数] 标志lambda表达式的开始，不捕获时为空。可以按照值捕获也可以按引用捕获。一些例子： [] 不捕获变量 [a, &amp;b] 按值捕获a，引用捕获b [this] 按值捕获this指针 [=] 按值捕获所有外部变量 [&amp;] 按引用捕获所有外部变量 [=, &amp;a] 按引用捕获a，其余变量按值捕获 [&amp;, =a] 按值捕获a，其余变量按引用捕获 mutable 或 exception 声明可以省略。按值传递函数对象参数时，加上 mutable 修饰符后，可以修改传递进来的拷贝（注意是能修改拷贝，而不是值本身），exception 声明用于指定函数抛出的异常，如抛出整数类型的异常，可以使用 throw(int)。 正则表达式正则表达式是文本搜索时进行匹配的一种规则。 单独字符，匹配字符本身。 转义字符，例如 ‘\\n’ 匹配换行符， ‘\\t’ 匹配制表符。 特殊字符，’^’ 匹配开头，’$’匹配结尾， ‘^hello$’就可匹配只含有hello的内容 [abc] 匹配其中的任意单个字符 [a-z] 匹配所有小写字母 [0-9] 匹配所有单个数字 []中的内容加 ‘^’ 可以取反，即表示不匹配。 12[^abc] 表示不匹配a，b，c[^a-z] 表示不匹配小写字母 []]可以连用，例如 1[a-z][0-9] 特殊字符 1234567&#39;.&#39; 可以匹配除换行符以外的任意字符\\d 等价于 [0-9]\\D 等价于 [^0-9]\\s 匹配所有空白字符\\S 匹配所有非空白字符\\w 匹配字母数字和下划线\\W 匹配非字母数字和下划线 x{n,m}代表前面内容出现次数重复n~m次 12345678a&#123;4&#125; 匹配aaaaa&#123;2,4&#125; 匹配aa或aaa或aaaaa&#123;2,&#125; 匹配长度大于等于2的[a-z]&#123;5,12&#125; 代表为长度为5~12的英文字母组合.&#123;5&#125; 所有长度为5的字符? 等价&#123;0,1&#125;+ 等价&#123;1,&#125;* 等价&#123;0,&#125; 或连接符 匹配模式可以使用 ‘|’ 进行连接 12(Chapter|Section) [1-9][0-9]? 可以匹配Chapter 1、Section 10等0\\d&#123;2&#125;-\\d&#123;8&#125;|0\\d&#123;3&#125;-\\d&#123;7&#125; 可以匹配010-12345678、0376-2233445 使用 ()改变优先级 12m|food 可以匹配m 或者 food(m|f)ood 可以匹配mood 或者 food 以()标识的部分被称作分组 123456* 正则表达式匹配后，每个分组的内容将被捕获* 用于提取关键信息，例如version(\\d+)即可捕获版本号* 分组会按顺序标号* 0号永远是匹配的字符串本身* (a)(pple) 0号为apple 1号为a 2号为pple使用(?:pattern)可以不捕获该分组 预查 后向引用 贪婪与懒惰 to do 原生字符串 12345正则表达式中往往会有很多\\，字符串表示时应写成\\\\原生字符串可以取消转义，保留字面值语法：R&quot;(str)&quot; 表示str的字面值&quot;\\\\d+&quot; &#x3D; R&quot;(\\d+)&quot; &#x3D; \\d+ 正则表达式库regex正则表达式匹配的三种模式 匹配 询问字符串是否能匹配正则表达式，并捕获相应分组 regex_match 替换 替换字符串中匹配的子串，并替换成相应内容 regex_replace 搜索 搜索字符串中匹配的子串，并捕获相应分组 regex_search 栗子 123456789string s(\"subject\");regex e(R\"(sub)(.*)\");smatch sm;regex_match(s,sm,e);cout &lt;&lt; sm.size() &lt;&lt; \" matches\\n\";cout &lt;&lt; \"the matches were: \";for (unsigned i=0; i&lt;sm.size(); ++i) &#123; cout &lt;&lt; \"[\" &lt;&lt; sm[i] &lt;&lt; \"] \"；&#125; 输出：3 matchesthe matches were: [subject] [sub] [ject] 关于regex库更详细的用法需要参考专业资料。","categories":[],"tags":[{"name":"OOP","slug":"OOP","permalink":"http://believebest35.github.io/tags/OOP/"}]},{"title":"面向对象_模版和STL初步","slug":"OOP-THU-7","date":"2020-10-13T02:31:17.000Z","updated":"2020-10-13T12:14:52.676Z","comments":true,"path":"2020/10/13/OOP-THU-7/","link":"","permalink":"http://believebest35.github.io/2020/10/13/OOP-THU-7/","excerpt":"函数模板和类模板继承和组合提供了重用对象代码的方法，而模板特征则提供了重用源代码的方法。 首先考虑下面的一个问题： 1234void sort(int *data, int len);void sort(float *data, int len);void sort(my_class *data, int len);// ...","text":"函数模板和类模板继承和组合提供了重用对象代码的方法，而模板特征则提供了重用源代码的方法。 首先考虑下面的一个问题： 1234void sort(int *data, int len);void sort(float *data, int len);void sort(my_class *data, int len);// ... 以上的排序算法的实现细节是一致的，仅仅只有数据（对象）的类型不同，因此有必要通过某种方式来重用代码。因此需要引入模板特征。模板可以分为： 函数模板 类模板 成员函数模板 函数模板有些函数的实现与类型无关，因此可以将类型设置为一种特殊的“参数”，这样就可以得到函数模板。 定义函数模板的方法： 12template&lt;typename T&gt; returnTypeFunc(Args) returnType表示函数模板将会返回的类型，也可以写成template表示的，说明返回的类型也不确定。 简单的相加函数模板就可以定义如下： 12345template&lt;typename T&gt;T sum(T a, T b)&#123; return a + b;&#125; 函数模板在实际调用时会根据调用参数的实际类型实例化为一个普通函数，但是需要实际的类型能够满足函数的运算要求，例如上例中要求对象类型可以进行加法运算。 也可以同时指定多个模版参数，例如： 12345template&lt;typename T1, typename T2&gt;T1 sum(T1 a, T2, b)&#123; return a + b;&#125; 以上要求两个类型之间可以进行相加并可进行类型转换。 可以手动指定调用类型 1cout &lt;&lt; sum&lt;int&gt;(1 + 2) &lt;&lt; endl; 类模版在定义类时也可以用一些模板参数使得类更具有通用性，示例如下： 12345678910111213141516171819202122template&lt;typename T&gt;class A&#123;private: T data;public: void func_1() &#123; cout &lt;&lt; data &lt;&lt; endl; &#125; void func_2();&#125;;template&lt;typename T&gt;void A&lt;T&gt;::func_2() // 模版类成员函数的类外定义，模版声明必须加上，否则编译报错&#123; cout &lt;&lt; data &lt;&lt; endl;&#125;int main()&#123; A&lt;int&gt; a; a.func_1(); // ...&#125; 类模版的参数： 类型参数：使用typename或class进行标记 非类型参数：整数，枚举，指针（指向对象或函数），引用（引用对象或引用函数）等，其中整数用的比较多。示例： 1234567891011template&lt;typename T, unsigned size&gt;class array&#123; T data[size]; // ...&#125;;int main()&#123; array&lt;int, 10&gt; arr;&#125; 成员函数模板普通类的成员函数也可以定义函数模，示例： 12345678910111213141516171819class normal_class&#123;public: int value; /// 在类内定义 template&lt;typename T&gt; void set(T const&amp; v) &#123; value = int(v); &#125; template&lt;typename T&gt; T get();&#125;;template&lt;typename T&gt; /// 在类外定义T normal_class::get()&#123; return T(value); &#125; 既可以在类中定义，也可以在类外进行定义。 普通类模板的成员函数，也可有额外的模板参数。示例： 123456789101112131415161718192021222324252627282930template&lt;typename T0&gt;class A&#123; T0 value; public: /// 在类内定义 template&lt;typename T1&gt; void set(T1 const&amp; v) &#123; value = T0(v); &#125; template&lt;typename T1&gt; T1 get();&#125;;/// 类外定义template&lt;typename T0&gt; template&lt;typename T1&gt; // 后面的template&lt;typename T1&gt;表示该函数的返回类型不确定T1 A&lt;T0&gt;::get()&#123; return T1(value);&#125;/// 注意以下写法是错误的/*template&lt;typename T0, typename T1&gt; T1 A&lt;T0&gt;::get()&#123; return T1(value);&#125;*/ 总结： 多个参数的类模板： 12template&lt;typename T0, typename T1&gt; class A &#123;&#125; 多个参数的函数模板 12template&lt;typename T0, typename T1&gt; void func( T0 a1, T1 a2 ) &#123;&#125; 函数模板特化有些类型当前的函数模板不能进行处理，因此需要对模版进行特殊化处理，这称为函数模板特化。函数模板特化需要提供所有模板参数的具体类型，不能进行部分特化，若要部分特化，则需要另开模板并重载。下面举一个栗子： 12345678// 泛型版本template &lt;class T&gt; int compare(const T &amp;v1, const T &amp;v2)&#123; if(v1 &lt; v2) return -1; if(v2 &gt; v1) return 1; return 0;&#125; 当实际参数为两个char型指针时，若要求比较的是char型指针指向内容的大小而不是地址大小，需要对上述函数模板进行特化。 123456// 特化版本template &lt;&gt; int compare&lt;const char *&gt;(const char * const &amp;v1, const char * const &amp;v2)&#123; return strcmp(v1, v2);&#125;// 远离C风格字符串。。。 函数特化的另外一个栗子： 1234567891011template&lt;typename T&gt;T div2(const T &amp;val)&#123; return val / 2;&#125;template&lt;&gt;int div2&lt;int&gt;(const int &amp;val)&#123; return val &gt;&gt; 1; // 整型除法&#125; 类模板特化对于类模板，允许部分特化，即部分限制模板的通用性，如通用模板为： 1template&lt;typename T1, typename T2&gt; class A &#123; ... &#125;; 部分特化 1template&lt;typename T1&gt; class A&lt;T1, int&gt; &#123;...&#125;; //指定第二个参数为int 全部特化 1template&lt;&gt; class A&lt;int, int&gt; &#123; ... &#125;; // 指定了所有参数 模板原理对于模板的处理是在编译时进行的，编译器每发现一个模板示例，就生成对应的代码。 需要注意的是，模板库必须在头文件中进行实现，不可以分开进行编译，因为若分开，则编译器不知道具体的函数模板实例如何初始化，会产生链接错误。 命名空间为了避免在大规模程序的设计中，以及在程序员使用各种各样的C++库时，标识符的命名发生冲突，标准C++引入了关键字namespace（命名空间），可以更好地控制标识符的作用域。 标准C++库（不包括标准C库）中所包含的所有内容（包括常量、变量、结构、类和函数等）都被定义在命名空间std（standard标准）中。 123456789101112131415161718// 定义命名空间namespace A&#123; int x, y;&#125;// 使用命名空间A::x = 3;A::y = 4;// 直接使用部分元素using A::x;x = 3;// 使用整个命名空间using namespace A;x = 3;y = 4; STL标准模板库，其中包含4个组件，分别为算法、容器、函数、迭代器。基于模板进行编写。 关键理念：将“在数据上执行的操作”与“要执行操作的数据”分离。 STL的命名空间为std。 关于STL中具体容器的介绍可直接查看文档。","categories":[],"tags":[{"name":"OOP","slug":"OOP","permalink":"http://believebest35.github.io/tags/OOP/"}]},{"title":"面向对象_虚函数与多态","slug":"OOP-THU-6","date":"2020-10-11T11:08:48.000Z","updated":"2020-10-13T12:16:44.553Z","comments":true,"path":"2020/10/11/OOP-THU-6/","link":"","permalink":"http://believebest35.github.io/2020/10/11/OOP-THU-6/","excerpt":"函数调用捆绑首先明确C++中捆绑的概念，捆绑（binding）指的是将函数的调用与函数的实现部分（函数体）相联系起来，即将函数体实现代码的入口地址与调用的函数名相绑定，程序执行到函数调用时会直接进入到函数实现代码。 捆绑可分为早捆绑和晚捆绑两个类别。","text":"函数调用捆绑首先明确C++中捆绑的概念，捆绑（binding）指的是将函数的调用与函数的实现部分（函数体）相联系起来，即将函数体实现代码的入口地址与调用的函数名相绑定，程序执行到函数调用时会直接进入到函数实现代码。 捆绑可分为早捆绑和晚捆绑两个类别。 早捆绑（early binding） 在程序运行之前（即编译时）已经确定了函数调用与具体的函数体之间的绑定关系，运行之前可以知道函数调用将会进入哪个函数体，这会导致如下的问题： 12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;class Instrument&#123;public: void play() &#123; cout &lt;&lt; \"Instrument::play\" &lt;&lt; endl; &#125;&#125;;class Wind : public Instrument&#123;public: void play() &#123; cout &lt;&lt; \"Wind::play\" &lt;&lt; endl; &#125; /// 重写隐藏&#125;;void tune(Instrument&amp; i)&#123; i.play();&#125;int main()&#123; Wind flute; tune(flute); /// 向上类型转换&#125; 以上的程序运行后实际会输出“Instrument::play”，这就是由于tune()中的i.play()和Instrument::play()的早捆绑所导致的。 晚捆绑（late binding） 与早捆绑相对应，晚捆绑发生在程序运行时，即程序运行之后才知道函数调用的所关联的具体函数体。晚捆绑只针对类中的虚函数起作用。 虚函数对于被派生类重新定义的成员函数，若它在基类中被声明为虚函数，则通过基类指针或引用调用该成员函数时，编译器将根据所指（或引用）对象的实际类型决定是调用基类中的函数，还是调用派生类重写的函数。虚函数定义说明如下： 123456class base&#123;public: virtual returnType Func(argument); // 虚函数定义 // ...&#125; 只要某成员函数在基类中被声明为虚函数，其派生类中的同名同参数成员函数（重写覆盖）也会是虚函数（不论在派生类中是否声明为虚函数）。 使用虚函数，早捆绑的问题即可解决，示例如下： 12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;class Instrument&#123;public: virtual void play() &#123; cout &lt;&lt; \"Instrument::play\" &lt;&lt; endl; &#125;&#125;;class Wind : public Instrument&#123;public: void play() &#123; cout &lt;&lt; \"Wind::play\" &lt;&lt; endl; &#125; /// 重写覆盖&#125;;void tune(Instrument&amp; i)&#123; i.play(); // 函数运行到这时根据i的实际类型调用对应的函数，实现了动态多态。&#125;int main()&#123; Wind flute; tune(flute); /// 向上类型转换&#125; 实际会输出“wind::play”。 注意晚捆绑只对指针或者引用类型有效。 虚函数表程序运行时对象要保存自身实际类型的信息，这些信息存储在虚函数表里。 虚函数表：每个包含虚函数的类用于存储虚函数地址的表。 每个包含虚函数的类的对象均有一个指向该类虚函数地址的指针（虚函数指针，vpointer/VPTR），当发生虚函数调用的时候通过虚函数指针获取虚函数表地址，然后在虚函数表中查询对应的虚函数实现代码的地址，以实现晚绑定。 若派生类中某虚函数fun()没有进行重写覆盖，则派生类和基类中的虚函数表fun()指向同一个虚函数体。 虚函数与构造函数包含虚函数的对象初始化时需要设置虚指针，虚函数指针的初始化由构造函数自动的进行，不需要程序员显式写出。需要注意的是，构造函数不能也不必要声明为虚函数。 讲义之中有说明在构造函数中调用虚函数的情况，实际运行的函数会是虚函数的本地版本（当前类的版本），即虚函数多态的机制失效。因为派生类中最先进行初始化的是基类的成员，若调用实际类的虚函数可能会使用到未初始化的派生类成员，导致未定义的行为。 若不理解上述原因也无所谓，尽量不要在构造函数中调用虚函数，这时虚函数的机制失效，没有实际的意义。 虚函数与析构函数析构函数能声明为虚函数，且常常是虚的。 虚析构函数的作用在于当删除基类类型的指针时，编译器将根据指针所指对象的实际类型来调用对应的析构函数，防止出现内存泄漏的错误。 同样的，尽量不要在析构函数中调用虚函数。 重要原则：总是将基类的析构函数设置为虚析构函数。 重写覆盖重写覆盖（override）：派生类重新定义基类中的虚函数，函数名必须相同，函数参数必须相同，返回值一般情况应相同。派生类的虚函数表中原基类的虚函数指针会被派生类中重新定义的虚函数指针覆盖掉。 重写隐藏（redefining）：派生类重新定义基类中的函数，函数名相同，但是参数不同或者基类的函数不是虚函数(参数相同+虚函数-&gt;不是重写隐藏)。虚函数表不会发生覆盖。 重写覆盖和重写隐藏： 相同点： 都要求派生类定义的函数与基类同名。 都会屏蔽基类中的同名函数，即派生类的实例无法调用基类的同名函数。 不同点： 重写覆盖要求基类的函数是虚函数，且函数参数相同，返回值一般情况应相同；重写隐藏要求基类的函数不是虚函数或者函数参数不同。 重写覆盖会使派生类虚函数表中基类的虚函数的指针被派生类的虚函数指针覆盖。重写隐藏不会。 重写覆盖与重写隐藏的示例如下： 12345678910111213141516171819class Base&#123;public: virtual void foo() &#123; cout&lt;&lt;\"Base::foo()\"&lt;&lt;endl; &#125;; virtual void foo(int )&#123; cout&lt;&lt;\"Base::foo(int )\"&lt;&lt;endl; &#125;; ///重载 void bar() &#123;&#125;;&#125;;class Derived1 : public Base&#123;public: void foo(int ) &#123; cout&lt;&lt;\"Derived1::foo(int )\"&lt;&lt;endl; &#125;; /// 重写覆盖&#125;;class Derived2 : public Base &#123;public: void foo(float ) &#123; cout&lt;&lt;\"Derived2::foo(float )\"&lt;&lt;endl; &#125;; /// 参数不一致，不是重写覆盖，是重写隐藏&#125;; Override关键字重写覆盖要求的条件很多，首先必须是重定义基类中的虚函数，并且要求参数相同，可以使用override关键字显式的告诉编译器进行重写覆盖，编译器将对重写覆盖要满足的条件进行检查，正确的重写覆盖才能通过编译。 1234567class Derived2 : public Base&#123;public: void foo(int ) override &#123; // ... &#125;; 是Base中的虚函数，并且参数一致 //void foo(float ) override &#123;&#125;; /// 参数不同，不是重写覆盖，编译错误 //void bar() override &#123;&#125;; /// bar 非虚函数，编译错误 &#125; 以上是使用override关键字的示例。 final关键字有些时候不希望虚函数在派生类中被重写，或者不希望有些类被继承，这时可以使用final关键字。 final关键字在虚函数声明或者虚函数定义时使用可以确保后续的派生类中不可以重写派生类，final关键字在类定义的时候使用会指定该类不可以被继承。示例如下： 12345678910111213141516171819202122232425262728class Base&#123;public: virtual void func() &#123;&#125;; // 基类中声明为虚函数 // ...&#125;;class A : public Base&#123;public: void func() final &#123; /* ... */ &#125; // 在类A中用final指定func()， 则func()不可以被类A的派生类进行改写 // void func_2() final &#123; /* ... */ &#125; /// func_2()不是虚函数，因此不能被final指定 // ...&#125;;class B final : public A // 将类B声明为final，即类B不能作为基类被继承&#123;public: // void func() &#123;&#125; /// func()已经在类A中声明为final了，不允许后续的类进行改写&#125;;/*class C : public B&#123; // ...&#125;;*///类B已经声明为final了，不允许后续的类对类B进行继承 纯虚函数虚函数可以通过如下的形式声明为纯虚函数。 1virtual returnType func(argument) = 0; 含有纯虚函数的类被称为抽象类，抽象类不允许定义具体的对象，定义抽象类的主要目的是为后续的派生类规定共性的接口。 纯虚函数可以在类外提供默认实现，示例如下： 123456789class Base&#123;public: virtual void func() = 0;&#125;;void Base::func()&#123; // ...&#125; 抽象类不允许定义对象，但允许定义抽象类的指针和引用并指向派生类对象，这样就保证只有指针和引用可以被向上类型转换。 当继承一个抽象类时，必须实现所有的纯虚函数，否则派生类仍然是一个抽象类，纯虚析构函数除外。 纯虚析构函数纯虚析构函数必须有函数体，即必须在抽象类的定义之外显式说明函数体。 定义纯虚析构函数的目的在于使基类成为抽象类，但若基类中有其他纯虚函数，则析构函数不必定义为虚的。 派生类中不需要显式实现纯虚析构函数，因为编译器可以自动合成析构函数。 1234567891011121314class Base&#123;public: virtual ~Base() = 0;&#125;;Base::~Base() &#123;&#125; // 纯虚析构函数必须显式说明函数体class A : public Base &#123;&#125;;int main()&#123; // Base b; /// 报错 A a; // 没有报错，但若没有显式说明基类中纯虚析构函数的函数体，则无法通过编译（编译阶段不会报错，错误在链接阶段产生）&#125; 向下类型转换基类指针或者引用转换为派生类指针或者引用被称为向下类型转换。要确保转换的正确性则必须借助虚函数表进行动态类型检查。示例如下： 1234567891011121314151617181920212223242526272829303132333435363738class Pet &#123; public: virtual ~Pet() &#123;&#125; &#125;;class Dog : public Pet&#123; public: void run() &#123; cout &lt;&lt; \"dog run\" &lt;&lt; endl; &#125;&#125;;class Bird : public Pet&#123;public: void fly() &#123; cout &lt;&lt; \"bird fly\" &lt;&lt; endl; &#125;&#125;;void action(Pet* p)&#123; auto d = dynamic_cast&lt;Dog*&gt;(p); /// 向下类型转换 auto b = dynamic_cast&lt;Bird*&gt;(p); /// 向下类型转换 if (d) /// 运行时根据实际类型表现特性 d-&gt;run(); else if(b) b-&gt;fly();&#125;int main()&#123; Pet* p[2]; p[0] = new Dog; /// 向上类型转换 p[1] = new Bird; /// 向上类型转换 for (int i = 0; i &lt; 2; ++i) &#123; action(p[i]); &#125;&#125; C++提供了一种安全的向下类型转换，即dynamic_cast，使用dynamic_cast必须有虚函数，因为它使用了存储在虚函数表中的信息判断实际的类型。 使用方法为： 1234// T1* obj_p = .....// T1&amp; obj_r = .....T2* pObj = dynamic_cast&lt;T2*&gt;(obj_p); //转换为T2指针，运行时失败返回nullptrT2&amp; refObj = dynamic_cast&lt;T2&amp;&gt;(obj_r); //转换为T2引用，运行时失败抛出bad_cast异常 要注意的是T1必须是带有虚函数（声明或者继承而来的）的类（T1必须是多态类型），否则编译会报错，T2不必是带有虚函数的类。T1，T2没有继承关系时转换会出错。 如果知道要转换的类型种类，可以使用static_ cast，static_cast在编译时静态浏览类层次，只检查继承关系。没有继承关系的类之间，必须具有转换途径才能进行转换（要么自定义，要么是语言语法支持），否则不过编译。运行时无法确认是否正确转换。 使用方法为： 1234// T1* obj_p = .....// T1&amp; obj_r = .....T2* pObj = static_cast&lt;T2*&gt;(obj_p); //转换为T2指针T2&amp; refObj = static_cast&lt;T2&amp;&gt;(obj_r); //转换为T2引用 static_cast不会做类型检查，因此不能保证转换后实际指向的对象类型为T2。 一般来说，建议使用dynamic_cast来进行向下类型转换。 几条重要的原则 指针或者引用的向上类型转换总是安全的。 向下类型转换时尽量使用dynamic_cast。 尽量不做对象的转换。 向上向下类型转换与虚函数表若基类中含有虚函数： 对于向上类型转换，派生类指针或者引用转换为基类指针或者引用，其虚函数表仍然绑定为派生类的虚函数表（晚绑定）。派生类对象转换为基类对象，则其虚函数表绑定为基类的虚函数表。 对于向下类型转换则可以通过检查虚函数表来判断是否可以进行向下类型转换。 多态以上所说的概念均是为多态所服务的，多态指的是：按照基类的接口定义，调用指针或引用所指对象的接口函数，函数执行过程因对象实际所属派生类的不同而呈现不同的效果（表现）。 当利用指针或者引用调用函数时，虚函数在运行时才确定具体的函数实现代码，取决于所指向对象的真实类型（晚绑定）。非虚函数在编译时就已进行绑定（早绑定）。 当利用对象作为参数直接调用函数时，无论什么函数均在编译时进行绑定。 所以产生多态的效果为：继承 &amp;&amp; 虚函数 &amp;&amp; （引用或指针） 多态使得C++语言可以用一段相同的代码，在运行时完成不同的任务，这些不同运行结果的差异由派生类之间的差异决定。好处在于通过基类定好接口后，不必对每一个派生类特殊处理，只需要调用抽象基类的接口即可。大大提高程序的可复用性。不同派生类对同一接口的实现不同，能达到不同的效果，提高了程序可拓展性和可维护性。 一个多态的示例如下： 123456789101112131415161718192021222324252627282930313233343536373839class Animal&#123; public: void action() &#123; speak(); motion(); &#125; virtual void speak() &#123; cout &lt;&lt; \"Animal speak\" &lt;&lt; endl; &#125; virtual void motion() &#123; cout &lt;&lt; \"Animal motion\" &lt;&lt; endl; &#125;&#125;;class Bird : public Animal&#123;public: void speak() &#123; cout &lt;&lt; \"Bird singing\" &lt;&lt; endl; &#125; void motion() &#123; cout &lt;&lt; \"Bird flying\" &lt;&lt; endl; &#125;&#125;;class Fish : public Animal&#123;public: void speak() &#123; cout &lt;&lt; \"Fish cannot speak ...\" &lt;&lt; endl; &#125; void motion() &#123; cout &lt;&lt; \"Fish swimming\" &lt;&lt; endl; &#125;&#125;;int main()&#123; Fish fish; Bird bird; fish.action(); ///不同调用方法 bird.action(); Animal *pBase1 = new Fish; Animal *pBase2 = new Bird; pBase1-&gt;action(); ///同一调用方法，根据 pBase2-&gt;action(); ///实际类型完成相应动作 return 0;&#125; 多态的一个典型应用就是TEMPLATE METHOD设计模式。 在接口的一个方法中定义算法的骨架。 将一些步骤的实现延迟到子类中。 使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。 多重继承一个类同时继承多个类称为多重继承。多重继承会有多个虚函数表，几重继承，就会有几个虚函数表。这些表按照派生的顺序依次排列。 如果子类改写了父类的虚函数，那么就会用子类自己的虚函数覆盖虚函数表的相应位置，如果子类有新的虚函数，那么就添加到第一个虚函数表的末尾。 多重继承的可以同时结合多个接口，但会导致二义性的问题，即派生类继承的两个基类若含有同名成员，则会导致编译器无法判断。另外一个问题则是钻石型继承带来的数据冗余问题。 实践中，最好只继承一个非抽象类，可以继承多个抽象类。 OOP核心思想OOP的核心思想是数据抽象、继承与动态绑定。 数据抽象：类的接口与实现分离 继承：建立相关类型的层次关系（基类与派生类）函数重写，虚函数 动态绑定：统一使用基类指针，实现多态行为类型转换，模板","categories":[],"tags":[{"name":"OOP","slug":"OOP","permalink":"http://believebest35.github.io/tags/OOP/"}]},{"title":"面向对象_组合与继承","slug":"OOP-THU-5","date":"2020-10-09T12:31:17.000Z","updated":"2020-10-13T12:17:07.990Z","comments":true,"path":"2020/10/09/OOP-THU-5/","link":"","permalink":"http://believebest35.github.io/2020/10/09/OOP-THU-5/","excerpt":"组合小的对象组合起来可以形成更大的对象，若对象a是对象b的一个组成部分，则可以说对象b是对象a的整体对象，对象a是对象b的部分对象。对象组合一般有两种实现方法： 将已有的类（对象a）定义为新定义的类（对象b）的公有成员，则可以通过访问原有的类提供旧的接口。 将已有的类定义为新定义的类的私有成员，这样新的类就必须提供新的接口用以访问旧的类，相当于对接口做了变换。","text":"组合小的对象组合起来可以形成更大的对象，若对象a是对象b的一个组成部分，则可以说对象b是对象a的整体对象，对象a是对象b的部分对象。对象组合一般有两种实现方法： 将已有的类（对象a）定义为新定义的类（对象b）的公有成员，则可以通过访问原有的类提供旧的接口。 将已有的类定义为新定义的类的私有成员，这样新的类就必须提供新的接口用以访问旧的类，相当于对接口做了变换。 以上的实现形式如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940class A&#123;private: int i;public: void set_i(int x) &#123; i = x; &#125;&#125;;class B&#123;private: int i;public: void set_i(int x) &#123; i = x; &#125;&#125;;class C&#123;private: A a;public: B b; void setA(int x) &#123; a.set_i(x); &#125;&#125;;int main()&#123; C c; c.b.set(0); c.setA(0);&#125; 子对象构造时若需要参数，则应在当前类的构造函数的初始化列表中进行初始化。 继承继承即是从一般到特殊的过程，若类A具有类B全部的数据成员以及对应的接口函数，除此之外还拥有一些自己独有的某些数据成员以及接口函数，则称类A继承与类B。 被继承的已有的类，被称为基类（base class），或者叫做父类。 继承定义出的新的类，被称为派生类（derived class），亦称作子类、扩展类。 常见的继承方式： public继承，定义形式如下所示： 1234class derived_class: public base_class&#123; // ...&#125; private继承，定义形式如下所示： 1234class derived_class: private base_class&#123; // ...&#125; private继承也是默认的继承方式。 protected继承，定义形式如下所示： 1234class derived_class: protected base_class&#123; // ...&#125; 最后一种继承方式很少使用。 派生类对象的构造和析构派生类对象的构造过程中首先初始化的是原属于基类的数据成员，需要调用原属于基类的构造函数来进行初始化。若没有显式调用则会自动调用属于基类的默认构造函数，若显式调用则只能在派生类的构造函数的初始化成员列表中进行调用。基类的数据成员初始化完毕之后再执行派生类的的构造函数。 对象析构时，派生类析构函数先执行，后续再执行基类的析构函数。 1234567891011121314class base&#123;private: int x;public: base(): x(0) &#123;&#125; base(int i): x(i) &#123;&#125;&#125;;class derived: public base&#123;public: derived(int i): base(i) &#123;&#125;&#125; 如上所示，派生类构造函数中显式调用基类的构造函数必须在初始化列表中进行。 继承基类构造函数在派生类中使用using Base::Base; 来继承基类构造函数，相当于给派生类“定义”了相应参数的构造函数。示例如下： 1234567891011121314151617181920class Base&#123; int data;public: Base(int i) : data(i) &#123;&#125; //Base(int i, int j) : data(i + j) &#123;&#125;&#125;;class Derive : public Base&#123;public: using Base::Base; ///相当于 Derive(int i):Base(i)&#123;&#125;; ///当基类存在多个构造函数时，使用using也会给派生类生成多个对应的构造函数，相当于 Derive(int i, int j):Base(i + j)&#123;&#125;&#125;;int main()&#123; Derive obj(356); return 0;&#125; 上述代码在c++11的情况下通过编译，mac自带的clang似乎不能通过编译。。 继承方式的选择 public继承 基类中的公有成员在派生类中仍然能保持公有，原有的接口仍能使用，是最为常用的一种继承方式。 private继承 通常很少使用，可通过组合替代。 protected继承 基本不使用，存在只是为了语言的完备性。 基类成员访问权限与三种继承方式 public继承 基类的公有成员，保护成员，私有成员作为派生类的成员时，都保持原有的状态。 private继承 基类的公有成员，保护成员，私有成员作为派生类的成员时，都作为私有成员。 protected继承 基类的公有成员，保护成员作为派生类的成员时，都成为保护成员，基类的私有成员仍然是私有的。 重写隐藏重写隐藏指的是在派生类中重新定义基类的函数，这样会屏蔽掉基类中的同名函数。 重写隐藏发生时基类中该同名函数的所有重载函数都会被屏蔽掉。可以在派生类中通过using 类名::成员函数名; 在派生类中“恢复”指定的基类成员函数（即去掉屏蔽），使之重新可用。 向上类型转换派生类对象/引用/指针转换成基类对象/引用/指针，称为向上类型转换，只对public继承有效。 凡是接受基类对象/引用/指针的地方（如函数参数），都可以使用派生类对象/引用/指针，编译器会自动将派生类对象转换为基类对象以便使用。 当派生类的对象(不是指针或引用)被转换为基类的对象时，派生类的对象被切片为对应基类的子对象，即会产生派生类对象数据的丢失。","categories":[],"tags":[{"name":"OOP","slug":"OOP","permalink":"http://believebest35.github.io/tags/OOP/"}]},{"title":"面向对象_引用与复制","slug":"OOP-THU-4","date":"2020-10-07T02:36:23.000Z","updated":"2020-10-13T12:17:47.854Z","comments":true,"path":"2020/10/07/OOP-THU-4/","link":"","permalink":"http://believebest35.github.io/2020/10/07/OOP-THU-4/","excerpt":"引用 引用是对于某个具体变量或者对象的别名，定义为：类型 &amp; 引用名 = 变量名，一个引用的定义示例如下： 12int a;int &amp;ra = a; 上述定义了一个指向变量a的引用ra，ra和a都是内存中统一单元的不同名字。引用在定义时必须进行初始化（即赋初值）。","text":"引用 引用是对于某个具体变量或者对象的别名，定义为：类型 &amp; 引用名 = 变量名，一个引用的定义示例如下： 12int a;int &amp;ra = a; 上述定义了一个指向变量a的引用ra，ra和a都是内存中统一单元的不同名字。引用在定义时必须进行初始化（即赋初值）。 函数的返回值也可以是引用类型，但是不能返回函数类的临时变量，否则编译器会抛出警告。 引用的优势： 更加灵活的支持运算符的重载。 创建时必须初始化，不存在空引用。 参数中的常量和常量引用某些函数在运行中仅仅需要用到参数的值而并不需要修改，因此可以通过传入常量引用的形式，限制子程序对传入的参数进行修改，示例如下： 12345void f(const int &amp;a, const int &amp;b)&#123; // a = 1; wrong // ...&#125; 上述函数中仅能读取参数a，b的值，并不允许修改。 拷贝构造函数拷贝构造函数是一类特殊的构造函数，其参数为同类对象的常量引用（不一定是常量引用？），一个典型的拷贝构造函数示例如下： 1234567891011121314class Sample&#123;private: int x, y; // ...public: Sample(const Sample &amp;S) &#123; x = S.x; y = S.y; // ... &#125; // ...&#125;; 拷贝构造函数一般在如下情况会被调用： 用一个类对象定义一个新的类对象，例如 123Sample s1;Sample s2(s1);Sample s3 = s1; 函数调用时以对象而不是引用作为参数。 函数返回类对象。 若类在定义时没有显式定义拷贝构造函数，编译器在需要时会自行产生拷贝构造函数，采用的形式为“位拷贝”（浅拷贝），即拷贝成员的地址而非内容，这就容易导致内存泄漏，特别是当数据成员之中含有指针类型的时候。 因此，程序设计中应该尽量减少使用拷贝构造函数。主要的解决方法有： 尽量使用引用/常量引用作为函数参数和函数返回类型。 将拷贝构造函数声明为private成员。 使用delete显式删除拷贝构造函数。 右值引用为此需要先说明左值和右值。 左值：可以取地址、有名字的值。 右值：不能取地址、没有名字的值，常见于常值、函数返回值以及表达式等。 举一个简单的栗子： 12345int a = 0, b = 0;int &amp;ra = a; // rightint *pa = &amp;a; // rightint &amp;ra_b = a + b; // wrongint *pa_b = &amp;(a + b); // wrong 后两个语句编译器会抛出错误，说明右值不能取地址以及被左值引用（&amp;）。 C++11中引入了右值引用的概念。右值引用的形式如下所示： 123int a = 0, b = 0;int &amp;&amp;ra_b = a + b; // rightint &amp;&amp;ra = a; // wrong 如示例所示，右值引用可以绑定到右值上，但不能绑定到左值上，即左值引用绑定左值，右值引用绑定右值，例外是左值常量引用可以绑定右值。 补充一个示例： 123456789void f(const int &amp;a)&#123; // ...&#125;int main()&#123; f(3);&#125; 以上示例不会抛出错误，说明常引用可以绑定到右值上（因为const保证了参数不会被修改）。 右值引用可以延长即将销毁变量的生命周期。 移动构造函数使用右值引用作为参数的构造函数叫做移动构造函数。 移动构造函数与拷贝构造函数最大的区别在于移动构造函数直接利用了原来临时对象中的堆内存，新的对象无需开辟内存，临时对象无需释放内存。 举一个简单的栗子： 12345678910111213141516171819202122232425262728class demo&#123;public: demo():num(new int(0)) &#123; cout&lt;&lt;\"construct!\"&lt;&lt;endl; &#125; //拷贝构造函数 demo(const demo &amp;d):num(new int(*d.num)) &#123; cout&lt;&lt;\"copy construct!\"&lt;&lt;endl; &#125; ~demo() &#123; cout&lt;&lt;\"class destruct!\"&lt;&lt;endl; &#125;private: int *num;&#125;;demo get_demo()&#123; return demo();&#125;int main()&#123; demo a = get_demo(); return 0;&#125; 以上的过程会多次调用拷贝构造函数，临时对象所占用的资源被浪费。 下面的示例引入了移动构造函数： 12345678910111213141516171819202122232425262728293031public: demo():num(new int(0)) &#123; cout&lt;&lt;\"construct!\"&lt;&lt;endl; &#125; demo(const demo &amp;d):num(new int(*d.num)) &#123; cout&lt;&lt;\"copy construct!\"&lt;&lt;endl; &#125; //添加移动构造函数 demo(demo &amp;&amp;d):num(d.num) &#123; d.num = NULL; cout&lt;&lt;\"move construct!\"&lt;&lt;endl; &#125; ~demo() &#123; cout&lt;&lt;\"class destruct!\"&lt;&lt;endl; &#125;private: int *num;&#125;;demo get_demo()&#123; return demo();&#125;int main()&#123; demo a = get_demo(); return 0;&#125; 移动构造函数采用了浅拷贝的方式，直接接管临时对象所占用的资源，避免了无谓的销毁以及申请资源的开销。 右值引用：移动语义有时候需要对左值调用移动构造函数，std提供了move() move可以解引用，即将左值转化为右值，原变量转化为未初始化状态。示例如下： 123Sample a;// ...Sample b = std::move(a); // a之后不会被使用 赋值运算符不同对象之间的赋值可通过重载赋值运算符来实现，示例如下： 12345678910111213141516class_name&amp; operator= (const class_name &amp;right)&#123; if (this != &amp;right) &#123; // ... 具体的赋值操作 &#125; return *this;&#125;int main()&#123; class_name a, b; // ... a = b; // 调用赋值运算 class_name c = a; // 拷贝构造&#125; 自动类型转换当出现对象类型不匹配的时候，需要进行类型转换，即实现从源类到目标类的转换，两个类之间的自动类型转换有如下两种实现方式： 在源类中定义目标类转换运算符，示例如下： 123456789101112class Src&#123;private: // ...public: operator Dst() const &#123; // ... return Dst(); &#125; &#125; 在目标类中定义以源类为参数的构造函数，示例如下： 12345678910class Dst&#123;private: // ...public: Dst(const Src &amp;s) &#123; // ... &#125;&#125; 以上方法只能同时使用一种，个人偏向于使用第二种。 使用关键字explicit可以禁止自动类型转换，即用explicit修饰类型转换运算符或类型转换构造函数，具体如下： 123explicit operator Dst() const;// or explicit Dst(const Src &amp;s); 强制类型转换C++提供了四种类型的强制类型转换。 const_cast，去除类型的const或volatile属性。 static_cast，类似于C风格的强制转换。无条件转换，静态类型转换。 dynamic_cast，动态类型转换。如子类和父类之间的多态类型转换。 reinterpret_cast，仅仅重新解释类型，但没有进行二进制的转换。 对于C++提供的强制类型转换详解需要另查资料。","categories":[],"tags":[{"name":"OOP","slug":"OOP","permalink":"http://believebest35.github.io/tags/OOP/"}]},{"title":"面向对象_创建与销毁","slug":"OOP-THU-3","date":"2020-10-06T11:29:33.000Z","updated":"2020-10-13T12:18:10.475Z","comments":true,"path":"2020/10/06/OOP-THU-3/","link":"","permalink":"http://believebest35.github.io/2020/10/06/OOP-THU-3/","excerpt":"构造函数对象的初始化工作是由对象的构造函数来完成的。构造函数没有返回值类型，函数名和类名一致，并且允许重载，一个典型的构造函数的定义示例如下： 1234567891011class Student&#123; long ID;public: Student(long id) &#123; ID = id; &#125; Student(int year, int order) &#123; ID = year * 10000 + order; &#125; // ...&#125;;","text":"构造函数对象的初始化工作是由对象的构造函数来完成的。构造函数没有返回值类型，函数名和类名一致，并且允许重载，一个典型的构造函数的定义示例如下： 1234567891011class Student&#123; long ID;public: Student(long id) &#123; ID = id; &#125; Student(int year, int order) &#123; ID = year * 10000 + order; &#125; // ...&#125;; 构造函数也可以类外进行定义。不带任何参数的构造函数被称为默认构造函数，或是缺省构造函数。 构造函数的初始化列表构造函数可以使用初始化列表来对类成员进行初始化。位置出现在函数体左花括号之前、函数参数列表圆括号之后，以冒号作开头，使用数据成员(初始值)的形式。示例如下： 1234567891011class Student&#123; long ID;public: Student(long id) ID(id) &#123;&#125; Student(int year, int order) &#123; ID = year * 10000 + order; &#125; // ...&#125;; 委派构造函数构造函数的初始化列表中还可以调用其他构造函数，被称为委派构造函数。 123456789101112class Info&#123;public: Info() &#123; Init(); &#125; Info(int i) : Info() &#123; id = i; &#125; Info(char c) : Info() &#123; gender = c; &#125;private: void Init() &#123; .... &#125;// 其他初始化 int id &#123;2016&#125;; char gender &#123;'M'&#125;; ...&#125;; 就地初始化C++11支持对于类中非静态成员变量进行如下的初始化： 12345678910class A&#123;private: int a = 1; double b &#123;2.0&#125;; public: A() &#123;&#125; A(int i):a(i) &#123;&#125; A(int i, double j): a(i),b(j) &#123;&#125;&#125;; 显式删除构造函数可以使用delete显式的删除的某些构造函数，以防止出现某些未预期的未定义行为。举一个栗子： 12345678910111213class A&#123;private: int a = 1; double b &#123;2.0&#125;; char c = 'c';public: A() = default; // 显式声明默认构造函数 A(int i):a(i) &#123;&#125; A(char ch) = delete; &#125;;A a('c'); //删除了以char进行初始化的构造函数，可以避免一些工程上的二义性问题，因为char型可以被转为int型，删除之后编译器将禁止这样的未定义行为。 析构函数对象的销毁是由对象的析构函数来完成的，析构函数只有一个，并且不需要任何参数，在对象的生命期结束时自动调用。定义形式为： ~&lt;类名&gt; 具体示例如下： 123456789101112class ClassRoom&#123; int num; long* ID_list;public: ClassRoom() : num(0), ID_list(0); &#123; &#125; // ... ~ClassRoom() &#123; // 析构函数 if (ID_list) delete[] ID_list; // 释放内存 &#125;&#125;; 对于申请动态内存的变量需要显式定义析构函数来释放空间。 类中的静态成员 staticstatic修饰的类成员变量被称为静态数据成员，为属于该类的所有对象所共有，即所有对象中的这个数据域处在同一内存位置。一个简单的示例如下： 12345678910class Sample&#123;private: int x, y; static int count;public: // ...&#125;;int Sample::count = 0; 如上定义了一个属于所有Sample类对象的静态数据成员count，其必须在类外进行初始化。在工程中更为规范的做法是将类的静态数据成员的声明放在.h（头文件）中，具体的初始化放在.cpp（实现文件）中。 成员函数也可以被static修饰，在返回值前面添加static修饰的成员函数，称为类的静态成员函数，一个简单的示例如下： 1234567891011121314class Sample&#123;private: int x, y; static int count;public: static int show_count() &#123; return count; &#125; // ...&#125;;int Sample::count = 0; 类的静态成员既可以通过类名进行访问，也可以通过具体的对象进行访问。 需要注意的是类的静态成员函数不能访问类的非静态数据成员，因为静态成员函数在对象进行初始化之前已经分配了内存空间，并且为所有对象所共有，而非静态数据成员只有在对象进行实例化时才分配具体的空间。 类中的常量成员 const使用const修饰的数据成员称为类的常量数据成员，在一个对象的生命期中不可以被修改。常量数据成员的初始化可以通过以下形式进行： 构造函数的初始化列表进行初始化 就地初始化（C++11的新特性） 注意，不能在构造函数的函数体中对对象的常量数据成员进行赋值。 类的成员函数也可以使用const进行修饰，被称为类的常量成员函数，该成员函数不能改变类的数据成员。 123456789101112class Sample&#123;private: const int x;public: Sample(): x(0) &#123;&#125; const int show_x() &#123; // x = 1; wrong，const修饰的函数不允许修改数据成员 return x; &#125;&#125;; 常量静态数据成员类的数据成员既可以定义为常量，也可以定义为静态的，常量静态数据成员需要在类外进行初始化（int 类型和enum类型除外）。 对象的构造与析构 局部对象的构造与析构 局部对象在程序执行到该局部对象的便进行构造，在其作用域结束时进行析构。 全局对象的构造与析构 全局对象在main函数调用之前进行构造，在main函数执行return之后进行析构。 一般来说程序中需要尽量少使用全局对象。 函数静态对象的构造与析构 函数静态对象是指在函数内部定义的static对象。在程序执行到该局部静态对象的代码时被初始化，离开作用域不析构，第二次执行到该对象代码时，不再初始化，直接使用上一次的对象，在main函数结束后被析构。 参数对象的构造与析构 若传递的是形参，在进入子函数时形参对象进行构造，在离开子函数时进行析构，若传递的是引用，在进入子函数时不进行构造，离开也不进行析构，因为传递的是一个变量的“别名”。 因此函数参数尽可能使用引用传递，可以避免大对象的拷贝。","categories":[],"tags":[{"name":"OOP","slug":"OOP","permalink":"http://believebest35.github.io/tags/OOP/"}]},{"title":"面向对象_封装与接口","slug":"OOP-THU-2","date":"2020-10-05T13:03:07.000Z","updated":"2020-10-13T12:25:52.667Z","comments":true,"path":"2020/10/05/OOP-THU-2/","link":"","permalink":"http://believebest35.github.io/2020/10/05/OOP-THU-2/","excerpt":"函数重载同一名称的函数，有两个以上不同的函数实现，被称为“函数重载”，例如 123456789void print(const char *msg)&#123; cout &lt;&lt; \"message: \" &lt;&lt; msg &lt;&lt; endl;&#125;void print(int score)&#123; cout &lt;&lt; \"score = \" &lt;&lt; score &lt;&lt; endl;&#125;","text":"函数重载同一名称的函数，有两个以上不同的函数实现，被称为“函数重载”，例如 123456789void print(const char *msg)&#123; cout &lt;&lt; \"message: \" &lt;&lt; msg &lt;&lt; endl;&#125;void print(int score)&#123; cout &lt;&lt; \"score = \" &lt;&lt; score &lt;&lt; endl;&#125; 编译器将根据函数调用语句的实际参数来决定哪一个函数被调用，多个同名的函数实现之间必须保证至少有一个参数的类型不一样。 函数在定义时可以指定参数的默认值，程序在调用时若不提供参数则会使用默认的参数值，例如： 1234void print(const char *msg = \"hello world\")&#123; cout &lt;&lt; msg &lt;&lt; endl;&#125; 一些基础知识autoauto类型可以根据变量的上下文自动推断变量的类型。例如： 12auto i = 3; // i为整型auto a = 4.0f; // a为浮点数类型 追踪返回类型的函数可以将函数返回类型的声明信息放到函数参数列表的后面进行声明，如： 12345// 普通函数声明形式int func(char* ptr, int val);// 追踪返回类型的函数声明形式auto func(char* ptr, int val) -&gt; int; 追踪返回类型在原本函数返回值的位置使用auto关键字。 decltypedecltype可以对变量或表达式结果的类型进行推导，可以用来重用匿名类型，在泛型编程中结合auto，可用于追踪函数的返回值类型，如： 12345678struct &#123; int a;&#125; s;int main()&#123; decltype(s) s1; // 定义了一个与s同类型的结构体变量&#125; 结合auto和decltype可以推到函数的返回类型，一般用在泛型编程之中。 12345template &lt;typename _Tx, typename _Ty&gt;auto multiply(_Tx x, _Ty y) -&gt; decltype(_Tx * _Ty)&#123; return x * y;&#125; new / deletenew和delete运算符可以在程序运行过程中动态的申请和释放内存空间，如下： 1234int *a = new int; // 申请一个整型变量的空间int *arr = new int[10]; // 申请大小为10的整型数组空间delete a; //删除申请的单个变量delete[] arr; //删除申请的连续内存区域 nullptrC++11引入了nullptr，之前使用NULL表示空指针，NULL被定义为0，可以被视为一个整型变量，因此如下的代码会出现问题： 12345678910111213141516void f(int x, int y)&#123; //...&#125;void f(int x, double *y)&#123; //...&#125;int main()&#123; //... f(2, NULL); // wrong f(2, nullptr); // right&#125; 以上的代码会出现错误，因为在使用NULL表示空指针的时候常常容易忽略NULL也是一个int型常量，而nullptr表示严格意义上的空指针，因此不会出现二义性的错误。 基于范围的for循环举例说明： 12345678void f(vector&lt;int&gt; &amp;nums)&#123; for (auto num : nums) &#123; //... &#125; // 以上可以自动的遍历vector，同理可以推广到其他可迭代类型&#125; 对象对象具有静态特性以及动态特性。 静态特征：可以用某种数据来描述的属性 动态特征：对象表现的行为或具有的功能 用户自定义类型class一个class的定义示例如下： 123456789101112// matrix.h#ifndef __MATRIX_H__#define __MATRIX_H__class Matrix&#123;private: int data[6][6];public: void fill(char dir);&#125;;#endif 成员函数的声明一般放在类定义中，具体实现一般放在实现文件中，例如： 1234567// matrix.cpp#include \"matrix.h\"void Matrix::fill(char dir) //类外需要类名限定&#123; ... // 函数实现&#125; 成员函数的实现也可以放在类定义中，放在类定义中的成员函数会自动内联。 类的成员（数据、函数）可以根据需要分成组，不同组设置不同的访问权限。 public public修饰的成员可以在类外用“.”操作符访问。 private private是不指定成员访问权限时的默认权限，不可以在类外使用“.”运算符进行访问。 protected 有关继承时再进行讨论。 this指针所有成员函数的参数中，隐含着一个指向当前对象的指针变量，其名称为this。 12345678910class Matrix&#123;public: void fill(char dir) &#123; //... this -&gt; data[0][0] = 1; //等价于 data[0][0] = 1; &#125; ...&#125;; 类的运算符重载以一个例子进行说明，类定义如下： 12345678910111213141516171819202122232425class Sample&#123;private: int x, y; static int count;public: Sample(); Sample(int x1, int x2, int y1, int y2): x(x1 + x2), y(y1 + y2) &#123;&#125; Sample(int x1, int y1); ~Sample(); void change_x_y(int x1, int y1); friend Sample operator+ (const Sample &amp;s1, const Sample &amp;s2); // +的重载 声明为友元函数 Sample&amp; operator+= (Sample &amp;s); // += 的重载 friend istream&amp; operator&gt;&gt; (istream &amp;in, Sample &amp;dst); // &gt;&gt;的重载 声明为友元函数 friend ostream&amp; operator&lt;&lt; (ostream &amp;out, Sample &amp;src); // &lt;&lt;的重载 声明为友元函数 void display(); void display_cnt() &#123; count++; cout &lt;&lt; count &lt;&lt; endl; &#125;&#125;;int Sample::count = 0; 运算符+和+=的重载实现如下： 1234567891011121314Sample&amp; Sample::operator+=(Sample &amp;s)&#123; this -&gt; x += s.x; this -&gt; y += s.y; return *this;&#125;Sample operator+ (const Sample &amp;s1, const Sample &amp;s2)&#123; Sample sum; sum.x = s1.x + s2.x; sum.y = s1.y + s2.y; return sum;&#125; 流运算符的重载（&gt;&gt; , &lt;&lt;） 1234567891011istream&amp; operator&gt;&gt; (istream &amp;in, Sample &amp;dst)&#123; in &gt;&gt; dst.x &gt;&gt; dst.y; return in;&#125;ostream&amp; operator&lt;&lt; (ostream &amp;out, Sample &amp;src)&#123; out &lt;&lt; src.x &lt;&lt; \" \" &lt;&lt; src.y; return out;&#125; 关于更多的特殊运算符重载可以查询资料 友元在上面的运算符重载声明中出现了friend关键字，friend可以将外部的一些函数或者类声明为友元，声明为友元的函数或者类可以访问该类的一切成员，不受private关键字的影响。 友元不传递，即朋友的朋友不是你的朋友。 友元不继承，即朋友的孩子不是你的朋友。 友元声明不能定义新的class。 内联函数使用内联函数，编译器在编译时会自动生成与函数等价的表达式语句，从而减少函数调用的开销。例如； 123456789101112inline int max(int a, int b)&#123; return a &gt; b ? a : b;&#125;int main()&#123; int a, b; // ... // cout &lt;&lt; max(a, b) &lt;&lt; endl; 实际会被优化为如下语句 cout &lt;&lt; a &gt; b ? a : b &lt;&lt; endl;&#125;","categories":[],"tags":[{"name":"OOP","slug":"OOP","permalink":"http://believebest35.github.io/tags/OOP/"}]},{"title":"面向对象_编程环境基础","slug":"OOP-THU-1","date":"2020-10-05T08:34:31.000Z","updated":"2020-10-13T12:26:23.740Z","comments":true,"path":"2020/10/05/OOP-THU-1/","link":"","permalink":"http://believebest35.github.io/2020/10/05/OOP-THU-1/","excerpt":"以下关于面向对象课程资料的内容来源于清华大学刘知远老师开设的面向对象程序设计基础课程， 课程资料 编译和链接C++源程序变为目标平台上的可执行程序需要经过编译器以及链接器。 编译器：首先将源代码解析为语法分析树，再根据语法分析树生成对应的中间代码或直接生成对应平台的汇编码、机器码，即生成目标文件。 链接器：将目标模块链接为可执行程序。","text":"以下关于面向对象课程资料的内容来源于清华大学刘知远老师开设的面向对象程序设计基础课程， 课程资料 编译和链接C++源程序变为目标平台上的可执行程序需要经过编译器以及链接器。 编译器：首先将源代码解析为语法分析树，再根据语法分析树生成对应的中间代码或直接生成对应平台的汇编码、机器码，即生成目标文件。 链接器：将目标模块链接为可执行程序。 g++ -c 只编译不链接 g++ -o 链接目标程序 12345678910111213141516171819202122--- Desktop/oop_test » lsmain.cpp--- Desktop/oop_test » cat main.cpp#include&lt;iostream&gt;using namespace std;int main()&#123; cout &lt;&lt; \"hello world\" &lt;&lt; endl; return 0;&#125;--- Desktop/oop_test » lsmain.cpp--- Desktop/oop_test » g++ -c main.cpp--- Desktop/oop_test » lsmain.cpp main.o--- Desktop/oop_test » g++ -o main.out main.o--- Desktop/oop_test » lsmain.cpp main.o main.out--- Desktop/oop_test » ./main.outhello world--- Desktop/oop_test » 宏定义 简单的宏定义：#define &lt;宏名&gt; &lt;字符串&gt; 如 1#define PI 3.14 // 不建议使用宏定义，建议使用const定义常量 带参数的宏定义：#define &lt;宏名&gt; (&lt;参数表&gt;) &lt;字符串&gt; 如 1#define sqr(x) ((x) * (x)) 防止头文件的重复包含 1234#ifndef __BODYDEF_H__#define __BODYDEF_H__// 头文件#endif 防止头文件的重复包含也可以采用如下方式： 1#pragma once 以上保证所有文件不会被编译两次 用于Debug输出 12345#ifdef 标识符 // 程序段1#else // 程序段2#endif MAKE工具MAKE工具是使得大型工程编译工程自动化的一种工具，相当于一个脚本集合。 关于Make命令的具体教程可以参见Make命令教程 格式： 12&lt;target&gt;: prerequisites&lt;tab&gt; command 其中target表示目标文件，target不能为空。prerequisites表示target所依赖的文件，可以为空。 prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。 一个简单的栗子，假设makefile文件编写如下 12345678910source: a.txt b.txt c.txtb.txt: echo \"this is a test\" &gt; b.txtc.txt: echo \"this is a test2\" &gt; c.txta.txt: b.txt c.txt cat b.txt c.txt &gt; a.txt 终端中输入make便会执行第一条命令，即make source 123456789--- Desktop/oop_test » lsmain.cpp main.o main.out makefile--- Desktop/oop_test » make sourceecho \"this is a test\" &gt; b.txtecho \"this is a test2\" &gt; c.txtcat b.txt c.txt &gt; a.txt--- Desktop/oop_test » lsa.txt b.txt c.txt main.cpp main.o main.out makefile--- Desktop/oop_test » 也可以显式指定要执行的命令，例如make b.txt 1234567--- Desktop/oop_test » lsmain.cpp main.o main.out makefile--- Desktop/oop_test » make b.txtecho \"this is a test\" &gt; b.txt--- Desktop/oop_test » lsb.txt main.cpp main.o main.out makefile--- Desktop/oop_test » 常常利用make来管理大型工程的编译过程，更多关于make的高级过程可查询教程。 C++程序命令行参数main函数可接受来自命令行的参数，例如 12345int main(int argc, char** argv)&#123; // .. return 0;&#125; 其中argc中存储的是命令行参数的个数，argv则以C风格字符串的形式保存参数，其中包含了可执行程序文件的名称本身，举一个栗子：main函数如下： 123456789#include&lt;iostream&gt;using namespace std;int main(int a, char ** b)&#123; cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; b[0] &lt;&lt; endl; cout &lt;&lt; \"hello world\" &lt;&lt; endl;&#125; 终端执行结果如下 12345678910--- Desktop/oop_test » lsmain.cpp main.o main.out--- Desktop/oop_test » g++ main.cppls% --- Desktop/oop_test » lsa.out main.cpp main.o main.out--- Desktop/oop_test » ./a.out 1 1 1 1 16./a.outhello world--- Desktop/oop_test »","categories":[],"tags":[{"name":"OOP","slug":"OOP","permalink":"http://believebest35.github.io/tags/OOP/"}]},{"title":"数据结构基础","slug":"data-structure-post-1","date":"2020-09-15T07:16:12.000Z","updated":"2020-10-13T12:28:17.751Z","comments":true,"path":"2020/09/15/data-structure-post-1/","link":"","permalink":"http://believebest35.github.io/2020/09/15/data-structure-post-1/","excerpt":"数据结构基础绪论数据结构数据结构描绘数据元素以及数据元素之间的关系。 算法的特性 有穷性 确定性 可行性 有输入（不一定） 有输出","text":"数据结构基础绪论数据结构数据结构描绘数据元素以及数据元素之间的关系。 算法的特性 有穷性 确定性 可行性 有输入（不一定） 有输出 线性表线性表是具有相同特性的数据元素的的一个有限序列，一般实现方式有两种： 顺序实现，c++中的数组类型就是对于线性表的顺序实现。 链表实现，即各个元素之间的不是连续的，需要额外存储下一个元素的所在位置。 单链表 双链表 循环链表 … 有序表有序表指的是元素以递增或者递减的方式排列的线性表，需要注意两个有序表的归并排序，即分别使用两个指针扫描两个子线性表，选择其中较小（假设递增排序）的元素归并到新的有序表中。 vectorc++的标准模版库中封装了vector类型，可十分方便的操作线性排列的元素。 123456789101112131415#include &lt;vector&gt;vector&lt;int&gt; v(10); // 初始化具有10个空间的线性表vector&lt;int&gt; v_2(10, 1) //初始化具有10个空间的线性表，每个元素的初始值为1int a = v[1]; //下标访问v.push_back(1);v.pop_back();v.clear(); // 清除所有元素v.erase(v.begin() + 1); // 删除一个元素v.erase(v.begin() + 1, v.begin() + 5) // 删除一段元素v.back();v.front();v.empty();v.size();// ... 栈只能在一端进行插入和删除的线性表，后进先出（FILO） 主要操作： 123456789#include &lt;stack&gt;stack&lt;int&gt; st;st.push(10);st.top();st.pop();st.empty();st.size(); 栈的一些应用 中缀表达式转后缀表达式 后缀表达式求值 … 队列只能在一端进行插入，另外一段进行删除的线性表，先进先出（LILO） 主要操作 12345678910#include &lt;queue&gt;queue&lt;int&gt; que;que.push(1);que.front();que.back();que.pop();que.size();que.empty(); 队列相关的应用 约瑟夫环问题 … 双端队列两端都可以进行插入和删除的线性表 123456789101112131415#include &lt;deque&gt;deque&lt;int&gt; deq; // vector加强版deq.empty();deq.push_front(1);deq.pop_front();deq.push_back(1);deq.pop_back(;deq.back();deq.front();deq.size();deq.clear();deq.insert(); // 同vector的插入deq.erase(deq.begin() + 4); 串的模式匹配 KMP串的模式匹配指的是给定两个字符串T和P，在主串T中找出第一次出现完整子串P的位置，一般的暴力解法如下： 1234567891011121314151617181920212223int brute_force_match(string T, string P)&#123; if (T == \"\" || P == \"\") return -1; int i = 0, j = 0; while (i &lt; T.size() &amp;&amp; j &lt; P.size()) &#123; if (T[i] == P[j]) &#123; i++; j++; &#125; else &#123; i = i - j + 1; j = 0; &#125; &#125; if (j == P.size()) return i - j; else return -1;&#125; 假设T串长m，P串长n，则暴力算法时间复杂度为O(m * n)。 KMP算法则可以将以上的匹配过程加速至O(m + n), KMP算法的核心在于保持匹配过程中i指针的位置不变，修改j指针，使得模式串尽量移动到有效的位置。 具体的讲解可见KMP算法讲解 举一个栗子，以主串ABCABCDHIJK和模式串ABCABB的匹配为例： A B C A B C D H I J K i A B C A B B j 当i指向T中第5个（以0开始标记）元素，j指向P中第5个元素，发生冲突，注意到已经匹配的部分ABCAB的前缀AB和后缀AB是一致的，因此可以跳过再次匹配这一部分的过程，维持i不变，将j移动到P中的第二个位置继续进行匹配。 以上的过程需要求已经匹配部分的前缀和后缀的最长公共部分的长度，并保存在next数组中，next[j]即表示发生冲突时j指针应该移动到的位置。 next数组的具体求法如下： 123456789101112131415161718vector&lt;int&gt; get_next(string P)&#123; vector&lt;int&gt; next(P.size()); next[0] = -1; // 规定next数组的第0位为-1 int j = 0, k = -1; while (j &lt; P.size() - 1) &#123; if (k == -1 || P[k] == P[j]) &#123; j++; k++; next[j] = k; &#125; else k = next[k]; &#125; return next;&#125; 求出next数组之后即可应用KMP算法 1234567891011121314151617181920212223int KMP_match(string T, string P)&#123; if (T == \"\" || P == \"\") return -1; vector&lt;int&gt; next = get_next(P); int i = 0, j = 0; while (i &lt; T.size() &amp;&amp; j &lt; P.size()) &#123; if (j == -1 || T[i] == P[j]) &#123; i++; j++; &#125; else &#123; j = next[j]; &#125; &#125; if (j == P.size()) return i - j; else return -1;&#125; 二叉树二叉树是一种树状的数据结构，二叉树的递归遍历相对比较简单 递归遍历的统一模版如下：12345678910void treeTravel(ListNode *node)&#123; if (node == nullptr) return; cout &lt;&lt; node -&gt; val; // 前序遍历 treeTravel(node -&gt; left); // cout &lt;&lt; node -&gt; val; // 中序遍历 treeTravel(node -&gt; right); // cout &lt;&lt; node -&gt; val; // 后序遍历&#125; 对于二叉树的非递归遍历，前中后序遍历实现形式不同，但也可以统一为一个形式,采用记号进行标记 先给出前序以及中序遍历的非统一非递归实现 前序遍历的非递归实现：1234567891011121314151617void pre_travel(ListNode *node)&#123; if (node == nullptr) return; stack&lt;ListNode*&gt; st; st.push(node); while (!st.empty()) &#123; ListNode *temp = st.top(); cout &lt;&lt; temp -&gt; val; st.pop(); if (temp -&gt; right != nullptr) st.push(temp -&gt; right); if (temp -&gt; left != nullptr) st.push(temp -&gt; left); &#125;&#125; 中序遍历的非递归实现：1234567891011121314151617void in_travel(ListNode *node)&#123; ListNode *cur = node; stack&lt;ListNode*&gt; st; while (cur != nullptr || !st.empty()) &#123; while (cur != nullptr) &#123; st.push(cur); cur = cur -&gt; left; &#125; cur = st.top(); st.pop(); cout &lt;&lt; cur -&gt; val; cur = cur -&gt; right; &#125;&#125; 后序遍历的非递归实现相较于前序以及中序的较为麻烦，不过可以将前两者的代码统一为一个形式 后续遍历的非递归实现：1234567891011121314151617181920212223void post_travel(ListNode *node)&#123; if (node == nullptr) return; stack&lt;pair&lt;ListNode*, int&gt;&gt; st; st.push(make_pair(node, 0)); while (!st.empty()) &#123; ListNode *temp = st.top().first; int flag = st.top().second; st.pop(); if (flag == 0) &#123; st.push(make_pair(temp, 1)); if (temp -&gt; right != nullptr) st.push(make_pair(temp -&gt; right, 0)); if (temp -&gt; left != nullptr) st.push(make_pair(temp -&gt; left, 0)); &#125; else cout &lt;&lt; temp -&gt; val; &#125;&#125; 调整以上的入栈顺序即可实现前序以及中序遍历。 二叉树的层次遍历比较简单，结合队列进行广搜即可。 并查集并查集是一种用于解决元素分组的数据结构，主要用于解决元素分组以及合并的问题，支持的操作包括find以及union。 find 查询两个元素是否在同一个集合中 union 将两个不相交的集合进行合并 初始化1234567int fa[MAX];inline void init(int n)&#123; for (int i = 1; i &lt;= n; i++) fa[i] = i;&#125; 即最开始每个元素分别所属不同的集合。 查询1234567int find(int x)&#123; if(fa[x] == x) return x; else return find(fa[x]);&#125; 合并1234inline void merge(int i, int j)&#123; fa[find(i)] = find(j);&#125; 其中合并可以进行优化，即进行路径压缩 123456789101112131415int find(int x)&#123; if(x == fa[x]) return x; else&#123; fa[x] = find(fa[x]); //父节点设为根节点 return fa[x]; //返回父节点 &#125;&#125;// 简化为一行的写法int find(int x)&#123; return x == fa[x] ? x : (fa[x] = find(fa[x]));&#125; 并查集的按秩合并优化初始化（按秩合并） 12345678inline void init(int n)&#123; for (int i = 1; i &lt;= n; ++i) &#123; fa[i] = i; rank[i] = 1; &#125;&#125; 合并（按秩合并） 12345678910inline void merge(int i, int j)&#123; int x = find(i), y = find(j); //先找到两个根节点 if (rank[x] &lt;= rank[y]) fa[x] = y; else fa[y] = x; if (rank[x] == rank[y] &amp;&amp; x != y) rank[y]++; //如果深度相同且根节点不同，则新的根节点的深度+1&#125; 图图的存储方式 邻接矩阵 邻接表 十字链表 邻接多重表 链式前向星 … 图的遍历 BFS DFS 最小生成树 普里姆算法 克鲁斯卡尔算法 最短路算法 Dijkstra(单源最短路) Floyd 拓扑排序依次寻找入度为0的节点即可 查找顺序查找时间复杂度为O(N),对线性表无特殊限制。 二分查找时间复杂度为O(logN),需要线性表有序。 123456789101112131415int binary_search(vector&lt;int&gt; nums, int target)&#123; int l = 0, r = nums.size() - 1; while (l &lt;= r) &#123; int mid = (l + r) / 2; if (nums[mid] == target) return mid; else if (nums[mid] &lt; target) l = mid + 1; else r = mid - 1; &#125; return -1;&#125; B树 B+树B树和B+树都是一般用于外查找的数据结构。 B树一棵m阶B树(balanced tree of order m)是一棵平衡的m路搜索树。它或者是空树，或者是满足下列性质的树： 根结点至少有两个子女； 每个非根节点所包含的关键字个数 j 满足：┌m/2┐ - 1 &lt;= j &lt;= m - 1； 除根结点以外的所有结点（不包括叶子结点）的度数正好是关键字总数加1，故内部子树个数 k 满足：┌m/2┐ &lt;= k &lt;= m ； 所有的叶子结点都位于同一层。在B-树中，每个结点中关键字从小到大排列，并且当该结点的孩子是非叶子结点时，该k-1个关键字正好是k个孩子包含的关键字的值域的分划。 以上内容摘自百度百科。 B+树to do 排序插入排序1234567891011void insert_sort(vector&lt;int&gt; &amp;nums)&#123; for (int i = 1; i &lt; nums.size(); i++) &#123; int temp = nums[i]; int j; for (j = i - 1; j &gt;= 0 &amp;&amp; nums[j] &gt; temp; j--) nums[j + 1] = nums[j]; nums[j + 1] = temp; &#125;&#125; 时间复杂度为O(n^2) 希尔排序希尔排序需要选择增量对数据进行分组，分完组的各部分分别使用插排，最后直到增量为1 冒泡排序1234567891011121314151617void bubble_sort(vector&lt;int&gt; &amp;nums)&#123; for (int i = 0; i &lt; nums.size() - 1; i++) &#123; bool exchange = false; for (int j = nums.size() - 1; j &gt; i; j--) &#123; if (nums[j] &lt; nums[j - 1]) &#123; swap(nums[j], nums[j - 1]); exchange = true; &#125; &#125; if (!exchange) return; &#125;&#125; 时间复杂度为O(n^2) 选择排序1234567891011void select_sort(vector&lt;int&gt; &amp;nums)&#123; for (int i = 0; i &lt; nums.size(); i++) &#123; int min_pos = i; for (int j = i + 1; j &lt; nums.size(); j++) if (nums[j] &lt; nums[min_pos]) min_pos = j; swap(nums[i], nums[min_pos]); &#125;&#125; 时间复杂度为O(n^2) 快速排序1234567891011121314151617181920212223242526int partition(vector&lt;int&gt; &amp;nums, int l, int r)&#123; int temp = nums[l]; while (l &lt; r) &#123; while (l &lt; r &amp;&amp; nums[r] &gt;= temp) r--; nums[l] = nums[r]; while (l &lt; r &amp;&amp; nums[l] &lt;= temp) l++; nums[r] = nums[l]; &#125; nums[l] = temp; return l;&#125;void quick_sort(vector&lt;int&gt; &amp;nums, int l, int r)&#123; if (l &lt; r) &#123; int i = partition(nums, l, r); quick_sort(nums, l, i - 1); quick_sort(nums, i + 1, r); &#125;&#125; 以上的快速排序没有做随机化处理，更加正统的写法应该随机化选择枢纽元素。平均时间复杂度为O(NlogN) 堆排序利用堆的性质进行排序，stl中提供了优先队列，可直接用于排序。关于具体的堆的实现可以百度。。。 归并排序123456789101112131415161718192021222324252627282930313233343536373839404142434445void merge(int *data,int start,int end,int *result) &#123; int left_length = (end - start + 1) / 2 + 1; int left_index = start; int right_index = start + left_length; int result_index = start; while(left_index&lt;start + left_length &amp;&amp; right_index &lt;end + 1) //store data into new array &#123; if(data[left_index] &lt;= data[right_index]) result[result_index++] = data[left_index++]; else result[result_index++] = data[right_index++]; &#125; while(left_index &lt; start + left_length) result[result_index++] = data[left_index++]; while(right_index &lt;end+1) result[result_index++] = data[right_index++];&#125; void merge_sort(int *data,int start,int end,int *result)&#123; if(1 == end - start) //last only two elements &#123; if(data[start] &gt; data[end]) &#123; int temp = data[start]; data[start] = data[end]; data[end] = temp; &#125; return; &#125; else if (end == start) return; //last one element then there is no need to sort; else&#123; //continue to divide the interval merge_sort(data, start, (end - start + 1) / 2 + start, result); merge_sort(data, (end - start + 1) / 2 + start + 1, end, result); //start to merge sorted data merge(data, start, end, result); for (int i = start; i &lt;= end;++i) &#123; data[i] = result[i]; &#125; &#125;&#125;","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://believebest35.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"leetcode 60 第k个排列","slug":"leetcode-solution-7","date":"2020-09-05T07:14:39.000Z","updated":"2020-10-13T12:26:34.437Z","comments":true,"path":"2020/09/05/leetcode-solution-7/","link":"","permalink":"http://believebest35.github.io/2020/09/05/leetcode-solution-7/","excerpt":"Leetcode 60 第k个排列leetcode 60 题目描述给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下： “123” “132” “213” “231” “312” “321”","text":"Leetcode 60 第k个排列leetcode 60 题目描述给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下： “123” “132” “213” “231” “312” “321” 给定 n 和 k，返回第 k 个排列。 说明： 给定 n 的范围是 [1, 9]。 给定 k 的范围是[1, n!]。 示例输入: n = 3, k = 3输出: “213” 输入: n = 4, k = 9输出: “2314” 解法依次固定每一位的取值即可,注意是从0开始计数的因此k需要减1，当k到0的时候就可以直接将剩下的数字直接接在最后。 123456789101112131415161718192021class Solution&#123;public: string getPermutation(int n, int k) &#123; vector&lt;int&gt; fac = &#123;0, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880&#125;; string s = string(\"123456789\").substr(0, n); k--; string ans = \"\"; while (k &gt; 0) &#123; int id = k / fac[n - 1]; ans += s[id]; s.erase(s.begin() + id); k %= fac[n - 1]; n--; &#125; ans += s; return ans; &#125;&#125;;","categories":[],"tags":[{"name":"leetcode_solution","slug":"leetcode-solution","permalink":"http://believebest35.github.io/tags/leetcode-solution/"}]},{"title":"leetcode 329 矩阵中的最长递增路径","slug":"leetcode-solution-6","date":"2020-07-26T16:02:08.000Z","updated":"2020-10-13T12:26:55.116Z","comments":true,"path":"2020/07/27/leetcode-solution-6/","link":"","permalink":"http://believebest35.github.io/2020/07/27/leetcode-solution-6/","excerpt":"Leetcode 329 矩阵中的最长递增路径leetcode 329 题目描述给定一个整数矩阵，找出最长递增路径的长度。 对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外（即不允许环绕）","text":"Leetcode 329 矩阵中的最长递增路径leetcode 329 题目描述给定一个整数矩阵，找出最长递增路径的长度。 对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外（即不允许环绕） 示例输入: nums = [9,9,4] [6,6,8] [2,1,1]输出: 4解释: 最长递增路径为 [1, 2, 6, 9]。 输入: nums = [3,4,5] [3,2,6] [2,2,1]输出: 4解释: 最长递增路径是 [3, 4, 5, 6]。注意不允许在对角线方向上移动。 方法：DFS这道题明显可以用dfs来写，不过最朴素的dfs（不带剪枝）会超时，因此需要简单的剪枝。或者可以写成记忆化递归的形式。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution&#123;public: int m, n; int ans; void dfs(vector&lt;vector&lt;int&gt;&gt; &amp;matrix, vector&lt;vector&lt;int&gt;&gt; &amp;dp, int x, int y) &#123; if (x &gt;= 1 &amp;&amp; matrix[x - 1][y] &gt; matrix[x][y] &amp;&amp; dp[x - 1][y] &lt; dp[x][y] + 1) &#123; dp[x - 1][y] = dp[x][y] + 1; ans = max(ans, dp[x - 1][y]); dfs(matrix, dp, x - 1, y); &#125; if (x &lt; m - 1 &amp;&amp; matrix[x + 1][y] &gt; matrix[x][y] &amp;&amp; dp[x + 1][y] &lt; dp[x][y] + 1) &#123; dp[x + 1][y] = dp[x][y] + 1; ans = max(ans, dp[x + 1][y]); dfs(matrix, dp, x + 1, y); &#125; if (y &gt;= 1 &amp;&amp; matrix[x][y - 1] &gt; matrix[x][y] &amp;&amp; dp[x][y - 1] &lt; dp[x][y] + 1) &#123; dp[x][y - 1] = dp[x][y] + 1; ans = max(ans, dp[x][y - 1]); dfs(matrix, dp, x, y - 1); &#125; if (y &lt; n - 1 &amp;&amp; matrix[x][y + 1] &gt; matrix[x][y] &amp;&amp; dp[x][y + 1] &lt; dp[x][y] + 1) &#123; dp[x][y + 1] = dp[x][y] + 1; ans = max(ans, dp[x][y + 1]); dfs(matrix, dp, x, y + 1); &#125; &#125; int longestIncreasingPath(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; m = matrix.size(); if (m == 0) return 0; ans = 1; n = matrix[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 1)); for (int i = 0; i &lt; m; i++) for (int j = 0; j &lt; n; j++) dfs(matrix, dp, i, j); return ans; &#125;&#125;;","categories":[],"tags":[{"name":"leetcode_solution","slug":"leetcode-solution","permalink":"http://believebest35.github.io/tags/leetcode-solution/"}]},{"title":"leetcode 322 零钱兑换 and leetcode 410 分割数组的最大值","slug":"leetcode-solution-5","date":"2020-07-25T08:03:33.000Z","updated":"2020-10-13T12:27:06.506Z","comments":true,"path":"2020/07/25/leetcode-solution-5/","link":"","permalink":"http://believebest35.github.io/2020/07/25/leetcode-solution-5/","excerpt":"Leetcode 322 零钱兑换leetcode 322 题目描述给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。 示例输入: coins = [1, 2, 5], amount = 11输出: 3解释: 11 = 5 + 5 + 1 输入: coins = [2], amount = 3输出: -1","text":"Leetcode 322 零钱兑换leetcode 322 题目描述给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。 示例输入: coins = [1, 2, 5], amount = 11输出: 3解释: 11 = 5 + 5 + 1 输入: coins = [2], amount = 3输出: -1 说明你可以认为每种硬币的数量是无限的。 方法一：DFS这是一道典型的可以用dfs来做的题，但。。。他T了 12345678910111213141516171819202122232425262728293031class Solution&#123;public: int ans; void dfs(vector&lt;int&gt; &amp;coins, int amount, int count) &#123; if (amount == 0) &#123; if (ans == -1) ans = count; else ans = min(ans, count); return; &#125; if (amount &lt; 0) return; for (int i = coins.size() - 1; i &gt;= 0; i--) dfs(coins, amount - coins[i], count + 1); &#125; int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123; // sort(coins.begin(), coins.end()); ans = -1; dfs(coins, amount, 0); return ans; &#125;&#125;; 方法二：DPDP状态很好设置，dp[i]即表示组成金额为i的所需最小金币个数，其中初始化如下： dp[0] = 0 若i = 某硬币面值，则dp[i] = 1; 其余均初始化为-1 状态转移过程直接写在代码里了 12345678910111213141516171819202122232425262728class Solution&#123;public: int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123; sort(coins.begin(), coins.end()); if (amount &lt; 0) return -1; vector&lt;int&gt; dp(amount + 1, -1); dp[0] = 0; for (int i = 0; i &lt; coins.size(); i++) if (coins[i] &lt;= amount) dp[coins[i]] = 1; for (int i = 1; i &lt;= amount; i++) &#123; if (dp[i] == 1) continue; for (int j = 0; j &lt; coins.size(); j++) &#123; if (i - coins[j] &gt;= 0 &amp;&amp; dp[i - coins[j]] != -1) dp[i] = (dp[i] == -1) ? (dp[i - coins[j]] + 1) : min(dp[i], dp[i - coins[j]] + 1); &#125; &#125; return dp[amount]; &#125;&#125;; Leetcode 410 分割数组的最大值leetcode 419 题目描述给定一个非负整数数组和一个整数 m，你需要将这个数组分成 m 个非空的连续子数组。设计一个算法使得这 m 个子数组各自和的最大值最小。 注意:数组长度 n 满足以下条件: 1 ≤ n ≤ 1000 1 ≤ m ≤ min(50, n) 示例输入:nums = [7,2,5,10,8]m = 2 输出:18 解释:一共有四种方法将nums分割为2个子数组。其中最好的方式是将其分为[7,2,5] 和 [10,8]，因为此时这两个子数组各自的和的最大值为18，在所有情况中最小。 方法动态规划，dp[i][j]表示前i个数被分为j段后的所有方案中各个子数组和最大值的最小值。。求前缀和比较亮眼。。。 12345678910111213141516171819202122class Solution&#123;public: int splitArray(vector&lt;int&gt;&amp; nums, int m) &#123; int n = nums.size(); vector&lt;long long&gt; pre_sum(n + 1, 0); pre_sum[1] = nums[0]; for (int i = 0; i &lt; n; i++) pre_sum[i + 1] = pre_sum[i] + nums[i]; vector&lt;vector&lt;long long&gt;&gt; dp(n + 1, vector&lt;long long&gt;(m + 1, LLONG_MAX)); //dp[i][j]表示前i个数被分为j段后各个子数组和最大值的最小值。。 dp[0][0] = 0; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= min(m, i); j++) for (int k = 0; k &lt; i; k++) dp[i][j] = min(dp[i][j], max(dp[k][j - 1], pre_sum[i] - pre_sum[k])); return dp[n][m]; &#125;&#125;;","categories":[],"tags":[{"name":"leetcode_solution","slug":"leetcode-solution","permalink":"http://believebest35.github.io/tags/leetcode-solution/"}]},{"title":"leetcode 1025 除数博弈","slug":"leetcode-solution-4","date":"2020-07-24T07:54:08.000Z","updated":"2020-10-13T12:27:17.429Z","comments":true,"path":"2020/07/24/leetcode-solution-4/","link":"","permalink":"http://believebest35.github.io/2020/07/24/leetcode-solution-4/","excerpt":"Leetcode 1025 除数博弈leetcode 1025 题目描述爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。 最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作： 选出任一 x，满足 0 &lt; x &lt; N 且 N % x == 0 。 用 N - x 替换黑板上的数字 N 。如果玩家无法执行这些操作，就会输掉游戏。 只有在爱丽丝在游戏中取得胜利时才返回 True，否则返回 false。假设两个玩家都以最佳状态参与游戏。","text":"Leetcode 1025 除数博弈leetcode 1025 题目描述爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。 最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作： 选出任一 x，满足 0 &lt; x &lt; N 且 N % x == 0 。 用 N - x 替换黑板上的数字 N 。如果玩家无法执行这些操作，就会输掉游戏。 只有在爱丽丝在游戏中取得胜利时才返回 True，否则返回 false。假设两个玩家都以最佳状态参与游戏。 示例输入：2输出：true解释：爱丽丝选择 1，鲍勃无法进行操作。 输入：3输出：false解释：爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。 方法一：动态规划如果不想动脑就无脑动态规划。。。设dp[i]表示数字为i时先手是否必赢。数字为i时的必胜是从先前某一必败态所转移来的，因此转移方程可以写为：dp[i] = true if dp[i - j] = false exists (j为i因子)or dp[i] = false 1234567891011121314151617class Solution&#123;public: bool divisorGame(int N) &#123; vector&lt;bool&gt; dp(N + 1, false); dp[1] = false, dp[2] = true; for (int i = 3; i &lt;= N; i++) for (int j = 1; j &lt; i; j++) if (i % j == 0 &amp;&amp; !dp[i - j]) &#123; dp[i] = true; break; &#125; return dp[N]; &#125;&#125;; 方法二：数学规律额，直接才想N能不能被2整除，能整除就返回true，否则false。证明可用数学归纳法。 12345678class Solution&#123;public: bool divisorGame(int N) &#123; return N % 2 == 0； &#125;&#125;;","categories":[],"tags":[{"name":"leetcode_solution","slug":"leetcode-solution","permalink":"http://believebest35.github.io/tags/leetcode-solution/"}]},{"title":"leetcode 287 寻找重复数","slug":"leetcode-solution-3","date":"2020-07-23T07:10:49.000Z","updated":"2020-10-13T12:27:26.410Z","comments":true,"path":"2020/07/23/leetcode-solution-3/","link":"","permalink":"http://believebest35.github.io/2020/07/23/leetcode-solution-3/","excerpt":"Leetcode 287 寻找重复数leetcode 287 题目描述给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。 示例输入: [1,3,4,2,2]输出: 2 输入: [3,1,3,4,2]输出: 3","text":"Leetcode 287 寻找重复数leetcode 287 题目描述给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。 示例输入: [1,3,4,2,2]输出: 2 输入: [3,1,3,4,2]输出: 3 说明 不能更改原数组（假设数组是只读的）。 只能使用额外的 O(1) 的空间。 时间复杂度小于 O(n^2) 。 数组中只有一个重复的数字，但它可能不止重复出现一次。 解法这道题如果没有说明里的条件的话是非常容易的，可以排序，或者哈希，但是排序修改了原数组，哈希需要O(n)的空间。另外如果没有第一个条件的话可以考虑使用原地哈希。 以上的方法不能使用，因此实际做的时候用的是二分，不过不是对下标进行二分，而是对值域进行二分。最开始范围取到1～n，mid = (1 + n) / 2，每次分别统计小于mid，等于mid以及大于mid的个数，据此缩小空间。 123456789101112131415161718192021222324252627282930class Solution&#123;public: int findDuplicate(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size() - 1; int i = 1, j = n; while (i &lt; j) &#123; int less_k = 0; int large_k = 0; int count_k = 0; int mid = i + (j - i) / 2; for (auto num : nums) if (num == mid) count_k++; else if (num &lt; mid) less_k++; else large_k++; if (count_k &gt;= 2) return mid; if (less_k &gt; mid - 1) j = mid - 1; else i = mid + 1; &#125; return i; // 题目数据保证，不会在这退出。。。 &#125;&#125;;","categories":[],"tags":[{"name":"leetcode_solution","slug":"leetcode-solution","permalink":"http://believebest35.github.io/tags/leetcode-solution/"}]},{"title":"STL常用容器","slug":"stl常用容器","date":"2020-07-23T03:21:30.000Z","updated":"2020-10-13T12:28:30.685Z","comments":true,"path":"2020/07/23/stl常用容器/","link":"","permalink":"http://believebest35.github.io/2020/07/23/stl%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8/","excerpt":"这里记录了一些用c++刷leetcode时可能会用到的stl容器用法 原出处，作者wangdh vector边长数组，倍增思想 系统为某一个程序分配空间时，所需时间和空间大小无关，与申请次数有关。 所以变长数组尽可能减少申请次数。一开始申请一定空间的大小，当超过容量时，申请长度变为二倍的空间，然后将原始空间的元素copy过来。 当初始化的时候不指定空间大小，但是使用的空间有非常大之后需要多次扩容，那么扩容需要的时间复杂度是O(N) 相当于插入一个元素就需要将O(1)的时间。申请空间的次数是O(log n)。","text":"这里记录了一些用c++刷leetcode时可能会用到的stl容器用法 原出处，作者wangdh vector边长数组，倍增思想 系统为某一个程序分配空间时，所需时间和空间大小无关，与申请次数有关。 所以变长数组尽可能减少申请次数。一开始申请一定空间的大小，当超过容量时，申请长度变为二倍的空间，然后将原始空间的元素copy过来。 当初始化的时候不指定空间大小，但是使用的空间有非常大之后需要多次扩容，那么扩容需要的时间复杂度是O(N) 相当于插入一个元素就需要将O(1)的时间。申请空间的次数是O(log n)。 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;int main()&#123; vector&lt;int&gt; a; // 定义一个vecotr vector&lt;int&gt; a(10); // 初始长度为10； vector&lt;int&gt; a(10, 3); // 初始长度为10， 且每个元素初始化为3 for(auto i : a) cout &lt;&lt; i &lt;&lt; \" \"; // 遍历元素的方式 ， auto 关键字，系统自动推断变量类型，变量名比较长的时候可以使用 vector&lt;int&gt; a[10]; // 定义了vector数组，每个元素都是一个vector&lt;int&gt; a.size(); // 返回列表里的元素的个数 a.empty(); // 返回列表是不是空 // size() 和empty() 是所有容器都有的，时间复杂度是o(1) a.clear(); // 清空，不是所有的容器都有 a.front(); // 返回第一个元素 a.back(); // 返回最后一个元素 a.push_back(); // 从最后插入一个元素 a.pop_back(); // 删除最后一个元素 a.begin(); a.end(); // 迭代器。 可以看做指针，可以解引用 a[2]; // 支持随机寻址，与数组相同 // 三种遍历方式 for(int i = 0; i &lt; a.size(); i ++) cout &lt;&lt; a[i] &lt;&lt; \" \"; cout &lt;&lt; endl; for(vector&lt;int&gt;::iterator i = a.begin(); i != a.end(); i ++) cout &lt;&lt; *i &lt;&lt; \" \"; for(auto i = a.begin(); i != a.end(); i ++) cout &lt;&lt; *i &lt;&lt; \" \"; // 迭代器，解引用 cout &lt;&lt; endl; for(auto x : a) cout &lt;&lt; x &lt;&lt; \" \"; // auto关键字自动推断类型 cout &lt;&lt; endl; // vector支持比较，按位进行字典序比较 vector&lt;int&gt; a(4, 3), b(3, 4); cout &lt;&lt; (a &lt; b); return 0;&#125; pair元组类型，相当于Python中的(). 当一个元素有多个属性的时候，可以使用pair来进行存储。当需要按照某个属性来排序的时候，就非常好。 比如合并区间的问题。每个区间有开始和结尾两个属性，然后需要按照区间的开始对区间进行排序。 可以看做实现了一个结构体，且实现了比较器。 12345678910111213141516171819202122232425262728293031// 两种初始化方法pair&lt;int, string&gt; p;p = make_pair(10, \"aa\");p = &#123;q, \"ab\"&#125;;// 支出比较运算，first为第一关键字，second为第二关键字pair&lt;int, string&gt; p = &#123;1, \"aa\"&#125;;pair&lt;int, string&gt; q = &#123;1, \"ab\"&#125;;// first取出第一个字， second取出第二个字cout &lt;&lt; p.first &lt;&lt; endl;cout &lt;&lt; p.second &lt;&lt; endl;cout &lt;&lt; (p &lt; q) &lt;&lt; endl;// 也可以使用pair存储三个属性等; pair 嵌套pairpair&lt;int, pair&lt;int, int&gt;&gt; p;string字符串，substr(), c_str()string s = \"a\"; s += \"ab\"; // 支持增量操作s += 'a';cout &lt;&lt; s &lt;&lt; endl;cout &lt;&lt; s.substr(1, 2) &lt;&lt; endl; // 可以取出某个子串，第一个是起始index，第二个是长度。第二个缺省或者超过范围则返回之后的左右字符串cout &lt;&lt; s.substr(1) &lt;&lt; endl;cout &lt;&lt; s.substr(1, 100) &lt;&lt; endl;printf(\"%s\\n\", s.c_str()); // 使用printf输出的时候，需要找到存储字符串数组的起始地址。c_str()可以返回size() | length() // 返回字符串的长度 s.find('a'); // 返回a在s中的位置,如果没找到，返回一个特别的标志c++中用npos表示(可以用s.npos)来表示 queue队列，push(), front() , pop(),back() 1234567// push() 向队尾插入一个元素// front() 返回队头元素// pop() 返回队尾元素// back() 弹出队头元素// size() // empty()// 没有clear操作 priority_queue优先队列，push(), top(), pop() 123456789101112131415161718192021222324// 内部使用堆维护// 默认是大顶堆，和python相反// 使用小顶对方法// 1. 在插入的时候插入元素的相反数即可// 2. 如下定义#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;iostream&gt;#include&lt;csting&gt;#include&lt;queue&gt;using namespace std;priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; heap;// priority_queue&lt;int&gt; q; // 大顶堆priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q; // 小顶堆q.push(1);q.push(2);q.push(5);q.push(10);while(!q.empty())&#123; cout &lt;&lt; q.top() &lt;&lt; endl; q.pop();&#125; stack栈， push(), top(), pop() 123456#include&lt;stack&gt;// size()// empty()// push() 栈顶加入一个元素// top() 范湖栈顶元素// pop() 弹出栈顶元素 deque双端队列，队头队尾都可以插入删除元素，也可以随机访问，加强版vector。 deque非常厉害，几乎支持其他容器所有的操作，但是速度对应的也比较慢。 12345678910111213#include&lt;deque&gt;size()empty()clear() // 支持清空操作front() // 可以访问头部或尾部元素back()// 能够从头或者尾部插入或删除元素push_back()pop_back()push_front()pop_front()[] // 支持索引操作 set, map multiset, multimap基于平衡二叉树(红黑树), 动态维护有序序列 1234567891011121314151617181920212223242526size();empty();clear();begin()/end(); ++ , -- 迭代器支持自增自减 返回前驱后继 时间复杂度也是log nset/ multiset// multiset可以存储多个相同的元素insert(); // 插入一个元素 log(n)find(x); // 查找一个元素count(x); // 返回某个数的个数erase(); // 输入一个数x，则删除所有x O(k + log n) k是元素个数 输入一个迭代器，则删除这个迭代器lower_bound()/ upper_bound(); // lower_bound(x) 返回大于等于x的最小的数的迭代器 upper_bound(x) 返回大于x的最小的数的迭代器map/ multimap; // 将两个元素做映射， multi_map支持一个key对应多个valueinsert(); // 插入的是一个pairerase(); // 输入的参数是一个pair或者迭代器find(); // []; // 支持索引操作 时间复杂度O(log n)#include&lt;map&gt;map&lt;string, int&gt; a;a[\"wdh\"] = 1;cout &lt;&lt; a[\"wdh\"] &lt;&lt; endl; unordered_set, unordered_map, unordered_multiset, unordered_multimap使用哈希表进行存储 操作和上面的相同，时间复杂度都是O(1)。内部无续，不支持lower_bound, upper_bound。不支迭代器的++ – bitset压位， 进行位运算，如状压DP的对状态的各种位操作。 比如如果开大小为1024的bool数组，那么需要使用1KB内存。 但是如果使用压位，那么只需要使用125B内存。 要开10000 * 10000的bool数组，那么需要大概100MB内存，但是内存限制是64MB， 这个时候使用压位就可以只用 12MB内存。 12345678910111213bitset&lt;10000&gt; s; // 一万位~ &amp; | ^; // 按位逻辑操作&gt;&gt; &lt;&lt; ; // 移位操作==, != ; // 比较操作[]; // 取出某一位count(); // 返回有多少个1any(); // 判断是否至少有一个1none(); // 判断是否全为零set(); // 把所有位置为1set(k, v); // 将第k位变成vreset(); // 将所有位变成零flip(); // 将所有位取反，等价于~flip(k); // 将第k位取反 algorithm实现了一些常用算法 1234567891011121314vector&lt;int&gt; a;sort(a.begin(), a.end()); // 对a进行快速排序reverse(a.begin(), a.end()); // 翻转一个vectorunique(a.begin(), a.end()); // 返回去重之后的尾迭代器(指针), 前闭后开，返回的是去重之后末尾元素的下一个位置int m =unique(a.begin(), a.end()) - a.begin(); // 计算去重之后的元素个数mrandom_shuffle(a.begin(), a.end()); // 随机打乱顺序next_permutation(); // 将两个迭代器(指针)指定的部分看做一个排列，求出这些元素构成的全排列中，字典序排在写一个的全排列。并直接在序列上更新。若不存在，则返回false，否则返回true。同理有prev_permutation函数// 输出1 - n的 n！中全排列int q[3] = &#123;1, 2, 3&#125;;do&#123; for(int i = 0; i &lt; 3; i ++) cout &lt;&lt; q[i] &lt;&lt; \" \"; cout &lt;&lt; endl;&#125;while(next_permutation(q, q+3));","categories":[],"tags":[{"name":"STL常用容器","slug":"STL常用容器","permalink":"http://believebest35.github.io/tags/STL%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8/"}]},{"title":"leetcode 279 完全平方数","slug":"leetcode-solution-2","date":"2020-07-22T14:39:07.000Z","updated":"2020-10-13T12:27:35.868Z","comments":true,"path":"2020/07/22/leetcode-solution-2/","link":"","permalink":"http://believebest35.github.io/2020/07/22/leetcode-solution-2/","excerpt":"Leetcode 279 完全平方数leetcode 279 题目描述给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。 示例输入: n = 12输出: 3解释: 12 = 4 + 4 + 4. 输入: n = 13输出: 2解释: 13 = 4 + 9.","text":"Leetcode 279 完全平方数leetcode 279 题目描述给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。 示例输入: n = 12输出: 3解释: 12 = 4 + 4 + 4. 输入: n = 13输出: 2解释: 13 = 4 + 9. 方法一：暴力拿到题目后想都没想Orz，直接dfs暴力搜索，果然T了。。。TAT 123456789101112131415161718192021222324252627class Solution&#123;public: int ans; void dfs(int left, int base, int count) &#123; if (left &lt; 0) return; if (left == 0) &#123; ans = min(ans, count); return; &#125; for (int i = base; i &gt;= 1; i--) dfs(left - i * i, i, count + 1); &#125; int numSquares(int n) &#123; ans = n; dfs(n, pow(n, 1.0 / 2.0), 0); return ans; &#125;&#125;; 方法二：动态规划设dp[i]表示和为i的最小平方数的个数，转移方程为：dp[i] = min(dp[i], dp[i - j * j] + 1); 123456789101112131415class Solution&#123;public: int numSquares(int n) &#123; vector&lt;int&gt; dp(n + 1, 0); for (int i = 1; i &lt;= n; i++) &#123; dp[i] = i; for (int j = 1; i - j * j &gt;= 0; j++) dp[i] = min(dp[i], dp[i - j * j] + 1); &#125; return dp[n]; &#125;&#125;;","categories":[],"tags":[{"name":"leetcode_solution","slug":"leetcode-solution","permalink":"http://believebest35.github.io/tags/leetcode-solution/"}]},{"title":"leetcode 剑指offer 11 旋转数组的最小数字","slug":"leetcode-solution-1","date":"2020-07-22T13:10:05.000Z","updated":"2020-10-13T12:27:44.518Z","comments":true,"path":"2020/07/22/leetcode-solution-1/","link":"","permalink":"http://believebest35.github.io/2020/07/22/leetcode-solution-1/","excerpt":"Leetcode 剑指offer 11 旋转数组的最小数字剑指offer 11 on leetcode 题目描述把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。 示例输入：[3,4,5,1,2]输出：1 输入：[2,2,2,0,1]输出：0","text":"Leetcode 剑指offer 11 旋转数组的最小数字剑指offer 11 on leetcode 题目描述把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。 示例输入：[3,4,5,1,2]输出：1 输入：[2,2,2,0,1]输出：0 方法一：暴力暴力的方法相对很直观，比较容易想到。但这道题没有说明搬运元素的个数，因此需要特判一下\b是否没有搬运，即比较数组头和数组尾元素大小即可。若nums[0] &lt; nums[n - 1]则说明没有搬运，直接返回第一个元素即可。 若搬运了元素，进行一次遍历即可，返回满足nums[i] &lt; nums[i - 1]的元素即可。 1234567891011121314151617181920class Solution&#123;public: int minArray(vector&lt;int&gt;&amp; numbers) &#123; int n = numbers.size(); if (n == 0) return 0; if (n == 1) return numbers[0]; if (n == 2) return min(numbers[0], numbers[1]); if (numbers[0] &lt; numbers[n - 1]) return numbers[0]; for (int i = 1; i &lt; n; i++) if (numbers[i] &lt; numbers[i - 1]) return numbers[i]; return numbers[n - 1]; &#125;&#125;; 显然时间复杂度为O(n)。 方法二：二分查找暴力的时间复杂度过高，通过二分查找可以将平均时间复杂度降至O(logn)。假定左端元素下标为i，右端元素下标为j，每次二分后得到mid元素可能以下存在三种情况 nums[mid] &lt; nums[j] 说明被找元素位于i和mid之间，因此将j修改为mid nums[mid] &gt; nums[j] 说明被找元素位于j和mid之间，因此将i修改为mid + 1 nums[mid] == nums[j] 由于存在重复元素，因此不能轻易修改i、j，由于mid和j处元素相同，因此不论nums[j]是否为最小元素， j左边应该存在一个“替代品”。。。因此将j–即可。 12345678910111213141516171819202122232425262728class Solution&#123;public: int minArray(vector&lt;int&gt;&amp; numbers) &#123; int n = numbers.size(); if (n == 0) return 0; if (n == 1) return numbers[0]; if (n == 2) return min(numbers[0], numbers[1]); if (numbers[0] &lt; numbers[n - 1]) return numbers[0]; int i = 0, j = n - 1; while (i &lt; j) &#123; int mid = i + (j - i) / 2; if (numbers[mid] &lt; numbers[j]) j = mid; else if (numbers[mid] &gt; numbers[j]) i = mid + 1; else j--; &#125; return numbers[i]; &#125;&#125;; 平均时间复杂度为O(logn)。 这似乎是我开始写的第一篇blog，希望我以后能够将写博客的习惯坚持下去吧，最近发现自己实在是太菜了Orz，无论是科研还是代码能力都菜得抠脚Orz。。。TAT 为此我也希望自己开始改变吧，以后无论是刷leetcode，还是读论文等等，与技术相关的东西我渐渐都会放在这里，希望自己在这两年卷的飞起的环境里还能找到一个还算行的工作吧。。。Orz 这里可能也会放一些吐槽吧。。。","categories":[],"tags":[{"name":"leetcode_solution","slug":"leetcode-solution","permalink":"http://believebest35.github.io/tags/leetcode-solution/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-07-19T15:31:33.751Z","updated":"2020-10-13T12:28:08.020Z","comments":true,"path":"2020/07/19/hello-world/","link":"","permalink":"http://believebest35.github.io/2020/07/19/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://believebest35.github.io/tags/Java/"},{"name":"Linux","slug":"Linux","permalink":"http://believebest35.github.io/tags/Linux/"},{"name":"OOP","slug":"OOP","permalink":"http://believebest35.github.io/tags/OOP/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://believebest35.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode_solution","slug":"leetcode-solution","permalink":"http://believebest35.github.io/tags/leetcode-solution/"},{"name":"STL常用容器","slug":"STL常用容器","permalink":"http://believebest35.github.io/tags/STL%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8/"}]}