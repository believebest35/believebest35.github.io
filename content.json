{"meta":{"title":"Xinrui Tang","subtitle":"","description":"","author":"Xinrui Tang","url":"http://beloevebest35.github.io","root":"/"},"pages":[{"title":"","date":"2020-07-22T11:24:27.000Z","updated":"2020-07-22T12:12:41.598Z","comments":false,"path":"categories/index.html","permalink":"http://beloevebest35.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2020-07-22T11:26:00.000Z","updated":"2020-07-22T12:12:13.920Z","comments":false,"path":"tags/index.html","permalink":"http://beloevebest35.github.io/tags/index.html","excerpt":"","text":""},{"title":"about me","date":"2020-07-22T11:26:47.000Z","updated":"2020-07-22T12:20:53.959Z","comments":false,"path":"about/index.html","permalink":"http://beloevebest35.github.io/about/index.html","excerpt":"","text":"Hello, this is Xinrui Tang’s blog by hexo."}],"posts":[{"title":"leetcode 287 寻找重复数","slug":"leetcode-solution-3","date":"2020-07-23T07:10:49.000Z","updated":"2020-07-23T07:25:27.728Z","comments":true,"path":"2020/07/23/leetcode-solution-3/","link":"","permalink":"http://beloevebest35.github.io/2020/07/23/leetcode-solution-3/","excerpt":"","text":"Leetcode 287 寻找重复数leetcode 287 题目描述给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。 示例输入: [1,3,4,2,2]输出: 2 输入: [3,1,3,4,2]输出: 3 说明 不能更改原数组（假设数组是只读的）。 只能使用额外的 O(1) 的空间。 时间复杂度小于 O(n^2) 。 数组中只有一个重复的数字，但它可能不止重复出现一次。 解法这道题如果没有说明里的条件的话是非常容易的，可以排序，或者哈希，但是排序修改了原数组，哈希需要O(n)的空间。另外如果没有第一个条件的话可以考虑使用原地哈希。 以上的方法不能使用，因此实际做的时候用的是二分，不过不是对下标进行二分，而是对值域进行二分。最开始范围取到1～n，mid = (1 + n) / 2，每次分别统计小于mid，等于mid以及大于mid的个数，据此缩小空间。 123456789101112131415161718192021222324252627282930class Solution&#123;public: int findDuplicate(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size() - 1; int i = 1, j = n; while (i &lt; j) &#123; int less_k = 0; int large_k = 0; int count_k = 0; int mid = i + (j - i) / 2; for (auto num : nums) if (num == mid) count_k++; else if (num &lt; mid) less_k++; else large_k++; if (count_k &gt;= 2) return mid; if (less_k &gt; mid - 1) j = mid - 1; else i = mid + 1; &#125; return i; // 题目数据保证，不会在这退出。。。 &#125;&#125;;","categories":[],"tags":[{"name":"leetcode_solution","slug":"leetcode-solution","permalink":"http://beloevebest35.github.io/tags/leetcode-solution/"}]},{"title":"STL常用容器","slug":"stl常用容器","date":"2020-07-23T03:21:30.000Z","updated":"2020-07-23T03:35:45.263Z","comments":true,"path":"2020/07/23/stl常用容器/","link":"","permalink":"http://beloevebest35.github.io/2020/07/23/stl%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8/","excerpt":"","text":"这里记录了一些用c++刷leetcode时可能会用到的stl容器用法 原出处，作者wangdh vector边长数组，倍增思想 系统为某一个程序分配空间时，所需时间和空间大小无关，与申请次数有关。 所以变长数组尽可能减少申请次数。一开始申请一定空间的大小，当超过容量时，申请长度变为二倍的空间，然后将原始空间的元素copy过来。 当初始化的时候不指定空间大小，但是使用的空间有非常大之后需要多次扩容，那么扩容需要的时间复杂度是O(N) 相当于插入一个元素就需要将O(1)的时间。申请空间的次数是O(log n)。 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;int main()&#123; vector&lt;int&gt; a; // 定义一个vecotr vector&lt;int&gt; a(10); // 初始长度为10； vector&lt;int&gt; a(10, 3); // 初始长度为10， 且每个元素初始化为3 for(auto i : a) cout &lt;&lt; i &lt;&lt; \" \"; // 遍历元素的方式 ， auto 关键字，系统自动推断变量类型，变量名比较长的时候可以使用 vector&lt;int&gt; a[10]; // 定义了vector数组，每个元素都是一个vector&lt;int&gt; a.size(); // 返回列表里的元素的个数 a.empty(); // 返回列表是不是空 // size() 和empty() 是所有容器都有的，时间复杂度是o(1) a.clear(); // 清空，不是所有的容器都有 a.front(); // 返回第一个元素 a.back(); // 返回最后一个元素 a.push_back(); // 从最后插入一个元素 a.pop_back(); // 删除最后一个元素 a.begin(); a.end(); // 迭代器。 可以看做指针，可以解引用 a[2]; // 支持随机寻址，与数组相同 // 三种遍历方式 for(int i = 0; i &lt; a.size(); i ++) cout &lt;&lt; a[i] &lt;&lt; \" \"; cout &lt;&lt; endl; for(vector&lt;int&gt;::iterator i = a.begin(); i != a.end(); i ++) cout &lt;&lt; *i &lt;&lt; \" \"; for(auto i = a.begin(); i != a.end(); i ++) cout &lt;&lt; *i &lt;&lt; \" \"; // 迭代器，解引用 cout &lt;&lt; endl; for(auto x : a) cout &lt;&lt; x &lt;&lt; \" \"; // auto关键字自动推断类型 cout &lt;&lt; endl; // vector支持比较，按位进行字典序比较 vector&lt;int&gt; a(4, 3), b(3, 4); cout &lt;&lt; (a &lt; b); return 0;&#125; pair元组类型，相当于Python中的(). 当一个元素有多个属性的时候，可以使用pair来进行存储。当需要按照某个属性来排序的时候，就非常好。 比如合并区间的问题。每个区间有开始和结尾两个属性，然后需要按照区间的开始对区间进行排序。 可以看做实现了一个结构体，且实现了比较器。 12345678910111213141516171819202122232425262728293031// 两种初始化方法pair&lt;int, string&gt; p;p = make_pair(10, \"aa\");p = &#123;q, \"ab\"&#125;;// 支出比较运算，first为第一关键字，second为第二关键字pair&lt;int, string&gt; p = &#123;1, \"aa\"&#125;;pair&lt;int, string&gt; q = &#123;1, \"ab\"&#125;;// first取出第一个字， second取出第二个字cout &lt;&lt; p.first &lt;&lt; endl;cout &lt;&lt; p.second &lt;&lt; endl;cout &lt;&lt; (p &lt; q) &lt;&lt; endl;// 也可以使用pair存储三个属性等; pair 嵌套pairpair&lt;int, pair&lt;int, int&gt;&gt; p;string字符串，substr(), c_str()string s = \"a\"; s += \"ab\"; // 支持增量操作s += 'a';cout &lt;&lt; s &lt;&lt; endl;cout &lt;&lt; s.substr(1, 2) &lt;&lt; endl; // 可以取出某个子串，第一个是起始index，第二个是长度。第二个缺省或者超过范围则返回之后的左右字符串cout &lt;&lt; s.substr(1) &lt;&lt; endl;cout &lt;&lt; s.substr(1, 100) &lt;&lt; endl;printf(\"%s\\n\", s.c_str()); // 使用printf输出的时候，需要找到存储字符串数组的起始地址。c_str()可以返回size() | length() // 返回字符串的长度 s.find('a'); // 返回a在s中的位置,如果没找到，返回一个特别的标志c++中用npos表示(可以用s.npos)来表示 queue队列，push(), front() , pop(),back() 1234567// push() 向队尾插入一个元素// front() 返回队头元素// pop() 返回队尾元素// back() 弹出队头元素// size() // empty()// 没有clear操作 priority_queue优先队列，push(), top(), pop() 123456789101112131415161718192021222324// 内部使用堆维护// 默认是大顶堆，和python相反// 使用小顶对方法// 1. 在插入的时候插入元素的相反数即可// 2. 如下定义#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;iostream&gt;#include&lt;csting&gt;#include&lt;queue&gt;using namespace std;priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; heap;// priority_queue&lt;int&gt; q; // 大顶堆priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q; // 小顶堆q.push(1);q.push(2);q.push(5);q.push(10);while(!q.empty())&#123; cout &lt;&lt; q.top() &lt;&lt; endl; q.pop();&#125; stack栈， push(), top(), pop() 123456#include&lt;stack&gt;// size()// empty()// push() 栈顶加入一个元素// top() 范湖栈顶元素// pop() 弹出栈顶元素 deque双端队列，队头队尾都可以插入删除元素，也可以随机访问，加强版vector。 deque非常厉害，几乎支持其他容器所有的操作，但是速度对应的也比较慢。 12345678910111213#include&lt;deque&gt;size()empty()clear() // 支持清空操作front() // 可以访问头部或尾部元素back()// 能够从头或者尾部插入或删除元素push_back()pop_back()push_front()pop_front()[] // 支持索引操作 set, map multiset, multimap基于平衡二叉树(红黑树), 动态维护有序序列 1234567891011121314151617181920212223242526size();empty();clear();begin()/end(); ++ , -- 迭代器支持自增自减 返回前驱后继 时间复杂度也是log nset/ multiset// multiset可以存储多个相同的元素insert(); // 插入一个元素 log(n)find(x); // 查找一个元素count(x); // 返回某个数的个数erase(); // 输入一个数x，则删除所有x O(k + log n) k是元素个数 输入一个迭代器，则删除这个迭代器lower_bound()/ upper_bound(); // lower_bound(x) 返回大于等于x的最小的数的迭代器 upper_bound(x) 返回大于x的最小的数的迭代器map/ multimap; // 将两个元素做映射， multi_map支持一个key对应多个valueinsert(); // 插入的是一个pairerase(); // 输入的参数是一个pair或者迭代器find(); // []; // 支持索引操作 时间复杂度O(log n)#include&lt;map&gt;map&lt;string, int&gt; a;a[\"wdh\"] = 1;cout &lt;&lt; a[\"wdh\"] &lt;&lt; endl; unordered_set, unordered_map, unordered_multiset, unordered_multimap使用哈希表进行存储 操作和上面的相同，时间复杂度都是O(1)。内部无续，不支持lower_bound, upper_bound。不支迭代器的++ – bitset压位， 进行位运算，如状压DP的对状态的各种位操作。 比如如果开大小为1024的bool数组，那么需要使用1KB内存。 但是如果使用压位，那么只需要使用125B内存。 要开10000 * 10000的bool数组，那么需要大概100MB内存，但是内存限制是64MB， 这个时候使用压位就可以只用 12MB内存。 12345678910111213bitset&lt;10000&gt; s; // 一万位~ &amp; | ^; // 按位逻辑操作&gt;&gt; &lt;&lt; ; // 移位操作==, != ; // 比较操作[]; // 取出某一位count(); // 返回有多少个1any(); // 判断是否至少有一个1none(); // 判断是否全为零set(); // 把所有位置为1set(k, v); // 将第k位变成vreset(); // 将所有位变成零flip(); // 将所有位取反，等价于~flip(k); // 将第k位取反 algorithm实现了一些常用算法 1234567891011121314vector&lt;int&gt; a;sort(a.begin(), a.end()); // 对a进行快速排序reverse(a.begin(), a.end()); // 翻转一个vectorunique(a.begin(), a.end()); // 返回去重之后的尾迭代器(指针), 前闭后开，返回的是去重之后末尾元素的下一个位置int m =unique(a.begin(), a.end()) - a.begin(); // 计算去重之后的元素个数mrandom_shuffle(a.begin(), a.end()); // 随机打乱顺序next_permutation(); // 将两个迭代器(指针)指定的部分看做一个排列，求出这些元素构成的全排列中，字典序排在写一个的全排列。并直接在序列上更新。若不存在，则返回false，否则返回true。同理有prev_permutation函数// 输出1 - n的 n！中全排列int q[3] = &#123;1, 2, 3&#125;;do&#123; for(int i = 0; i &lt; 3; i ++) cout &lt;&lt; q[i] &lt;&lt; \" \"; cout &lt;&lt; endl;&#125;while(next_permutation(q, q+3));","categories":[],"tags":[{"name":"STL常用容器","slug":"STL常用容器","permalink":"http://beloevebest35.github.io/tags/STL%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8/"}]},{"title":"leetcode 279 完全平方数","slug":"leetcode-solution-2","date":"2020-07-22T14:39:07.000Z","updated":"2020-07-23T07:10:09.209Z","comments":true,"path":"2020/07/22/leetcode-solution-2/","link":"","permalink":"http://beloevebest35.github.io/2020/07/22/leetcode-solution-2/","excerpt":"","text":"Leetcode 279 完全平方数leetcode 279 题目描述给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。 示例输入: n = 12输出: 3解释: 12 = 4 + 4 + 4. 输入: n = 13输出: 2解释: 13 = 4 + 9. 方法一：暴力拿到题目后想都没想Orz，直接dfs暴力搜索，果然T了。。。TAT 123456789101112131415161718192021222324252627class Solution&#123;public: int ans; void dfs(int left, int base, int count) &#123; if (left &lt; 0) return; if (left == 0) &#123; ans = min(ans, count); return; &#125; for (int i = base; i &gt;= 1; i--) dfs(left - i * i, i, count + 1); &#125; int numSquares(int n) &#123; ans = n; dfs(n, pow(n, 1.0 / 2.0), 0); return ans; &#125;&#125;; 方法二：动态规划设dp[i]表示和为i的最小平方数的个数，转移方程为：dp[i] = min(dp[i], dp[i - j * j] + 1); 123456789101112131415class Solution&#123;public: int numSquares(int n) &#123; vector&lt;int&gt; dp(n + 1, 0); for (int i = 1; i &lt;= n; i++) &#123; dp[i] = i; for (int j = 1; i - j * j &gt;= 0; j++) dp[i] = min(dp[i], dp[i - j * j] + 1); &#125; return dp[n]; &#125;&#125;;","categories":[],"tags":[{"name":"leetcode_solution","slug":"leetcode-solution","permalink":"http://beloevebest35.github.io/tags/leetcode-solution/"}]},{"title":"leetcode 剑指offer 11 旋转数组的最小数字","slug":"leetcode-solution-1","date":"2020-07-22T13:10:05.000Z","updated":"2020-07-23T06:23:05.009Z","comments":true,"path":"2020/07/22/leetcode-solution-1/","link":"","permalink":"http://beloevebest35.github.io/2020/07/22/leetcode-solution-1/","excerpt":"","text":"Leetcode 剑指offer 11 旋转数组的最小数字剑指offer 11 on leetcode 题目描述把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。 示例输入：[3,4,5,1,2]输出：1 输入：[2,2,2,0,1]输出：0 方法一：暴力暴力的方法相对很直观，比较容易想到。但这道题没有说明搬运元素的个数，因此需要特判一下\b是否没有搬运，即比较数组头和数组尾元素大小即可。若nums[0] &lt; nums[n - 1]则说明没有搬运，直接返回第一个元素即可。 若搬运了元素，进行一次遍历即可，返回满足nums[i] &lt; nums[i - 1]的元素即可。 1234567891011121314151617181920class Solution&#123;public: int minArray(vector&lt;int&gt;&amp; numbers) &#123; int n = numbers.size(); if (n == 0) return 0; if (n == 1) return numbers[0]; if (n == 2) return min(numbers[0], numbers[1]); if (numbers[0] &lt; numbers[n - 1]) return numbers[0]; for (int i = 1; i &lt; n; i++) if (numbers[i] &lt; numbers[i - 1]) return numbers[i]; return numbers[n - 1]; &#125;&#125;; 显然时间复杂度为O(n)。 方法二：二分查找暴力的时间复杂度过高，通过二分查找可以将平均时间复杂度降至O(logn)。假定左端元素下标为i，右端元素下标为j，每次二分后得到mid元素可能以下存在三种情况 nums[mid] &lt; nums[j] 说明被找元素位于i和mid之间，因此将j修改为mid nums[mid] &gt; nums[j] 说明被找元素位于j和mid之间，因此将i修改为mid + 1 nums[mid] == nums[j] 由于存在重复元素，因此不能轻易修改i、j，由于mid和j处元素相同，因此不论nums[j]是否为最小元素， j左边应该存在一个“替代品”。。。因此将j–即可。 12345678910111213141516171819202122232425262728class Solution&#123;public: int minArray(vector&lt;int&gt;&amp; numbers) &#123; int n = numbers.size(); if (n == 0) return 0; if (n == 1) return numbers[0]; if (n == 2) return min(numbers[0], numbers[1]); if (numbers[0] &lt; numbers[n - 1]) return numbers[0]; int i = 0, j = n - 1; while (i &lt; j) &#123; int mid = i + (j - i) / 2; if (numbers[mid] &lt; numbers[j]) j = mid; else if (numbers[mid] &gt; numbers[j]) i = mid + 1; else j--; &#125; return numbers[i]; &#125;&#125;; 平均时间复杂度为O(logn)。 这似乎是我开始写的第一篇blog，希望我以后能够将写博客的习惯坚持下去吧，最近发现自己实在是太菜了Orz，无论是科研还是代码能力都菜得抠脚Orz。。。TAT 为此我也希望自己开始改变吧，以后无论是刷leetcode，还是读论文等等，与技术相关的东西我渐渐都会放在这里，希望自己在这两年卷的飞起的环境里还能找到一个还算行的工作吧。。。Orz 这里可能也会放一些吐槽吧。。。","categories":[],"tags":[{"name":"leetcode_solution","slug":"leetcode-solution","permalink":"http://beloevebest35.github.io/tags/leetcode-solution/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-07-19T15:31:33.751Z","updated":"2020-07-19T15:31:33.751Z","comments":true,"path":"2020/07/19/hello-world/","link":"","permalink":"http://beloevebest35.github.io/2020/07/19/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"leetcode_solution","slug":"leetcode-solution","permalink":"http://beloevebest35.github.io/tags/leetcode-solution/"},{"name":"STL常用容器","slug":"STL常用容器","permalink":"http://beloevebest35.github.io/tags/STL%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8/"}]}