{"meta":{"title":"Xinrui Tang","subtitle":"","description":"","author":"Xinrui Tang","url":"http://believebest35.github.io","root":"/"},"pages":[{"title":"about me","date":"2020-07-22T11:26:47.000Z","updated":"2020-07-22T12:20:53.959Z","comments":false,"path":"about/index.html","permalink":"http://believebest35.github.io/about/index.html","excerpt":"","text":"Hello, this is Xinrui Tang’s blog by hexo."},{"title":"","date":"2020-07-22T11:24:27.000Z","updated":"2020-07-22T12:12:41.598Z","comments":false,"path":"categories/index.html","permalink":"http://believebest35.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2020-07-22T11:26:00.000Z","updated":"2020-07-22T12:12:13.920Z","comments":false,"path":"tags/index.html","permalink":"http://believebest35.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"面向对象_组合与继承","slug":"OOP-THU-5","date":"2020-10-09T12:31:17.000Z","updated":"2020-10-10T11:51:26.092Z","comments":true,"path":"2020/10/09/OOP-THU-5/","link":"","permalink":"http://believebest35.github.io/2020/10/09/OOP-THU-5/","excerpt":"","text":"组合小的对象组合起来可以形成更大的对象，若对象a是对象b的一个组成部分，则可以说对象b是对象a的整体对象，对象a是对象b的部分对象。对象组合一般有两种实现方法： 将已有的类（对象a）定义为新定义的类（对象b）的公有成员，则可以通过访问原有的类提供旧的接口。 将已有的类定义为新定义的类的私有成员，这样新的类就必须提供新的接口用以访问旧的类，相当于对接口做了变换。 以上的实现形式如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940class A&#123;private: int i;public: void set_i(int x) &#123; i = x; &#125;&#125;;class B&#123;private: int i;public: void set_i(int x) &#123; i = x; &#125;&#125;;class C&#123;private: A a;public: B b; void setA(int x) &#123; a.set_i(x); &#125;&#125;;int main()&#123; C c; c.b.set(0); c.setA(0);&#125; 子对象构造时若需要参数，则应在当前类的构造函数的初始化列表中进行初始化。 继承继承即是从一般到特殊的过程，若类A具有类B全部的数据成员以及对应的接口函数，除此之外还拥有一些自己独有的某些数据成员以及接口函数，则称类A继承与类B。 被继承的已有的类，被称为基类（base class），或者叫做父类。 继承定义出的新的类，被称为派生类（derived class），亦称作子类、扩展类。 常见的继承方式： public继承，定义形式如下所示： 1234class derived_class: public base_class&#123; // ...&#125; private继承，定义形式如下所示： 1234class derived_class: private base_class&#123; // ...&#125; private继承也是默认的继承方式。 protected继承，定义形式如下所示： 1234class derived_class: protected base_class&#123; // ...&#125; 最后一种继承方式很少使用。 派生类对象的构造和析构派生类对象的构造过程中首先初始化的是原属于基类的数据成员，需要调用原属于基类的构造函数来进行初始化。若没有显式调用则会自动调用属于基类的默认构造函数，若显式调用则只能在派生类的构造函数的初始化成员列表中进行调用。基类的数据成员初始化完毕之后再执行派生类的的构造函数。 对象析构时，派生类析构函数先执行，后续再执行基类的析构函数。 1234567891011121314class base&#123;private: int x;public: base(): x(0) &#123;&#125; base(int i): x(i) &#123;&#125;&#125;;class derived: public base&#123;public: derived(int i): base(i) &#123;&#125;&#125; 如上所示，派生类构造函数中显式调用基类的构造函数必须在初始化列表中进行。 继承基类构造函数在派生类中使用using Base::Base; 来继承基类构造函数，相当于给派生类“定义”了相应参数的构造函数。示例如下： 1234567891011121314151617181920class Base&#123; int data;public: Base(int i) : data(i) &#123;&#125; //Base(int i, int j) : data(i + j) &#123;&#125;&#125;;class Derive : public Base&#123;public: using Base::Base; ///相当于 Derive(int i):Base(i)&#123;&#125;; ///当基类存在多个构造函数时，使用using也会给派生类生成多个对应的构造函数，相当于 Derive(int i, int j):Base(i + j)&#123;&#125;&#125;;int main()&#123; Derive obj(356); return 0;&#125; 上述代码在c++11的情况下通过编译，mac自带的clang似乎不能通过编译。。 继承方式的选择 public继承 基类中的公有成员在派生类中仍然能保持公有，原有的接口仍能使用，是最为常用的一种继承方式。 private继承 通常很少使用，可通过组合替代。 protected继承 基本不使用，存在只是为了语言的完备性。 基类成员访问权限与三种继承方式 public继承 基类的公有成员，保护成员，私有成员作为派生类的成员时，都保持原有的状态。 private继承 基类的公有成员，保护成员，私有成员作为派生类的成员时，都作为私有成员。 protected继承 基类的公有成员，保护成员作为派生类的成员时，都成为保护成员，基类的私有成员仍然是私有的。 重写隐藏重写隐藏指的是在派生类中重新定义基类的函数，这样会屏蔽掉基类中的同名函数。 重写隐藏发生时基类中该同名函数的所有重载函数都会被屏蔽掉。可以在派生类中通过using 类名::成员函数名; 在派生类中“恢复”指定的基类成员函数（即去掉屏蔽），使之重新可用。 向上类型转换派生类对象/引用/指针转换成基类对象/引用/指针，称为向上类型转换，只对public继承有效。 凡是接受基类对象/引用/指针的地方（如函数参数），都可以使用派生类对象/引用/指针，编译器会自动将派生类对象转换为基类对象以便使用。 当派生类的对象(不是指针或引用)被转换为基类的对象时，派生类的对象被切片为对应基类的子对象，即会产生派生类对象数据的丢失。","categories":[],"tags":[{"name":"OOP","slug":"OOP","permalink":"http://believebest35.github.io/tags/OOP/"}]},{"title":"面向对象_引用与复制","slug":"OOP-THU-4","date":"2020-10-07T02:36:23.000Z","updated":"2020-10-07T12:19:39.471Z","comments":true,"path":"2020/10/07/OOP-THU-4/","link":"","permalink":"http://believebest35.github.io/2020/10/07/OOP-THU-4/","excerpt":"","text":"引用 引用是对于某个具体变量或者对象的别名，定义为：类型 &amp; 引用名 = 变量名，一个引用的定义示例如下： 12int a;int &amp;ra = a; 上述定义了一个指向变量a的引用ra，ra和a都是内存中统一单元的不同名字。引用在定义时必须进行初始化（即赋初值）。 函数的返回值也可以是引用类型，但是不能返回函数类的临时变量，否则编译器会抛出警告。 引用的优势： 更加灵活的支持运算符的重载。 创建时必须初始化，不存在空引用。 参数中的常量和常量引用某些函数在运行中仅仅需要用到参数的值而并不需要修改，因此可以通过传入常量引用的形式，限制子程序对传入的参数进行修改，示例如下： 12345void f(const int &amp;a, const int &amp;b)&#123; // a = 1; wrong // ...&#125; 上述函数中仅能读取参数a，b的值，并不允许修改。 拷贝构造函数拷贝构造函数是一类特殊的构造函数，其参数为同类对象的常量引用（不一定是常量引用？），一个典型的拷贝构造函数示例如下： 1234567891011121314class Sample&#123;private: int x, y; // ...public: Sample(const Sample &amp;S) &#123; x = S.x; y = S.y; // ... &#125; // ...&#125;; 拷贝构造函数一般在如下情况会被调用： 用一个类对象定义一个新的类对象，例如 123Sample s1;Sample s2(s1);Sample s3 = s1; 函数调用时以对象而不是引用作为参数。 函数返回类对象。 若类在定义时没有显式定义拷贝构造函数，编译器在需要时会自行产生拷贝构造函数，采用的形式为“位拷贝”（浅拷贝），即拷贝成员的地址而非内容，这就容易导致内存泄漏，特别是当数据成员之中含有指针类型的时候。 因此，程序设计中应该尽量减少使用拷贝构造函数。主要的解决方法有： 尽量使用引用/常量引用作为函数参数和函数返回类型。 将拷贝构造函数声明为private成员。 使用delete显式删除拷贝构造函数。 右值引用为此需要先说明左值和右值。 左值：可以取地址、有名字的值。 右值：不能取地址、没有名字的值，常见于常值、函数返回值以及表达式等。 举一个简单的栗子： 12345int a = 0, b = 0;int &amp;ra = a; // rightint *pa = &amp;a; // rightint &amp;ra_b = a + b; // wrongint *pa_b = &amp;(a + b); // wrong 后两个语句编译器会抛出错误，说明右值不能取地址以及被左值引用（&amp;）。 C++11中引入了右值引用的概念。右值引用的形式如下所示： 123int a = 0, b = 0;int &amp;&amp;ra_b = a + b; // rightint &amp;&amp;ra = a; // wrong 如示例所示，右值引用可以绑定到右值上，但不能绑定到左值上，即左值引用绑定左值，右值引用绑定右值，例外是左值常量引用可以绑定右值。 补充一个示例： 123456789void f(const int &amp;a)&#123; // ...&#125;int main()&#123; f(3);&#125; 以上示例不会抛出错误，说明常引用可以绑定到右值上（因为const保证了参数不会被修改）。 右值引用可以延长即将销毁变量的生命周期。 移动构造函数使用右值引用作为参数的构造函数叫做移动构造函数。 移动构造函数与拷贝构造函数最大的区别在于移动构造函数直接利用了原来临时对象中的堆内存，新的对象无需开辟内存，临时对象无需释放内存。 举一个简单的栗子： 12345678910111213141516171819202122232425262728class demo&#123;public: demo():num(new int(0)) &#123; cout&lt;&lt;\"construct!\"&lt;&lt;endl; &#125; //拷贝构造函数 demo(const demo &amp;d):num(new int(*d.num)) &#123; cout&lt;&lt;\"copy construct!\"&lt;&lt;endl; &#125; ~demo() &#123; cout&lt;&lt;\"class destruct!\"&lt;&lt;endl; &#125;private: int *num;&#125;;demo get_demo()&#123; return demo();&#125;int main()&#123; demo a = get_demo(); return 0;&#125; 以上的过程会多次调用拷贝构造函数，临时对象所占用的资源被浪费。 下面的示例引入了移动构造函数： 12345678910111213141516171819202122232425262728293031public: demo():num(new int(0)) &#123; cout&lt;&lt;\"construct!\"&lt;&lt;endl; &#125; demo(const demo &amp;d):num(new int(*d.num)) &#123; cout&lt;&lt;\"copy construct!\"&lt;&lt;endl; &#125; //添加移动构造函数 demo(demo &amp;&amp;d):num(d.num) &#123; d.num = NULL; cout&lt;&lt;\"move construct!\"&lt;&lt;endl; &#125; ~demo() &#123; cout&lt;&lt;\"class destruct!\"&lt;&lt;endl; &#125;private: int *num;&#125;;demo get_demo()&#123; return demo();&#125;int main()&#123; demo a = get_demo(); return 0;&#125; 移动构造函数采用了浅拷贝的方式，直接接管临时对象所占用的资源，避免了无谓的销毁以及申请资源的开销。 右值引用：移动语义有时候需要对左值调用移动构造函数，std提供了move() move可以解引用，即将左值转化为右值，原变量转化为未初始化状态。示例如下： 123Sample a;// ...Sample b = std::move(a); // a之后不会被使用 赋值运算符不同对象之间的赋值可通过重载赋值运算符来实现，示例如下： 12345678910111213141516class_name&amp; operator= (const class_name &amp;right)&#123; if (this != &amp;right) &#123; // ... 具体的赋值操作 &#125; return *this;&#125;int main()&#123; class_name a, b; // ... a = b; // 调用赋值运算 class_name c = a; // 拷贝构造&#125; 自动类型转换当出现对象类型不匹配的时候，需要进行类型转换，即实现从源类到目标类的转换，两个类之间的自动类型转换有如下两种实现方式： 在源类中定义目标类转换运算符，示例如下： 123456789101112class Src&#123;private: // ...public: operator Dst() const &#123; // ... return Dst(); &#125; &#125; 在目标类中定义以源类为参数的构造函数，示例如下： 12345678910class Dst&#123;private: // ...public: Dst(const Src &amp;s) &#123; // ... &#125;&#125; 以上方法只能同时使用一种，个人偏向于使用第二种。 使用关键字explicit可以禁止自动类型转换，即用explicit修饰类型转换运算符或类型转换构造函数，具体如下： 123explicit operator Dst() const;// or explicit Dst(const Src &amp;s); 强制类型转换C++提供了四种类型的强制类型转换。 const_cast，去除类型的const或volatile属性。 static_cast，类似于C风格的强制转换。无条件转换，静态类型转换。 dynamic_cast，动态类型转换。如子类和父类之间的多态类型转换。 reinterpret_cast，仅仅重新解释类型，但没有进行二进制的转换。 对于C++提供的强制类型转换详解需要另查资料。","categories":[],"tags":[{"name":"OOP","slug":"OOP","permalink":"http://believebest35.github.io/tags/OOP/"}]},{"title":"面向对象_创建与销毁","slug":"OOP-THU-3","date":"2020-10-06T11:29:33.000Z","updated":"2020-10-06T15:15:02.543Z","comments":true,"path":"2020/10/06/OOP-THU-3/","link":"","permalink":"http://believebest35.github.io/2020/10/06/OOP-THU-3/","excerpt":"","text":"构造函数对象的初始化工作是由对象的构造函数来完成的。构造函数没有返回值类型，函数名和类名一致，并且允许重载，一个典型的构造函数的定义示例如下： 1234567891011class Student&#123; long ID;public: Student(long id) &#123; ID = id; &#125; Student(int year, int order) &#123; ID = year * 10000 + order; &#125; // ...&#125;; 构造函数也可以类外进行定义。不带任何参数的构造函数被称为默认构造函数，或是缺省构造函数。 构造函数的初始化列表构造函数可以使用初始化列表来对类成员进行初始化。位置出现在函数体左花括号之前、函数参数列表圆括号之后，以冒号作开头，使用数据成员(初始值)的形式。示例如下： 1234567891011class Student&#123; long ID;public: Student(long id) ID(id) &#123;&#125; Student(int year, int order) &#123; ID = year * 10000 + order; &#125; // ...&#125;; 委派构造函数构造函数的初始化列表中还可以调用其他构造函数，被称为委派构造函数。 123456789101112class Info&#123;public: Info() &#123; Init(); &#125; Info(int i) : Info() &#123; id = i; &#125; Info(char c) : Info() &#123; gender = c; &#125;private: void Init() &#123; .... &#125;// 其他初始化 int id &#123;2016&#125;; char gender &#123;'M'&#125;; ...&#125;; 就地初始化C++11支持对于类中非静态成员变量进行如下的初始化： 12345678910class A&#123;private: int a = 1; double b &#123;2.0&#125;; public: A() &#123;&#125; A(int i):a(i) &#123;&#125; A(int i, double j): a(i),b(j) &#123;&#125;&#125;; 显式删除构造函数可以使用delete显式的删除的某些构造函数，以防止出现某些未预期的未定义行为。举一个栗子： 12345678910111213class A&#123;private: int a = 1; double b &#123;2.0&#125;; char c = 'c';public: A() = default; // 显式声明默认构造函数 A(int i):a(i) &#123;&#125; A(char ch) = delete; &#125;;A a('c'); //删除了以char进行初始化的构造函数，可以避免一些工程上的二义性问题，因为char型可以被转为int型，删除之后编译器将禁止这样的未定义行为。 析构函数对象的销毁是由对象的析构函数来完成的，析构函数只有一个，并且不需要任何参数，在对象的生命期结束时自动调用。定义形式为： ~&lt;类名&gt; 具体示例如下： 123456789101112class ClassRoom&#123; int num; long* ID_list;public: ClassRoom() : num(0), ID_list(0); &#123; &#125; // ... ~ClassRoom() &#123; // 析构函数 if (ID_list) delete[] ID_list; // 释放内存 &#125;&#125;; 对于申请动态内存的变量需要显式定义析构函数来释放空间。 类中的静态成员 staticstatic修饰的类成员变量被称为静态数据成员，为属于该类的所有对象所共有，即所有对象中的这个数据域处在同一内存位置。一个简单的示例如下： 12345678910class Sample&#123;private: int x, y; static int count;public: // ...&#125;;int Sample::count = 0; 如上定义了一个属于所有Sample类对象的静态数据成员count，其必须在类外进行初始化。在工程中更为规范的做法是将类的静态数据成员的声明放在.h（头文件）中，具体的初始化放在.cpp（实现文件）中。 成员函数也可以被static修饰，在返回值前面添加static修饰的成员函数，称为类的静态成员函数，一个简单的示例如下： 1234567891011121314class Sample&#123;private: int x, y; static int count;public: static int show_count() &#123; return count; &#125; // ...&#125;;int Sample::count = 0; 类的静态成员既可以通过类名进行访问，也可以通过具体的对象进行访问。 需要注意的是类的静态成员函数不能访问类的非静态数据成员，因为静态成员函数在对象进行初始化之前已经分配了内存空间，并且为所有对象所共有，而非静态数据成员只有在对象进行实例化时才分配具体的空间。 类中的常量成员 const使用const修饰的数据成员称为类的常量数据成员，在一个对象的生命期中不可以被修改。常量数据成员的初始化可以通过以下形式进行： 构造函数的初始化列表进行初始化 就地初始化（C++11的新特性） 注意，不能在构造函数的函数体中对对象的常量数据成员进行赋值。 类的成员函数也可以使用const进行修饰，被称为类的常量成员函数，该成员函数不能改变类的数据成员。 123456789101112class Sample&#123;private: const int x;public: Sample(): x(0) &#123;&#125; const int show_x() &#123; // x = 1; wrong，const修饰的函数不允许修改数据成员 return x; &#125;&#125;; 常量静态数据成员类的数据成员既可以定义为常量，也可以定义为静态的，常量静态数据成员需要在类外进行初始化（int 类型和enum类型除外）。 对象的构造与析构 局部对象的构造与析构 局部对象在程序执行到该局部对象的便进行构造，在其作用域结束时进行析构。 全局对象的构造与析构 全局对象在main函数调用之前进行构造，在main函数执行return之后进行析构。 一般来说程序中需要尽量少使用全局对象。 函数静态对象的构造与析构 函数静态对象是指在函数内部定义的static对象。在程序执行到该局部静态对象的代码时被初始化，离开作用域不析构，第二次执行到该对象代码时，不再初始化，直接使用上一次的对象，在main函数结束后被析构。 参数对象的构造与析构 若传递的是形参，在进入子函数时形参对象进行构造，在离开子函数时进行析构，若传递的是引用，在进入子函数时不进行构造，离开也不进行析构，因为传递的是一个变量的“别名”。 因此函数参数尽可能使用引用传递，可以避免大对象的拷贝。","categories":[],"tags":[{"name":"OOP","slug":"OOP","permalink":"http://believebest35.github.io/tags/OOP/"}]},{"title":"面向对象_封装与接口","slug":"OOP-THU-2","date":"2020-10-05T13:03:07.000Z","updated":"2020-10-06T11:16:22.738Z","comments":true,"path":"2020/10/05/OOP-THU-2/","link":"","permalink":"http://believebest35.github.io/2020/10/05/OOP-THU-2/","excerpt":"","text":"函数重载同一名称的函数，有两个以上不同的函数实现，被称为“函数重载”，例如 123456789void print(const char *msg)&#123; cout &lt;&lt; \"message: \" &lt;&lt; msg &lt;&lt; endl;&#125;void print(int score)&#123; cout &lt;&lt; \"score = \" &lt;&lt; score &lt;&lt; endl;&#125; 编译器将根据函数调用语句的实际参数来决定哪一个函数被调用，多个同名的函数实现之间必须保证至少有一个参数的类型不一样。 函数在定义时可以指定参数的默认值，程序在调用时若不提供参数则会使用默认的参数值，例如： 1234void print(const char *msg = \"hello world\")&#123; cout &lt;&lt; msg &lt;&lt; endl;&#125; 一些基础知识autoauto类型可以根据变量的上下文自动推断变量的类型。例如： 12auto i = 3; // i为整型auto a = 4.0f; // a为浮点数类型 追踪返回类型的函数可以将函数返回类型的声明信息放到函数参数列表的后面进行声明，如： 12345// 普通函数声明形式int func(char* ptr, int val);// 追踪返回类型的函数声明形式auto func(char* ptr, int val) -&gt; int; 追踪返回类型在原本函数返回值的位置使用auto关键字。 decltypedecltype可以对变量或表达式结果的类型进行推导，可以用来重用匿名类型，在泛型编程中结合auto，可用于追踪函数的返回值类型，如： 12345678struct &#123; int a;&#125; s;int main()&#123; decltype(s) s1; // 定义了一个与s同类型的结构体变量&#125; 结合auto和decltype可以推到函数的返回类型，一般用在泛型编程之中。 12345template &lt;typename _Tx, typename _Ty&gt;auto multiply(_Tx x, _Ty y) -&gt; decltype(_Tx * _Ty)&#123; return x * y;&#125; new / deletenew和delete运算符可以在程序运行过程中动态的申请和释放内存空间，如下： 1234int *a = new int; // 申请一个整型变量的空间int *arr = new int[10]; // 申请大小为10的整型数组空间delete a; //删除申请的单个变量delete[] arr; //删除申请的连续内存区域 nullptrC++11引入了nullptr，之前使用NULL表示空指针，NULL被定义为0，可以被视为一个整型变量，因此如下的代码会出现问题： 12345678910111213141516void f(int x, int y)&#123; //...&#125;void f(int x, double *y)&#123; //...&#125;int main()&#123; //... f(2, NULL); // wrong f(2, nullptr); // right&#125; 以上的代码会出现错误，因为在使用NULL表示空指针的时候常常容易忽略NULL也是一个int型常量，而nullptr表示严格意义上的空指针，因此不会出现二义性的错误。 基于范围的for循环举例说明： 12345678void f(vector&lt;int&gt; &amp;nums)&#123; for (auto num : nums) &#123; //... &#125; // 以上可以自动的遍历vector，同理可以推广到其他可迭代类型&#125; 对象对象具有静态特性以及动态特性。 静态特征：可以用某种数据来描述的属性 动态特征：对象表现的行为或具有的功能 用户自定义类型class一个class的定义示例如下： 123456789101112// matrix.h#ifndef __MATRIX_H__#define __MATRIX_H__class Matrix&#123;private: int data[6][6];public: void fill(char dir);&#125;;#endif 成员函数的声明一般放在类定义中，具体实现一般放在实现文件中，例如： 1234567// matrix.cpp#include \"matrix.h\"void Matrix::fill(char dir) //类外需要类名限定&#123; ... // 函数实现&#125; 成员函数的实现也可以放在类定义中，放在类定义中的成员函数会自动内联。 类的成员（数据、函数）可以根据需要分成组，不同组设置不同的访问权限。 public public修饰的成员可以在类外用“.”操作符访问。 private private是不指定成员访问权限时的默认权限，不可以在类外使用“.”运算符进行访问。 protected 有关继承时再进行讨论。 this指针所有成员函数的参数中，隐含着一个指向当前对象的指针变量，其名称为this。 12345678910class Matrix&#123;public: void fill(char dir) &#123; //... this -&gt; data[0][0] = 1; //等价于 data[0][0] = 1; &#125; ...&#125;; 类的运算符重载以一个例子进行说明，类定义如下： 12345678910111213141516171819202122232425class Sample&#123;private: int x, y; static int count;public: Sample(); Sample(int x1, int x2, int y1, int y2): x(x1 + x2), y(y1 + y2) &#123;&#125; Sample(int x1, int y1); ~Sample(); void change_x_y(int x1, int y1); friend Sample operator+ (const Sample &amp;s1, const Sample &amp;s2); // +的重载 声明为友元函数 Sample&amp; operator+= (Sample &amp;s); // += 的重载 friend istream&amp; operator&gt;&gt; (istream &amp;in, Sample &amp;dst); // &gt;&gt;的重载 声明为友元函数 friend ostream&amp; operator&lt;&lt; (ostream &amp;out, Sample &amp;src); // &lt;&lt;的重载 声明为友元函数 void display(); void display_cnt() &#123; count++; cout &lt;&lt; count &lt;&lt; endl; &#125;&#125;;int Sample::count = 0; 运算符+和+=的重载实现如下： 1234567891011121314Sample&amp; Sample::operator+=(Sample &amp;s)&#123; this -&gt; x += s.x; this -&gt; y += s.y; return *this;&#125;Sample operator+ (const Sample &amp;s1, const Sample &amp;s2)&#123; Sample sum; sum.x = s1.x + s2.x; sum.y = s1.y + s2.y; return sum;&#125; 流运算符的重载（&gt;&gt; , &lt;&lt;） 1234567891011istream&amp; operator&gt;&gt; (istream &amp;in, Sample &amp;dst)&#123; in &gt;&gt; dst.x &gt;&gt; dst.y; return in;&#125;ostream&amp; operator&lt;&lt; (ostream &amp;out, Sample &amp;src)&#123; out &lt;&lt; src.x &lt;&lt; \" \" &lt;&lt; src.y; return out;&#125; 关于更多的特殊运算符重载可以查询资料 友元在上面的运算符重载声明中出现了friend关键字，friend可以将外部的一些函数或者类声明为友元，声明为友元的函数或者类可以访问该类的一切成员，不受private关键字的影响。 友元不传递，即朋友的朋友不是你的朋友。 友元不继承，即朋友的孩子不是你的朋友。 友元声明不能定义新的class。 内联函数使用内联函数，编译器在编译时会自动生成与函数等价的表达式语句，从而减少函数调用的开销。例如； 123456789101112inline int max(int a, int b)&#123; return a &gt; b ? a : b;&#125;int main()&#123; int a, b; // ... // cout &lt;&lt; max(a, b) &lt;&lt; endl; 实际会被优化为如下语句 cout &lt;&lt; a &gt; b ? a : b &lt;&lt; endl;&#125;","categories":[],"tags":[{"name":"OOP","slug":"OOP","permalink":"http://believebest35.github.io/tags/OOP/"}]},{"title":"面向对象_编程环境基础","slug":"OOP-THU-1","date":"2020-10-05T08:34:31.000Z","updated":"2020-10-05T12:57:58.141Z","comments":true,"path":"2020/10/05/OOP-THU-1/","link":"","permalink":"http://believebest35.github.io/2020/10/05/OOP-THU-1/","excerpt":"","text":"编译和链接C++源程序变为目标平台上的可执行程序需要经过编译器以及链接器。 编译器：首先将源代码解析为语法分析树，再根据语法分析树生成对应的中间代码或直接生成对应平台的汇编码、机器码，即生成目标文件。 链接器：将目标模块链接为可执行程序。 g++ -c 只编译不链接 g++ -o 链接目标程序 12345678910111213141516171819202122--- Desktop/oop_test » lsmain.cpp--- Desktop/oop_test » cat main.cpp#include&lt;iostream&gt;using namespace std;int main()&#123; cout &lt;&lt; \"hello world\" &lt;&lt; endl; return 0;&#125;--- Desktop/oop_test » lsmain.cpp--- Desktop/oop_test » g++ -c main.cpp--- Desktop/oop_test » lsmain.cpp main.o--- Desktop/oop_test » g++ -o main.out main.o--- Desktop/oop_test » lsmain.cpp main.o main.out--- Desktop/oop_test » ./main.outhello world--- Desktop/oop_test » 宏定义 简单的宏定义：#define &lt;宏名&gt; &lt;字符串&gt; 如 1#define PI 3.14 // 不建议使用宏定义，建议使用const定义常量 带参数的宏定义：#define &lt;宏名&gt; (&lt;参数表&gt;) &lt;字符串&gt; 如 1#define sqr(x) ((x) * (x)) 防止头文件的重复包含 1234#ifndef __BODYDEF_H__#define __BODYDEF_H__// 头文件#endif 防止头文件的重复包含也可以采用如下方式： 1#pragma once 以上保证所有文件不会被编译两次 用于Debug输出 12345#ifdef 标识符 // 程序段1#else // 程序段2#endif MAKE工具MAKE工具是使得大型工程编译工程自动化的一种工具，相当于一个脚本集合。 关于Make命令的具体教程可以参见Make命令教程 格式： 12&lt;target&gt;: prerequisites&lt;tab&gt; command 其中target表示目标文件，target不能为空。prerequisites表示target所依赖的文件，可以为空。 prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。 一个简单的栗子，假设makefile文件编写如下 12345678910source: a.txt b.txt c.txtb.txt: echo \"this is a test\" &gt; b.txtc.txt: echo \"this is a test2\" &gt; c.txta.txt: b.txt c.txt cat b.txt c.txt &gt; a.txt 终端中输入make便会执行第一条命令，即make source 123456789--- Desktop/oop_test » lsmain.cpp main.o main.out makefile--- Desktop/oop_test » make sourceecho \"this is a test\" &gt; b.txtecho \"this is a test2\" &gt; c.txtcat b.txt c.txt &gt; a.txt--- Desktop/oop_test » lsa.txt b.txt c.txt main.cpp main.o main.out makefile--- Desktop/oop_test » 也可以显式指定要执行的命令，例如make b.txt 1234567--- Desktop/oop_test » lsmain.cpp main.o main.out makefile--- Desktop/oop_test » make b.txtecho \"this is a test\" &gt; b.txt--- Desktop/oop_test » lsb.txt main.cpp main.o main.out makefile--- Desktop/oop_test » 常常利用make来管理大型工程的编译过程，更多关于make的高级过程可查询教程。 C++程序命令行参数main函数可接受来自命令行的参数，例如 12345int main(int argc, char** argv)&#123; // .. return 0;&#125; 其中argc中存储的是命令行参数的个数，argv则以C风格字符串的形式保存参数，其中包含了可执行程序文件的名称本身，举一个栗子：main函数如下： 123456789#include&lt;iostream&gt;using namespace std;int main(int a, char ** b)&#123; cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; b[0] &lt;&lt; endl; cout &lt;&lt; \"hello world\" &lt;&lt; endl;&#125; 终端执行结果如下 12345678910--- Desktop/oop_test » lsmain.cpp main.o main.out--- Desktop/oop_test » g++ main.cppls% --- Desktop/oop_test » lsa.out main.cpp main.o main.out--- Desktop/oop_test » ./a.out 1 1 1 1 16./a.outhello world--- Desktop/oop_test »","categories":[],"tags":[{"name":"OOP","slug":"OOP","permalink":"http://believebest35.github.io/tags/OOP/"}]},{"title":"数据结构基础","slug":"data-structure-post-1","date":"2020-09-15T07:16:12.000Z","updated":"2020-09-16T08:49:54.888Z","comments":true,"path":"2020/09/15/data-structure-post-1/","link":"","permalink":"http://believebest35.github.io/2020/09/15/data-structure-post-1/","excerpt":"","text":"数据结构基础绪论数据结构数据结构描绘数据元素以及数据元素之间的关系。 算法的特性 有穷性 确定性 可行性 有输入（不一定） 有输出 线性表线性表是具有相同特性的数据元素的的一个有限序列，一般实现方式有两种： 顺序实现，c++中的数组类型就是对于线性表的顺序实现。 链表实现，即各个元素之间的不是连续的，需要额外存储下一个元素的所在位置。 单链表 双链表 循环链表 … 有序表有序表指的是元素以递增或者递减的方式排列的线性表，需要注意两个有序表的归并排序，即分别使用两个指针扫描两个子线性表，选择其中较小（假设递增排序）的元素归并到新的有序表中。 vectorc++的标准模版库中封装了vector类型，可十分方便的操作线性排列的元素。 123456789101112131415#include &lt;vector&gt;vector&lt;int&gt; v(10); // 初始化具有10个空间的线性表vector&lt;int&gt; v_2(10, 1) //初始化具有10个空间的线性表，每个元素的初始值为1int a = v[1]; //下标访问v.push_back(1);v.pop_back();v.clear(); // 清除所有元素v.erase(v.begin() + 1); // 删除一个元素v.erase(v.begin() + 1, v.begin() + 5) // 删除一段元素v.back();v.front();v.empty();v.size();// ... 栈只能在一端进行插入和删除的线性表，后进先出（FILO） 主要操作： 123456789#include &lt;stack&gt;stack&lt;int&gt; st;st.push(10);st.top();st.pop();st.empty();st.size(); 栈的一些应用 中缀表达式转后缀表达式 后缀表达式求值 … 队列只能在一端进行插入，另外一段进行删除的线性表，先进先出（LILO） 主要操作 12345678910#include &lt;queue&gt;queue&lt;int&gt; que;que.push(1);que.front();que.back();que.pop();que.size();que.empty(); 队列相关的应用 约瑟夫环问题 … 双端队列两端都可以进行插入和删除的线性表 123456789101112131415#include &lt;deque&gt;deque&lt;int&gt; deq; // vector加强版deq.empty();deq.push_front(1);deq.pop_front();deq.push_back(1);deq.pop_back(;deq.back();deq.front();deq.size();deq.clear();deq.insert(); // 同vector的插入deq.erase(deq.begin() + 4); 串的模式匹配 KMP串的模式匹配指的是给定两个字符串T和P，在主串T中找出第一次出现完整子串P的位置，一般的暴力解法如下： 1234567891011121314151617181920212223int brute_force_match(string T, string P)&#123; if (T == \"\" || P == \"\") return -1; int i = 0, j = 0; while (i &lt; T.size() &amp;&amp; j &lt; P.size()) &#123; if (T[i] == P[j]) &#123; i++; j++; &#125; else &#123; i = i - j + 1; j = 0; &#125; &#125; if (j == P.size()) return i - j; else return -1;&#125; 假设T串长m，P串长n，则暴力算法时间复杂度为O(m * n)。 KMP算法则可以将以上的匹配过程加速至O(m + n), KMP算法的核心在于保持匹配过程中i指针的位置不变，修改j指针，使得模式串尽量移动到有效的位置。 具体的讲解可见KMP算法讲解 举一个栗子，以主串ABCABCDHIJK和模式串ABCABB的匹配为例： A B C A B C D H I J K i A B C A B B j 当i指向T中第5个（以0开始标记）元素，j指向P中第5个元素，发生冲突，注意到已经匹配的部分ABCAB的前缀AB和后缀AB是一致的，因此可以跳过再次匹配这一部分的过程，维持i不变，将j移动到P中的第二个位置继续进行匹配。 以上的过程需要求已经匹配部分的前缀和后缀的最长公共部分的长度，并保存在next数组中，next[j]即表示发生冲突时j指针应该移动到的位置。 next数组的具体求法如下： 123456789101112131415161718vector&lt;int&gt; get_next(string P)&#123; vector&lt;int&gt; next(P.size()); next[0] = -1; // 规定next数组的第0位为-1 int j = 0, k = -1; while (j &lt; P.size() - 1) &#123; if (k == -1 || P[k] == P[j]) &#123; j++; k++; next[j] = k; &#125; else k = next[k]; &#125; return next;&#125; 求出next数组之后即可应用KMP算法 1234567891011121314151617181920212223int KMP_match(string T, string P)&#123; if (T == \"\" || P == \"\") return -1; vector&lt;int&gt; next = get_next(P); int i = 0, j = 0; while (i &lt; T.size() &amp;&amp; j &lt; P.size()) &#123; if (j == -1 || T[i] == P[j]) &#123; i++; j++; &#125; else &#123; j = next[j]; &#125; &#125; if (j == P.size()) return i - j; else return -1;&#125; 二叉树二叉树是一种树状的数据结构，二叉树的递归遍历相对比较简单 递归遍历的统一模版如下：12345678910void treeTravel(ListNode *node)&#123; if (node == nullptr) return; cout &lt;&lt; node -&gt; val; // 前序遍历 treeTravel(node -&gt; left); // cout &lt;&lt; node -&gt; val; // 中序遍历 treeTravel(node -&gt; right); // cout &lt;&lt; node -&gt; val; // 后序遍历&#125; 对于二叉树的非递归遍历，前中后序遍历实现形式不同，但也可以统一为一个形式,采用记号进行标记 先给出前序以及中序遍历的非统一非递归实现 前序遍历的非递归实现：1234567891011121314151617void pre_travel(ListNode *node)&#123; if (node == nullptr) return; stack&lt;ListNode*&gt; st; st.push(node); while (!st.empty()) &#123; ListNode *temp = st.top(); cout &lt;&lt; temp -&gt; val; st.pop(); if (temp -&gt; right != nullptr) st.push(temp -&gt; right); if (temp -&gt; left != nullptr) st.push(temp -&gt; left); &#125;&#125; 中序遍历的非递归实现：1234567891011121314151617void in_travel(ListNode *node)&#123; ListNode *cur = node; stack&lt;ListNode*&gt; st; while (cur != nullptr || !st.empty()) &#123; while (cur != nullptr) &#123; st.push(cur); cur = cur -&gt; left; &#125; cur = st.top(); st.pop(); cout &lt;&lt; cur -&gt; val; cur = cur -&gt; right; &#125;&#125; 后序遍历的非递归实现相较于前序以及中序的较为麻烦，不过可以将前两者的代码统一为一个形式 后续遍历的非递归实现：1234567891011121314151617181920212223void post_travel(ListNode *node)&#123; if (node == nullptr) return; stack&lt;pair&lt;ListNode*, int&gt;&gt; st; st.push(make_pair(node, 0)); while (!st.empty()) &#123; ListNode *temp = st.top().first; int flag = st.top().second; st.pop(); if (flag == 0) &#123; st.push(make_pair(temp, 1)); if (temp -&gt; right != nullptr) st.push(make_pair(temp -&gt; right, 0)); if (temp -&gt; left != nullptr) st.push(make_pair(temp -&gt; left, 0)); &#125; else cout &lt;&lt; temp -&gt; val; &#125;&#125; 调整以上的入栈顺序即可实现前序以及中序遍历。 二叉树的层次遍历比较简单，结合队列进行广搜即可。 并查集并查集是一种用于解决元素分组的数据结构，主要用于解决元素分组以及合并的问题，支持的操作包括find以及union。 find 查询两个元素是否在同一个集合中 union 将两个不相交的集合进行合并 初始化1234567int fa[MAX];inline void init(int n)&#123; for (int i = 1; i &lt;= n; i++) fa[i] = i;&#125; 即最开始每个元素分别所属不同的集合。 查询1234567int find(int x)&#123; if(fa[x] == x) return x; else return find(fa[x]);&#125; 合并1234inline void merge(int i, int j)&#123; fa[find(i)] = find(j);&#125; 其中合并可以进行优化，即进行路径压缩 123456789101112131415int find(int x)&#123; if(x == fa[x]) return x; else&#123; fa[x] = find(fa[x]); //父节点设为根节点 return fa[x]; //返回父节点 &#125;&#125;// 简化为一行的写法int find(int x)&#123; return x == fa[x] ? x : (fa[x] = find(fa[x]));&#125; 并查集的按秩合并优化初始化（按秩合并） 12345678inline void init(int n)&#123; for (int i = 1; i &lt;= n; ++i) &#123; fa[i] = i; rank[i] = 1; &#125;&#125; 合并（按秩合并） 12345678910inline void merge(int i, int j)&#123; int x = find(i), y = find(j); //先找到两个根节点 if (rank[x] &lt;= rank[y]) fa[x] = y; else fa[y] = x; if (rank[x] == rank[y] &amp;&amp; x != y) rank[y]++; //如果深度相同且根节点不同，则新的根节点的深度+1&#125; 图图的存储方式 邻接矩阵 邻接表 十字链表 邻接多重表 链式前向星 … 图的遍历 BFS DFS 最小生成树 普里姆算法 克鲁斯卡尔算法 最短路算法 Dijkstra(单源最短路) Floyd 拓扑排序依次寻找入度为0的节点即可 查找顺序查找时间复杂度为O(N),对线性表无特殊限制。 二分查找时间复杂度为O(logN),需要线性表有序。 123456789101112131415int binary_search(vector&lt;int&gt; nums, int target)&#123; int l = 0, r = nums.size() - 1; while (l &lt;= r) &#123; int mid = (l + r) / 2; if (nums[mid] == target) return mid; else if (nums[mid] &lt; target) l = mid + 1; else r = mid - 1; &#125; return -1;&#125; B树 B+树B树和B+树都是一般用于外查找的数据结构。 B树一棵m阶B树(balanced tree of order m)是一棵平衡的m路搜索树。它或者是空树，或者是满足下列性质的树： 根结点至少有两个子女； 每个非根节点所包含的关键字个数 j 满足：┌m/2┐ - 1 &lt;= j &lt;= m - 1； 除根结点以外的所有结点（不包括叶子结点）的度数正好是关键字总数加1，故内部子树个数 k 满足：┌m/2┐ &lt;= k &lt;= m ； 所有的叶子结点都位于同一层。在B-树中，每个结点中关键字从小到大排列，并且当该结点的孩子是非叶子结点时，该k-1个关键字正好是k个孩子包含的关键字的值域的分划。 以上内容摘自百度百科。 B+树to do 排序插入排序1234567891011void insert_sort(vector&lt;int&gt; &amp;nums)&#123; for (int i = 1; i &lt; nums.size(); i++) &#123; int temp = nums[i]; int j; for (j = i - 1; j &gt;= 0 &amp;&amp; nums[j] &gt; temp; j--) nums[j + 1] = nums[j]; nums[j + 1] = temp; &#125;&#125; 时间复杂度为O(n^2) 希尔排序希尔排序需要选择增量对数据进行分组，分完组的各部分分别使用插排，最后直到增量为1 冒泡排序1234567891011121314151617void bubble_sort(vector&lt;int&gt; &amp;nums)&#123; for (int i = 0; i &lt; nums.size() - 1; i++) &#123; bool exchange = false; for (int j = nums.size() - 1; j &gt; i; j--) &#123; if (nums[j] &lt; nums[j - 1]) &#123; swap(nums[j], nums[j - 1]); exchange = true; &#125; &#125; if (!exchange) return; &#125;&#125; 时间复杂度为O(n^2) 选择排序1234567891011void select_sort(vector&lt;int&gt; &amp;nums)&#123; for (int i = 0; i &lt; nums.size(); i++) &#123; int min_pos = i; for (int j = i + 1; j &lt; nums.size(); j++) if (nums[j] &lt; nums[min_pos]) min_pos = j; swap(nums[i], nums[min_pos]); &#125;&#125; 时间复杂度为O(n^2) 快速排序1234567891011121314151617181920212223242526int partition(vector&lt;int&gt; &amp;nums, int l, int r)&#123; int temp = nums[l]; while (l &lt; r) &#123; while (l &lt; r &amp;&amp; nums[r] &gt;= temp) r--; nums[l] = nums[r]; while (l &lt; r &amp;&amp; nums[l] &lt;= temp) l++; nums[r] = nums[l]; &#125; nums[l] = temp; return l;&#125;void quick_sort(vector&lt;int&gt; &amp;nums, int l, int r)&#123; if (l &lt; r) &#123; int i = partition(nums, l, r); quick_sort(nums, l, i - 1); quick_sort(nums, i + 1, r); &#125;&#125; 以上的快速排序没有做随机化处理，更加正统的写法应该随机化选择枢纽元素。平均时间复杂度为O(NlogN) 堆排序利用堆的性质进行排序，stl中提供了优先队列，可直接用于排序。关于具体的堆的实现可以百度。。。 归并排序123456789101112131415161718192021222324252627282930313233343536373839404142434445void merge(int *data,int start,int end,int *result) &#123; int left_length = (end - start + 1) / 2 + 1; int left_index = start; int right_index = start + left_length; int result_index = start; while(left_index&lt;start + left_length &amp;&amp; right_index &lt;end + 1) //store data into new array &#123; if(data[left_index] &lt;= data[right_index]) result[result_index++] = data[left_index++]; else result[result_index++] = data[right_index++]; &#125; while(left_index &lt; start + left_length) result[result_index++] = data[left_index++]; while(right_index &lt;end+1) result[result_index++] = data[right_index++];&#125; void merge_sort(int *data,int start,int end,int *result)&#123; if(1 == end - start) //last only two elements &#123; if(data[start] &gt; data[end]) &#123; int temp = data[start]; data[start] = data[end]; data[end] = temp; &#125; return; &#125; else if (end == start) return; //last one element then there is no need to sort; else&#123; //continue to divide the interval merge_sort(data, start, (end - start + 1) / 2 + start, result); merge_sort(data, (end - start + 1) / 2 + start + 1, end, result); //start to merge sorted data merge(data, start, end, result); for (int i = start; i &lt;= end;++i) &#123; data[i] = result[i]; &#125; &#125;&#125;","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://believebest35.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"leetcode 60 第k个排列","slug":"leetcode-solution-7","date":"2020-09-05T07:14:39.000Z","updated":"2020-09-05T07:25:01.020Z","comments":true,"path":"2020/09/05/leetcode-solution-7/","link":"","permalink":"http://believebest35.github.io/2020/09/05/leetcode-solution-7/","excerpt":"","text":"Leetcode 60 第k个排列leetcode 60 题目描述给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下： “123” “132” “213” “231” “312” “321” 给定 n 和 k，返回第 k 个排列。 说明： 给定 n 的范围是 [1, 9]。 给定 k 的范围是[1, n!]。 示例输入: n = 3, k = 3输出: “213” 输入: n = 4, k = 9输出: “2314” 解法依次固定每一位的取值即可,注意是从0开始计数的因此k需要减1，当k到0的时候就可以直接将剩下的数字直接接在最后。 123456789101112131415161718192021class Solution&#123;public: string getPermutation(int n, int k) &#123; vector&lt;int&gt; fac = &#123;0, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880&#125;; string s = string(\"123456789\").substr(0, n); k--; string ans = \"\"; while (k &gt; 0) &#123; int id = k / fac[n - 1]; ans += s[id]; s.erase(s.begin() + id); k %= fac[n - 1]; n--; &#125; ans += s; return ans; &#125;&#125;;","categories":[],"tags":[{"name":"leetcode_solution","slug":"leetcode-solution","permalink":"http://believebest35.github.io/tags/leetcode-solution/"}]},{"title":"leetcode 329 矩阵中的最长递增路径","slug":"leetcode-solution-6","date":"2020-07-26T16:02:08.000Z","updated":"2020-07-26T16:10:57.584Z","comments":true,"path":"2020/07/27/leetcode-solution-6/","link":"","permalink":"http://believebest35.github.io/2020/07/27/leetcode-solution-6/","excerpt":"","text":"Leetcode 329 矩阵中的最长递增路径leetcode 329 题目描述给定一个整数矩阵，找出最长递增路径的长度。 对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外（即不允许环绕） 示例输入: nums = [9,9,4] [6,6,8] [2,1,1]输出: 4解释: 最长递增路径为 [1, 2, 6, 9]。 输入: nums = [3,4,5] [3,2,6] [2,2,1]输出: 4解释: 最长递增路径是 [3, 4, 5, 6]。注意不允许在对角线方向上移动。 方法：DFS这道题明显可以用dfs来写，不过最朴素的dfs（不带剪枝）会超时，因此需要简单的剪枝。或者可以写成记忆化递归的形式。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution&#123;public: int m, n; int ans; void dfs(vector&lt;vector&lt;int&gt;&gt; &amp;matrix, vector&lt;vector&lt;int&gt;&gt; &amp;dp, int x, int y) &#123; if (x &gt;= 1 &amp;&amp; matrix[x - 1][y] &gt; matrix[x][y] &amp;&amp; dp[x - 1][y] &lt; dp[x][y] + 1) &#123; dp[x - 1][y] = dp[x][y] + 1; ans = max(ans, dp[x - 1][y]); dfs(matrix, dp, x - 1, y); &#125; if (x &lt; m - 1 &amp;&amp; matrix[x + 1][y] &gt; matrix[x][y] &amp;&amp; dp[x + 1][y] &lt; dp[x][y] + 1) &#123; dp[x + 1][y] = dp[x][y] + 1; ans = max(ans, dp[x + 1][y]); dfs(matrix, dp, x + 1, y); &#125; if (y &gt;= 1 &amp;&amp; matrix[x][y - 1] &gt; matrix[x][y] &amp;&amp; dp[x][y - 1] &lt; dp[x][y] + 1) &#123; dp[x][y - 1] = dp[x][y] + 1; ans = max(ans, dp[x][y - 1]); dfs(matrix, dp, x, y - 1); &#125; if (y &lt; n - 1 &amp;&amp; matrix[x][y + 1] &gt; matrix[x][y] &amp;&amp; dp[x][y + 1] &lt; dp[x][y] + 1) &#123; dp[x][y + 1] = dp[x][y] + 1; ans = max(ans, dp[x][y + 1]); dfs(matrix, dp, x, y + 1); &#125; &#125; int longestIncreasingPath(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; m = matrix.size(); if (m == 0) return 0; ans = 1; n = matrix[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 1)); for (int i = 0; i &lt; m; i++) for (int j = 0; j &lt; n; j++) dfs(matrix, dp, i, j); return ans; &#125;&#125;;","categories":[],"tags":[{"name":"leetcode_solution","slug":"leetcode-solution","permalink":"http://believebest35.github.io/tags/leetcode-solution/"}]},{"title":"leetcode 322 零钱兑换 and leetcode 410 分割数组的最大值","slug":"leetcode-solution-5","date":"2020-07-25T08:03:33.000Z","updated":"2020-07-25T08:32:37.112Z","comments":true,"path":"2020/07/25/leetcode-solution-5/","link":"","permalink":"http://believebest35.github.io/2020/07/25/leetcode-solution-5/","excerpt":"","text":"Leetcode 322 零钱兑换leetcode 322 题目描述给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。 示例输入: coins = [1, 2, 5], amount = 11输出: 3解释: 11 = 5 + 5 + 1 输入: coins = [2], amount = 3输出: -1 说明你可以认为每种硬币的数量是无限的。 方法一：DFS这是一道典型的可以用dfs来做的题，但。。。他T了 12345678910111213141516171819202122232425262728293031class Solution&#123;public: int ans; void dfs(vector&lt;int&gt; &amp;coins, int amount, int count) &#123; if (amount == 0) &#123; if (ans == -1) ans = count; else ans = min(ans, count); return; &#125; if (amount &lt; 0) return; for (int i = coins.size() - 1; i &gt;= 0; i--) dfs(coins, amount - coins[i], count + 1); &#125; int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123; // sort(coins.begin(), coins.end()); ans = -1; dfs(coins, amount, 0); return ans; &#125;&#125;; 方法二：DPDP状态很好设置，dp[i]即表示组成金额为i的所需最小金币个数，其中初始化如下： dp[0] = 0 若i = 某硬币面值，则dp[i] = 1; 其余均初始化为-1 状态转移过程直接写在代码里了 12345678910111213141516171819202122232425262728class Solution&#123;public: int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123; sort(coins.begin(), coins.end()); if (amount &lt; 0) return -1; vector&lt;int&gt; dp(amount + 1, -1); dp[0] = 0; for (int i = 0; i &lt; coins.size(); i++) if (coins[i] &lt;= amount) dp[coins[i]] = 1; for (int i = 1; i &lt;= amount; i++) &#123; if (dp[i] == 1) continue; for (int j = 0; j &lt; coins.size(); j++) &#123; if (i - coins[j] &gt;= 0 &amp;&amp; dp[i - coins[j]] != -1) dp[i] = (dp[i] == -1) ? (dp[i - coins[j]] + 1) : min(dp[i], dp[i - coins[j]] + 1); &#125; &#125; return dp[amount]; &#125;&#125;; Leetcode 410 分割数组的最大值leetcode 419 题目描述给定一个非负整数数组和一个整数 m，你需要将这个数组分成 m 个非空的连续子数组。设计一个算法使得这 m 个子数组各自和的最大值最小。 注意:数组长度 n 满足以下条件: 1 ≤ n ≤ 1000 1 ≤ m ≤ min(50, n) 示例输入:nums = [7,2,5,10,8]m = 2 输出:18 解释:一共有四种方法将nums分割为2个子数组。其中最好的方式是将其分为[7,2,5] 和 [10,8]，因为此时这两个子数组各自的和的最大值为18，在所有情况中最小。 方法动态规划，dp[i][j]表示前i个数被分为j段后的所有方案中各个子数组和最大值的最小值。。求前缀和比较亮眼。。。 12345678910111213141516171819202122class Solution&#123;public: int splitArray(vector&lt;int&gt;&amp; nums, int m) &#123; int n = nums.size(); vector&lt;long long&gt; pre_sum(n + 1, 0); pre_sum[1] = nums[0]; for (int i = 0; i &lt; n; i++) pre_sum[i + 1] = pre_sum[i] + nums[i]; vector&lt;vector&lt;long long&gt;&gt; dp(n + 1, vector&lt;long long&gt;(m + 1, LLONG_MAX)); //dp[i][j]表示前i个数被分为j段后各个子数组和最大值的最小值。。 dp[0][0] = 0; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= min(m, i); j++) for (int k = 0; k &lt; i; k++) dp[i][j] = min(dp[i][j], max(dp[k][j - 1], pre_sum[i] - pre_sum[k])); return dp[n][m]; &#125;&#125;;","categories":[],"tags":[{"name":"leetcode_solution","slug":"leetcode-solution","permalink":"http://believebest35.github.io/tags/leetcode-solution/"}]},{"title":"leetcode 1025 除数博弈","slug":"leetcode-solution-4","date":"2020-07-24T07:54:08.000Z","updated":"2020-07-24T08:06:57.075Z","comments":true,"path":"2020/07/24/leetcode-solution-4/","link":"","permalink":"http://believebest35.github.io/2020/07/24/leetcode-solution-4/","excerpt":"","text":"Leetcode 1025 除数博弈leetcode 1025 题目描述爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。 最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作： 选出任一 x，满足 0 &lt; x &lt; N 且 N % x == 0 。 用 N - x 替换黑板上的数字 N 。如果玩家无法执行这些操作，就会输掉游戏。 只有在爱丽丝在游戏中取得胜利时才返回 True，否则返回 false。假设两个玩家都以最佳状态参与游戏。 示例输入：2输出：true解释：爱丽丝选择 1，鲍勃无法进行操作。 输入：3输出：false解释：爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。 方法一：动态规划如果不想动脑就无脑动态规划。。。设dp[i]表示数字为i时先手是否必赢。数字为i时的必胜是从先前某一必败态所转移来的，因此转移方程可以写为：dp[i] = true if dp[i - j] = false exists (j为i因子)or dp[i] = false 1234567891011121314151617class Solution&#123;public: bool divisorGame(int N) &#123; vector&lt;bool&gt; dp(N + 1, false); dp[1] = false, dp[2] = true; for (int i = 3; i &lt;= N; i++) for (int j = 1; j &lt; i; j++) if (i % j == 0 &amp;&amp; !dp[i - j]) &#123; dp[i] = true; break; &#125; return dp[N]; &#125;&#125;; 方法二：数学规律额，直接才想N能不能被2整除，能整除就返回true，否则false。证明可用数学归纳法。 12345678class Solution&#123;public: bool divisorGame(int N) &#123; return N % 2 == 0； &#125;&#125;;","categories":[],"tags":[{"name":"leetcode_solution","slug":"leetcode-solution","permalink":"http://believebest35.github.io/tags/leetcode-solution/"}]},{"title":"leetcode 287 寻找重复数","slug":"leetcode-solution-3","date":"2020-07-23T07:10:49.000Z","updated":"2020-07-24T07:53:54.624Z","comments":true,"path":"2020/07/23/leetcode-solution-3/","link":"","permalink":"http://believebest35.github.io/2020/07/23/leetcode-solution-3/","excerpt":"","text":"Leetcode 287 寻找重复数leetcode 287 题目描述给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。 示例输入: [1,3,4,2,2]输出: 2 输入: [3,1,3,4,2]输出: 3 说明 不能更改原数组（假设数组是只读的）。 只能使用额外的 O(1) 的空间。 时间复杂度小于 O(n^2) 。 数组中只有一个重复的数字，但它可能不止重复出现一次。 解法这道题如果没有说明里的条件的话是非常容易的，可以排序，或者哈希，但是排序修改了原数组，哈希需要O(n)的空间。另外如果没有第一个条件的话可以考虑使用原地哈希。 以上的方法不能使用，因此实际做的时候用的是二分，不过不是对下标进行二分，而是对值域进行二分。最开始范围取到1～n，mid = (1 + n) / 2，每次分别统计小于mid，等于mid以及大于mid的个数，据此缩小空间。 123456789101112131415161718192021222324252627282930class Solution&#123;public: int findDuplicate(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size() - 1; int i = 1, j = n; while (i &lt; j) &#123; int less_k = 0; int large_k = 0; int count_k = 0; int mid = i + (j - i) / 2; for (auto num : nums) if (num == mid) count_k++; else if (num &lt; mid) less_k++; else large_k++; if (count_k &gt;= 2) return mid; if (less_k &gt; mid - 1) j = mid - 1; else i = mid + 1; &#125; return i; // 题目数据保证，不会在这退出。。。 &#125;&#125;;","categories":[],"tags":[{"name":"leetcode_solution","slug":"leetcode-solution","permalink":"http://believebest35.github.io/tags/leetcode-solution/"}]},{"title":"STL常用容器","slug":"stl常用容器","date":"2020-07-23T03:21:30.000Z","updated":"2020-07-23T03:35:45.263Z","comments":true,"path":"2020/07/23/stl常用容器/","link":"","permalink":"http://believebest35.github.io/2020/07/23/stl%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8/","excerpt":"","text":"这里记录了一些用c++刷leetcode时可能会用到的stl容器用法 原出处，作者wangdh vector边长数组，倍增思想 系统为某一个程序分配空间时，所需时间和空间大小无关，与申请次数有关。 所以变长数组尽可能减少申请次数。一开始申请一定空间的大小，当超过容量时，申请长度变为二倍的空间，然后将原始空间的元素copy过来。 当初始化的时候不指定空间大小，但是使用的空间有非常大之后需要多次扩容，那么扩容需要的时间复杂度是O(N) 相当于插入一个元素就需要将O(1)的时间。申请空间的次数是O(log n)。 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;int main()&#123; vector&lt;int&gt; a; // 定义一个vecotr vector&lt;int&gt; a(10); // 初始长度为10； vector&lt;int&gt; a(10, 3); // 初始长度为10， 且每个元素初始化为3 for(auto i : a) cout &lt;&lt; i &lt;&lt; \" \"; // 遍历元素的方式 ， auto 关键字，系统自动推断变量类型，变量名比较长的时候可以使用 vector&lt;int&gt; a[10]; // 定义了vector数组，每个元素都是一个vector&lt;int&gt; a.size(); // 返回列表里的元素的个数 a.empty(); // 返回列表是不是空 // size() 和empty() 是所有容器都有的，时间复杂度是o(1) a.clear(); // 清空，不是所有的容器都有 a.front(); // 返回第一个元素 a.back(); // 返回最后一个元素 a.push_back(); // 从最后插入一个元素 a.pop_back(); // 删除最后一个元素 a.begin(); a.end(); // 迭代器。 可以看做指针，可以解引用 a[2]; // 支持随机寻址，与数组相同 // 三种遍历方式 for(int i = 0; i &lt; a.size(); i ++) cout &lt;&lt; a[i] &lt;&lt; \" \"; cout &lt;&lt; endl; for(vector&lt;int&gt;::iterator i = a.begin(); i != a.end(); i ++) cout &lt;&lt; *i &lt;&lt; \" \"; for(auto i = a.begin(); i != a.end(); i ++) cout &lt;&lt; *i &lt;&lt; \" \"; // 迭代器，解引用 cout &lt;&lt; endl; for(auto x : a) cout &lt;&lt; x &lt;&lt; \" \"; // auto关键字自动推断类型 cout &lt;&lt; endl; // vector支持比较，按位进行字典序比较 vector&lt;int&gt; a(4, 3), b(3, 4); cout &lt;&lt; (a &lt; b); return 0;&#125; pair元组类型，相当于Python中的(). 当一个元素有多个属性的时候，可以使用pair来进行存储。当需要按照某个属性来排序的时候，就非常好。 比如合并区间的问题。每个区间有开始和结尾两个属性，然后需要按照区间的开始对区间进行排序。 可以看做实现了一个结构体，且实现了比较器。 12345678910111213141516171819202122232425262728293031// 两种初始化方法pair&lt;int, string&gt; p;p = make_pair(10, \"aa\");p = &#123;q, \"ab\"&#125;;// 支出比较运算，first为第一关键字，second为第二关键字pair&lt;int, string&gt; p = &#123;1, \"aa\"&#125;;pair&lt;int, string&gt; q = &#123;1, \"ab\"&#125;;// first取出第一个字， second取出第二个字cout &lt;&lt; p.first &lt;&lt; endl;cout &lt;&lt; p.second &lt;&lt; endl;cout &lt;&lt; (p &lt; q) &lt;&lt; endl;// 也可以使用pair存储三个属性等; pair 嵌套pairpair&lt;int, pair&lt;int, int&gt;&gt; p;string字符串，substr(), c_str()string s = \"a\"; s += \"ab\"; // 支持增量操作s += 'a';cout &lt;&lt; s &lt;&lt; endl;cout &lt;&lt; s.substr(1, 2) &lt;&lt; endl; // 可以取出某个子串，第一个是起始index，第二个是长度。第二个缺省或者超过范围则返回之后的左右字符串cout &lt;&lt; s.substr(1) &lt;&lt; endl;cout &lt;&lt; s.substr(1, 100) &lt;&lt; endl;printf(\"%s\\n\", s.c_str()); // 使用printf输出的时候，需要找到存储字符串数组的起始地址。c_str()可以返回size() | length() // 返回字符串的长度 s.find('a'); // 返回a在s中的位置,如果没找到，返回一个特别的标志c++中用npos表示(可以用s.npos)来表示 queue队列，push(), front() , pop(),back() 1234567// push() 向队尾插入一个元素// front() 返回队头元素// pop() 返回队尾元素// back() 弹出队头元素// size() // empty()// 没有clear操作 priority_queue优先队列，push(), top(), pop() 123456789101112131415161718192021222324// 内部使用堆维护// 默认是大顶堆，和python相反// 使用小顶对方法// 1. 在插入的时候插入元素的相反数即可// 2. 如下定义#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;iostream&gt;#include&lt;csting&gt;#include&lt;queue&gt;using namespace std;priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; heap;// priority_queue&lt;int&gt; q; // 大顶堆priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q; // 小顶堆q.push(1);q.push(2);q.push(5);q.push(10);while(!q.empty())&#123; cout &lt;&lt; q.top() &lt;&lt; endl; q.pop();&#125; stack栈， push(), top(), pop() 123456#include&lt;stack&gt;// size()// empty()// push() 栈顶加入一个元素// top() 范湖栈顶元素// pop() 弹出栈顶元素 deque双端队列，队头队尾都可以插入删除元素，也可以随机访问，加强版vector。 deque非常厉害，几乎支持其他容器所有的操作，但是速度对应的也比较慢。 12345678910111213#include&lt;deque&gt;size()empty()clear() // 支持清空操作front() // 可以访问头部或尾部元素back()// 能够从头或者尾部插入或删除元素push_back()pop_back()push_front()pop_front()[] // 支持索引操作 set, map multiset, multimap基于平衡二叉树(红黑树), 动态维护有序序列 1234567891011121314151617181920212223242526size();empty();clear();begin()/end(); ++ , -- 迭代器支持自增自减 返回前驱后继 时间复杂度也是log nset/ multiset// multiset可以存储多个相同的元素insert(); // 插入一个元素 log(n)find(x); // 查找一个元素count(x); // 返回某个数的个数erase(); // 输入一个数x，则删除所有x O(k + log n) k是元素个数 输入一个迭代器，则删除这个迭代器lower_bound()/ upper_bound(); // lower_bound(x) 返回大于等于x的最小的数的迭代器 upper_bound(x) 返回大于x的最小的数的迭代器map/ multimap; // 将两个元素做映射， multi_map支持一个key对应多个valueinsert(); // 插入的是一个pairerase(); // 输入的参数是一个pair或者迭代器find(); // []; // 支持索引操作 时间复杂度O(log n)#include&lt;map&gt;map&lt;string, int&gt; a;a[\"wdh\"] = 1;cout &lt;&lt; a[\"wdh\"] &lt;&lt; endl; unordered_set, unordered_map, unordered_multiset, unordered_multimap使用哈希表进行存储 操作和上面的相同，时间复杂度都是O(1)。内部无续，不支持lower_bound, upper_bound。不支迭代器的++ – bitset压位， 进行位运算，如状压DP的对状态的各种位操作。 比如如果开大小为1024的bool数组，那么需要使用1KB内存。 但是如果使用压位，那么只需要使用125B内存。 要开10000 * 10000的bool数组，那么需要大概100MB内存，但是内存限制是64MB， 这个时候使用压位就可以只用 12MB内存。 12345678910111213bitset&lt;10000&gt; s; // 一万位~ &amp; | ^; // 按位逻辑操作&gt;&gt; &lt;&lt; ; // 移位操作==, != ; // 比较操作[]; // 取出某一位count(); // 返回有多少个1any(); // 判断是否至少有一个1none(); // 判断是否全为零set(); // 把所有位置为1set(k, v); // 将第k位变成vreset(); // 将所有位变成零flip(); // 将所有位取反，等价于~flip(k); // 将第k位取反 algorithm实现了一些常用算法 1234567891011121314vector&lt;int&gt; a;sort(a.begin(), a.end()); // 对a进行快速排序reverse(a.begin(), a.end()); // 翻转一个vectorunique(a.begin(), a.end()); // 返回去重之后的尾迭代器(指针), 前闭后开，返回的是去重之后末尾元素的下一个位置int m =unique(a.begin(), a.end()) - a.begin(); // 计算去重之后的元素个数mrandom_shuffle(a.begin(), a.end()); // 随机打乱顺序next_permutation(); // 将两个迭代器(指针)指定的部分看做一个排列，求出这些元素构成的全排列中，字典序排在写一个的全排列。并直接在序列上更新。若不存在，则返回false，否则返回true。同理有prev_permutation函数// 输出1 - n的 n！中全排列int q[3] = &#123;1, 2, 3&#125;;do&#123; for(int i = 0; i &lt; 3; i ++) cout &lt;&lt; q[i] &lt;&lt; \" \"; cout &lt;&lt; endl;&#125;while(next_permutation(q, q+3));","categories":[],"tags":[{"name":"STL常用容器","slug":"STL常用容器","permalink":"http://believebest35.github.io/tags/STL%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8/"}]},{"title":"leetcode 279 完全平方数","slug":"leetcode-solution-2","date":"2020-07-22T14:39:07.000Z","updated":"2020-07-23T07:10:09.209Z","comments":true,"path":"2020/07/22/leetcode-solution-2/","link":"","permalink":"http://believebest35.github.io/2020/07/22/leetcode-solution-2/","excerpt":"","text":"Leetcode 279 完全平方数leetcode 279 题目描述给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。 示例输入: n = 12输出: 3解释: 12 = 4 + 4 + 4. 输入: n = 13输出: 2解释: 13 = 4 + 9. 方法一：暴力拿到题目后想都没想Orz，直接dfs暴力搜索，果然T了。。。TAT 123456789101112131415161718192021222324252627class Solution&#123;public: int ans; void dfs(int left, int base, int count) &#123; if (left &lt; 0) return; if (left == 0) &#123; ans = min(ans, count); return; &#125; for (int i = base; i &gt;= 1; i--) dfs(left - i * i, i, count + 1); &#125; int numSquares(int n) &#123; ans = n; dfs(n, pow(n, 1.0 / 2.0), 0); return ans; &#125;&#125;; 方法二：动态规划设dp[i]表示和为i的最小平方数的个数，转移方程为：dp[i] = min(dp[i], dp[i - j * j] + 1); 123456789101112131415class Solution&#123;public: int numSquares(int n) &#123; vector&lt;int&gt; dp(n + 1, 0); for (int i = 1; i &lt;= n; i++) &#123; dp[i] = i; for (int j = 1; i - j * j &gt;= 0; j++) dp[i] = min(dp[i], dp[i - j * j] + 1); &#125; return dp[n]; &#125;&#125;;","categories":[],"tags":[{"name":"leetcode_solution","slug":"leetcode-solution","permalink":"http://believebest35.github.io/tags/leetcode-solution/"}]},{"title":"leetcode 剑指offer 11 旋转数组的最小数字","slug":"leetcode-solution-1","date":"2020-07-22T13:10:05.000Z","updated":"2020-07-25T08:32:51.200Z","comments":true,"path":"2020/07/22/leetcode-solution-1/","link":"","permalink":"http://believebest35.github.io/2020/07/22/leetcode-solution-1/","excerpt":"","text":"Leetcode 剑指offer 11 旋转数组的最小数字剑指offer 11 on leetcode 题目描述把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。 示例输入：[3,4,5,1,2]输出：1 输入：[2,2,2,0,1]输出：0 方法一：暴力暴力的方法相对很直观，比较容易想到。但这道题没有说明搬运元素的个数，因此需要特判一下\b是否没有搬运，即比较数组头和数组尾元素大小即可。若nums[0] &lt; nums[n - 1]则说明没有搬运，直接返回第一个元素即可。 若搬运了元素，进行一次遍历即可，返回满足nums[i] &lt; nums[i - 1]的元素即可。 1234567891011121314151617181920class Solution&#123;public: int minArray(vector&lt;int&gt;&amp; numbers) &#123; int n = numbers.size(); if (n == 0) return 0; if (n == 1) return numbers[0]; if (n == 2) return min(numbers[0], numbers[1]); if (numbers[0] &lt; numbers[n - 1]) return numbers[0]; for (int i = 1; i &lt; n; i++) if (numbers[i] &lt; numbers[i - 1]) return numbers[i]; return numbers[n - 1]; &#125;&#125;; 显然时间复杂度为O(n)。 方法二：二分查找暴力的时间复杂度过高，通过二分查找可以将平均时间复杂度降至O(logn)。假定左端元素下标为i，右端元素下标为j，每次二分后得到mid元素可能以下存在三种情况 nums[mid] &lt; nums[j] 说明被找元素位于i和mid之间，因此将j修改为mid nums[mid] &gt; nums[j] 说明被找元素位于j和mid之间，因此将i修改为mid + 1 nums[mid] == nums[j] 由于存在重复元素，因此不能轻易修改i、j，由于mid和j处元素相同，因此不论nums[j]是否为最小元素， j左边应该存在一个“替代品”。。。因此将j–即可。 12345678910111213141516171819202122232425262728class Solution&#123;public: int minArray(vector&lt;int&gt;&amp; numbers) &#123; int n = numbers.size(); if (n == 0) return 0; if (n == 1) return numbers[0]; if (n == 2) return min(numbers[0], numbers[1]); if (numbers[0] &lt; numbers[n - 1]) return numbers[0]; int i = 0, j = n - 1; while (i &lt; j) &#123; int mid = i + (j - i) / 2; if (numbers[mid] &lt; numbers[j]) j = mid; else if (numbers[mid] &gt; numbers[j]) i = mid + 1; else j--; &#125; return numbers[i]; &#125;&#125;; 平均时间复杂度为O(logn)。 这似乎是我开始写的第一篇blog，希望我以后能够将写博客的习惯坚持下去吧，最近发现自己实在是太菜了Orz，无论是科研还是代码能力都菜得抠脚Orz。。。TAT 为此我也希望自己开始改变吧，以后无论是刷leetcode，还是读论文等等，与技术相关的东西我渐渐都会放在这里，希望自己在这两年卷的飞起的环境里还能找到一个还算行的工作吧。。。Orz 这里可能也会放一些吐槽吧。。。","categories":[],"tags":[{"name":"leetcode_solution","slug":"leetcode-solution","permalink":"http://believebest35.github.io/tags/leetcode-solution/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-07-19T15:31:33.751Z","updated":"2020-07-19T15:31:33.751Z","comments":true,"path":"2020/07/19/hello-world/","link":"","permalink":"http://believebest35.github.io/2020/07/19/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"OOP","slug":"OOP","permalink":"http://believebest35.github.io/tags/OOP/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://believebest35.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode_solution","slug":"leetcode-solution","permalink":"http://believebest35.github.io/tags/leetcode-solution/"},{"name":"STL常用容器","slug":"STL常用容器","permalink":"http://believebest35.github.io/tags/STL%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8/"}]}