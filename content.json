{"meta":{"title":"Xinrui Tang","subtitle":"","description":"这里是我写一些无聊的东西的地方","author":"Xinrui Tang","url":"http://believebest35.github.io","root":"/"},"pages":[{"title":"about me","date":"2020-07-22T11:26:47.000Z","updated":"2020-07-22T12:20:53.959Z","comments":false,"path":"about/index.html","permalink":"http://believebest35.github.io/about/index.html","excerpt":"","text":"Hello, this is Xinrui Tang’s blog by hexo."},{"title":"","date":"2020-07-22T11:24:27.000Z","updated":"2020-07-22T12:12:41.598Z","comments":false,"path":"categories/index.html","permalink":"http://believebest35.github.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2020-10-13T11:42:13.000Z","updated":"2020-10-13T11:42:13.660Z","comments":true,"path":"about/index-1.html","permalink":"http://believebest35.github.io/about/index-1.html","excerpt":"","text":""},{"title":"tags","date":"2020-10-13T11:38:43.000Z","updated":"2020-10-13T11:38:43.060Z","comments":true,"path":"tags/index-1.html","permalink":"http://believebest35.github.io/tags/index-1.html","excerpt":"","text":""},{"title":"","date":"2020-07-22T11:26:00.000Z","updated":"2020-07-22T12:12:13.920Z","comments":false,"path":"tags/index.html","permalink":"http://believebest35.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"effective_c++ 章节4","slug":"effective-c-4","date":"2020-12-16T08:15:09.000Z","updated":"2020-12-16T13:40:48.597Z","comments":true,"path":"2020/12/16/effective-c-4/","link":"","permalink":"http://believebest35.github.io/2020/12/16/effective-c-4/","excerpt":"第四章主题：设计与声明。","text":"第四章主题：设计与声明。 让接口容易被正确使用，不容易被错误使用。 Make interfaces easy to use correctly and hard to use incorrectly. 这一条讲的比较宽泛，大概意思就是你设计的接口要让客户使用起来方便。 设计class犹如设计type。 Treat class design as type design. 原书中讨论了关于设计一个class需要关注的方方面面，具体总结可见这个博客，简单来说，设计一个完备的类是一个十分复杂的事情。 以pass-by-reference-const替换pass-by-value。 Prefer pass-by-reference-to-const to pass-by-value. 传递对象时最好传引用，值传递的方式涉及到新对象的创建和析构，其效率很低。 另外使用引用传递可以避免对象切片，若某个函数的参数为基类对象（不是基类指针和基类引用类型），若传入了一个派生类对象，则在该函数的调用过程中，该派生类对象只会保留父类的成员（因为会调用基类的拷贝构造函数），派生类的成员均会丢失，使用引用或者指针的形式则可以避免对象切片的发生（实质上是避免了拷贝构造函数的调用，也提高了程序运行效率）。 当然对于C++的内置类型，可以选择使用值传递，因为其复制开销很小。 不要返回临时对象的引用。 Don’t try to return a reference when you must return an object. 返回临时对象的引用容易出现未定义的行为。 也不要返回堆区上对象的引用，new和delete一般都是成对出现，返回堆区对象的引用容易导致出现内存泄漏。 此外也不能返回静态区（static）对象的引用，静态区对象一般被多个线程共享，容易出现线程安全的问题。 将成员变量声明为private。 Declare data members private. 将成员变量声明为private可以提高封装性。 宁以non-member、non-friend函数替换member函数。 Prefer non-member non-friend functions to member functions. 仁者见仁，智者见智，关于这个观点，在以后的实践中摸索。 若所有参数皆需类型转换，那么请采用non-member函数。 Declare non-member functions when type conversions should apply to all parameters. 文中举了一个有理数Rational运算的例子，在类中加入一个operator*(const Rational&amp; other)的函数，可以实现类似rational * 2的操作，其中2是个int，但是因为rational有一个以int为参数的构造，因此编译器帮你执行了隐式类型转换。但是反过来写2 * rational的时候，编译就报错了。因为2是个int，并没有operator*这个函数。但是为什么这样写就没有执行隐式类型转换呢？这又引出一个问题：隐式类型转换的合格条件是什么？答案是：必须是参数列中的参数才是隐式类型转换的有效参与者，类的执行者也就是’.’前面的那个对象（this指向的对象，比如说rational.func()中的rational是类执行者，相当于他是函数的调用人，地位较高，不能参与隐式类型转换），这就解释了为什么2放在前面是不行的。解决此种问题的方法是提供一个non-mem的operator*(Rational a, Rational b)即可。 考虑写出一个不抛出异常的swap函数 Consider support for a non-throwing swap. 一般写swap最普通的方法就是利用中间变量，temp = a, a = b, b = temp，这种方法对于内置类型没任何问题，内置类型上的赋值绝对不会抛出异常，并且效率很高。但是如果a,b不是内置类型，就会调用类的copy构造函数和assign函数，并且必须是深拷贝。这样如果类的成员较多就会造成交换的效率很低，特别是针对pimpl实现方法，即成员中包含指针（即资源）时。更好的做法就是直接交换指针就可以了，相当于交换了两个int(指针都是4字节的)，这就比拷贝这个指针指向的资源要快得多。 如何实现呢？只要将swap都转换成内置类型的swap就可以了，做法就是在类中提供一个public的swap(T&amp; b)函数（T为一个类），将每个成员进行交换（如果成员中包含其他非内置对象，调用这个对象的swap函数即可）。然后提供一个non-member的swap(T&amp; a, T&amp; b)重载函数，在函数内部调用类中的a.swap(b)，就可以像如下方式实现交换两个对象的操作：swap(a, b)。 需要注意的是在类内的swap交换内置类型时要调用std命名空间内的swap函数，必须使用using std::swap，否则就变成递归函数了。","categories":[],"tags":[{"name":"c++","slug":"c","permalink":"http://believebest35.github.io/tags/c/"}]},{"title":"effective_c++ 章节3","slug":"effective-c-3","date":"2020-12-16T06:58:49.000Z","updated":"2020-12-16T08:00:32.746Z","comments":true,"path":"2020/12/16/effective-c-3/","link":"","permalink":"http://believebest35.github.io/2020/12/16/effective-c-3/","excerpt":"第三章中涉及到C++中的资源管理。不同于Java等其他语言，C++中可以自行管理内存，因此容易出现内存泄漏的情况，正确的进行资源管理是十分重要的。","text":"第三章中涉及到C++中的资源管理。不同于Java等其他语言，C++中可以自行管理内存，因此容易出现内存泄漏的情况，正确的进行资源管理是十分重要的。 以对象管理资源 Use objects to manage resources. 获得了资源后需要立刻放进资源管理对象，通过对资源管理对象的析构来释放资源。即不要自行手动释放资源，将任何资源的释放放在析构函数中进行。 常见的自动管理资源的类是所谓的“智能指针”，关于智能指针需要单独学习。 在资源管理类中小心copy行为 Think carefully about copying behavior in resource-managing classes. RAII（Resource Acquisition Is Initialization）观念表示获得资源即是初始化，即资源在构造期间获得，在析构期间释放。 这里的问题在于如果需要自行实现类似智能指针的资源管理类，需要格外小心对于资源管理对象的复制行为，具体参看博客。 在资源管理类中提供对原始资源的访问。 Provide access to raw resources in resource-managing classes. 例如智能指针这样的资源管理类相当于在原始的资源上加了一层包装，但一些函数参数仅仅接收原始类型的指针或者引用，因此需要资源管理类提供对应的接口返回原始资源。例如智能指针的get方法。 成对使用new和delete需要采取相同的形式。 Use the same form in corresponding uses of new and delete. 使用new申请的，用delete释放，使用new[]申请的，用delete[]释放。 以单独的语句将newed对象置入shared_ptr。 Store newed objects in smart pointers in standalone statements. 不要写下这样的代码： 1234Function(shared_ptr&lt;Class&gt;(new Class), x())&#123; // ...&#125; 原因在于shared_ptr的构造分为两步，第一步是new Class创建一个对象，第二部是执行构造函数，但是像上面那样写可能导致x()在两步之间运行（与编译器如何编译代码有关了），如果这个时候x()发生了异常，那么就会导致内存泄漏。因此初始化shared_ptr的时候，最好不要掺杂其他东西。","categories":[],"tags":[{"name":"c++","slug":"c","permalink":"http://believebest35.github.io/tags/c/"}]},{"title":"effective_c++ 章节2","slug":"effective-c-2","date":"2020-12-16T02:18:51.000Z","updated":"2020-12-16T03:39:03.856Z","comments":true,"path":"2020/12/16/effective-c-2/","link":"","permalink":"http://believebest35.github.io/2020/12/16/effective-c-2/","excerpt":"第二章涉及对象的构造、析构以及赋值。","text":"第二章涉及对象的构造、析构以及赋值。 确保了解C++编译器会自动生成什么函数 Know what functions C++ silently writes and calls. 在定义类时，若没有显式指定构造函数、拷贝构造函数、析构函数以及对赋值操作符“=”的重载，则编译器会自动合成这些函数。 需要注意的是自动合成的拷贝构造函数是浅拷贝的，即并不会开辟新的内存空间。 1234567891011121314151617class Empty &#123;&#125;;// 等价于class Empty &#123;public: Empty() &#123; ... &#125; Empty(const Empty&amp; rhs) &#123; ... &#125; ~Empty( ) &#123; ... &#125; Empty&amp; operator=(const Empty&amp; rhs) &#123; ... &#125;&#125;Empty e1;Empty e2(e2); // copy构造函数e2 = e1; // 赋值运算 假如自己指定了构造函数（不管带不带参），则编译器不会自动生成构造函数。 不想使用默认生成的函数，可以明确拒绝 Explicitly disallow the use of compiler-generated functions you do not want. 例如想要禁止显式调用默认构造函数，可以将显式指定它，并设置为private。C++11的新特性可以使用delete关键字显式删除这一类构造函数。 123456789101112131415class Test&#123;private: int a; Test() &#123;&#125;;&#125;;// or C++11class Test&#123;private: int a;public: Test() &#123;&#125; = delete;&#125; 总结：默认的构造可以被其他构造替换，拷贝构造和赋值函数如果不想被外面调用可以将其声明为private。 为多态基类声明virtual析构函数 Declare destructors virtual in polymorphic base classes. C++中的多态机制一部分是靠基类对象指针和引用才能进行的，在释放他们所指向的对象所占用的资源时，倘若基类的析构函数没有设置为虚函数，则在释放资源时只会释放父类成员所占用的资源，子类的成员并不会释放，这样会造成资源的泄漏。 如果一个类并不被继承，则没有必要声明虚析构函数。 别让异常逃离虚构函数 Prevent exceptions from leaving destructors. 一篇博客的解释 总而言之，让客户端去解决异常，不要尝试在析构函数里解决异常。 不要在构造和析构函数调用virtual函数 Never call virtual functions during construction or destruction. 派生类构造函数通常都是先初始化父类成员，在初始化派生类成员，若调用虚函数，很可能会涉及到未初始化的派生类成员，导致未定义的行为，因此不能再构造函数中调用虚函数。 析构函数同理，子类先被析构，若调用虚函数，子类成员已经被释放，也会出现不可预期的行为。 令operator=返回一个reference to *this Have assignment operators return a reference to *this. 重载“=”时返回引用比返回值的效率高，因为少了多次对临时变量的构造和析构。 在operator=中处理自我赋值 Handle assignment to self in operator=. 通常出现于指针、引用，即指向了同一个对象，导致自我赋值，因此需要在赋值之前判断是否为同一个对象。 复制对象的时候勿忘其每个部分 Copy all parts of an object.","categories":[],"tags":[{"name":"c++","slug":"c","permalink":"http://believebest35.github.io/tags/c/"}]},{"title":"effective_c++ 章节1","slug":"effective-c-1","date":"2020-12-15T14:34:24.000Z","updated":"2020-12-16T06:59:30.504Z","comments":true,"path":"2020/12/15/effective-c-1/","link":"","permalink":"http://believebest35.github.io/2020/12/15/effective-c-1/","excerpt":"自己对于C++的了解十分肤浅，因此有必要学习一下Effective C++这本书，虽然这本书似乎没有描述C++11的新特性，但是还是值得一读的 C++是一种语言集合。 View c++ as a federation of languages.","text":"自己对于C++的了解十分肤浅，因此有必要学习一下Effective C++这本书，虽然这本书似乎没有描述C++11的新特性，但是还是值得一读的 C++是一种语言集合。 View c++ as a federation of languages. C++对于我绝大多数时候都只是C with STL或者C with Classes，其模板、泛型编程特性极少接触到，而C++是一个具有多种语言特性的语言集合，包括： C C++本质上还是C语言的超集。 Object-Oriented C++ C++是面向对象的语言。 Template C++ 泛型 STL C++提供的一堆模板程序库。 尽量以const，enum，inline 替换 #define Prefer consts,enums, and inlines to #defines. 尽量少使用宏定义。 原文关于#define的缺陷有很多讨论，一个最经典的例子 123456#define square(x) x * xint main()&#123; cout &lt;&lt; square(2 + 1) &lt;&lt; endl;&#125; 以上的代码在经过预处理之后会变成 2 + 1 * 2 + 1，出现极其危险的错误，因此尝试用内联函数来替代。 尽可能使用const Use const whenever possible. const表示常量，但是经常和指针混在一起，导致不好辨别其语义。 一个简单的辨别方法： const在星号左边表示被指物是常量，const在星号右边表示指针自身是常量，同时出现在两边表示被指物和指针都是常量。 确保对象使用前已经被初始化 Make sure that objects are initialized before they’re used. 主要来自于c语言的历史遗留。","categories":[],"tags":[{"name":"c++","slug":"c","permalink":"http://believebest35.github.io/tags/c/"}]},{"title":"Java集合类型","slug":"Java-5","date":"2020-12-07T13:35:24.000Z","updated":"2020-12-07T14:57:59.686Z","comments":true,"path":"2020/12/07/Java-5/","link":"","permalink":"http://believebest35.github.io/2020/12/07/Java-5/","excerpt":"ListJava中定义了List接口，ArrayList是一种具体实现。","text":"ListJava中定义了List接口，ArrayList是一种具体实现。 12345678910111213141516171819// import java.util.List;// import java.util.ArrayList;List&lt;String&gt; list = new ArrayList&lt;&gt;(); // 声明List 多态性质list.add(\"apple\");list.add(\"pear\");list.add(\"bear\");for (int i = 0; i &lt; list.size(); i++) &#123; // 下标遍历 System.out.println(list.get(i));&#125;for (String s : list) &#123; // for each遍历 System.out.println(s);&#125;for (var s : list) &#123; // for each遍历 System.out.println(s);&#125; List&lt;E&gt;接口，几个主要的接口方法： 在末尾添加一个元素：boolean add(E e) 在指定索引添加一个元素：boolean add(int index, E e) 删除指定索引的元素：int remove(int index) 删除某个元素：int remove(Object e) 获取指定索引的元素：E get(int index) 获取链表大小（包含元素的个数）：int size() 是否包含元素：boolean contains(Object o) 返回某个元素的索引（不包含时返回-1）：int indexOf(Object o) List包含的元素若为自定义类型，对于查找操作需要正确覆写equals方法。 MapMap类容器可存储映射关系，HashMap是一种具体实现。 1234567891011121314151617// import java.util.Map;// import java.util.HashMap;Map&lt;String, Integer&gt; m = new HashMap&lt;&gt;(); // 声明Mapm.put(\"Tom\", 100); // 放入键值对System.out.println(m.get(\"Tom\")); // 根据键获取值System.out.println(m.get(\"Bob\")); // 键不存在返回nullfor (var key : m.keySet()) &#123; // HashMap键遍历，无序 System.out.println(key + \" \" + m.get(key));&#125;for (var entry : m.entrySet()) &#123; // 键值对遍历 String key = entry.getKey(); int value = entry.getValue(); System.out.println(key + \" \" + value);&#125; 若采用自定义类型作为键，则该类型需要正确覆写equals方法和hasCode方法。 HashMap使用链地址法（就是数组链表，两个关键字算哈希出现冲突则都放到一个List里，通过遍历List查找关键字）解决地址冲突。具体参考这篇博客。 SetSet集合类型，常用实现HashSet。 1234567891011121314// import java.util.*;Set&lt;String&gt; set = new HashSet&lt;&gt;();System.out.println(set.add(\"abc\")); // trueSystem.out.println(set.add(\"xyz\")); // trueSystem.out.println(set.add(\"xyz\")); // false，添加失败，因为元素已存在System.out.println(set.contains(\"xyz\")); // true，元素存在System.out.println(set.contains(\"XYZ\")); // false，元素不存在System.out.println(set.remove(\"hello\")); // false，删除失败，因为元素不存在System.out.println(set.size()); // 2，一共两个元素for (String s : set) &#123; // 遍历 System.out.println(s);&#125; 放入Set的类型必须正确覆写equals方法。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://believebest35.github.io/tags/Java/"}]},{"title":"HTTP协议基础","slug":"http协议","date":"2020-12-03T12:23:55.000Z","updated":"2020-12-03T14:17:35.940Z","comments":true,"path":"2020/12/03/http协议/","link":"","permalink":"http://believebest35.github.io/2020/12/03/http%E5%8D%8F%E8%AE%AE/","excerpt":"一些文档 关于HTTP协议，一篇就够了 十分钟搞懂HTTP和HTTPS协议？ HTTP 协议入门 阮一峰 … HTTP协议即超文本传输协议，是基于TCP/IP协议的应用层协议，是用于从服务器传输超文本到本地浏览器。","text":"一些文档 关于HTTP协议，一篇就够了 十分钟搞懂HTTP和HTTPS协议？ HTTP 协议入门 阮一峰 … HTTP协议即超文本传输协议，是基于TCP/IP协议的应用层协议，是用于从服务器传输超文本到本地浏览器。 HTTP协议工作于客户端-服务端（C-S / B-S）架构之上（B表示Browser）。 一些特点 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST 灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接，但是这样不利于客户端与服务器保持会话连接，为了弥补这种不足，产生了两项记录http状态的技术，一个叫做Cookie,一个叫做Session。 无状态：无状态是指协议对于事务处理没有记忆，后续处理需要前面的信息，则必须重传 支持B-S和C-S模式 URI：统一资源标识符 URL：统一资源定位符 HTTP报文结构请求报文（Request）结构 请求行：包括请求方法、URL、协议/版本 请求头(Request Header) 空行：请求头和请求正文之间必须有空行 请求正文 响应报文（Response）结构 状态行：由HTTP协议版本号，状态码，状态消息三部分组成。 响应头：用来说明客户端要使用的一些附加信息 空行 响应正文：即HTML HTTP状态码状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别: 1xx：指示信息–表示请求已接收，继续处理 2xx：成功–表示请求已被成功接收、理解、接受 3xx：重定向–要完成请求必须进行更进一步的操作 4xx：客户端错误–请求有语法错误或请求无法实现 5xx：服务器端错误–服务器未能实现合法的请求 常见状态码： 1234567200 OK &#x2F;&#x2F;客户端请求成功400 Bad Request &#x2F;&#x2F;客户端请求有语法错误，不能被服务器所理解401 Unauthorized &#x2F;&#x2F;请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 403 Forbidden &#x2F;&#x2F;服务器收到请求，但是拒绝提供服务404 Not Found &#x2F;&#x2F;请求资源不存在，eg：输入了错误的URL500 Internal Server Error &#x2F;&#x2F;服务器发生不可预期的错误503 Server Unavailable &#x2F;&#x2F;服务器当前不能处理客户端的请求，一段时间后可能恢复正常 常见请求方法 GET:请求指定的页面信息，并返回实体主体。 POST:向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 HEAD:类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头 PUT:从客户端向服务器传送的数据取代指定的文档的内容。 DELETE:请求服务器删除指定的页面。 POST和GET的区别 都包含请求头请求行，post多了请求body。 get多用来查询，请求参数放在url中，不会对服务器上的内容产生作用。post用来提交，如把账号密码放入body中。 GET是直接添加到URL后面的，直接就可以在URL中看到内容，而POST是放在报文内部的，用户无法直接看到。 GET提交的数据长度是有限制的，因为URL长度有限制，具体的长度限制视浏览器而定。而POST没有。 HTTP工作原理HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。 以下是 HTTP 请求/响应的步骤： 客户端连接到Web服务器 一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，http://www.oakcms.cn。 发送HTTP请求 通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。 服务器接受请求并返回HTTP响应 Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。 释放连接TCP连接 若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求; 客户端浏览器解析HTML内容 客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。 例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程： 浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址; 解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接; 浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器; 服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器; 释放 TCP连接; 浏览器将该 html 文本并显示内容; HTTPS协议因为HTTP协议以明文传递信息，因此不适合传递敏感信息。 一般http中存在如下问题： 请求信息明文传输，容易被窃听截取。 数据的完整性未校验，容易被篡改 没有验证对方身份，存在冒充危险 HTTPS协议（HyperText Transfer Protocol over Secure Socket Layer）：一般理解为HTTP+SSL/TLS，通过 SSL证书来验证服务器的身份，并为浏览器和服务器之间的通信进行加密。 使用HTTPS传输数据的流程 首先客户端通过URL访问服务器建立SSL连接。 服务端收到客户端请求后，会将网站支持的证书信息（证书中包含公钥）传送一份给客户端。 客户端的服务器开始协商SSL连接的安全等级，也就是信息加密的等级。 客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。 服务器利用自己的私钥解密出会话密钥。 服务器利用会话密钥加密与客户端之间的通信。","categories":[],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://believebest35.github.io/tags/HTTP/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://believebest35.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"数据库事务及其隔离级别","slug":"数据库事务及其隔离级别","date":"2020-11-27T08:31:38.000Z","updated":"2020-11-27T09:43:27.928Z","comments":true,"path":"2020/11/27/数据库事务及其隔离级别/","link":"","permalink":"http://believebest35.github.io/2020/11/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%8F%8A%E5%85%B6%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/","excerpt":"数据库事务百度了一下，这篇博客写得很好，廖雪峰网站的关于数据库事务的讲解个人认为讲的不好。 数据库事务(transaction)是访问并可能操作各种数据项的一个数据库操作序列，这些操作要么全部执行,要么全部不执行，是一个不可分割的工作单位。","text":"数据库事务百度了一下，这篇博客写得很好，廖雪峰网站的关于数据库事务的讲解个人认为讲的不好。 数据库事务(transaction)是访问并可能操作各种数据项的一个数据库操作序列，这些操作要么全部执行,要么全部不执行，是一个不可分割的工作单位。 简单来说： 业务要求某些SQL语句必须作为一个整体全部执行，若执行不完则必须整体回滚，这样的SQL语句整体称为一个数据库事务。例如： 1234BEGIN;UPDATE accounts SET balance = balance - 100 WHERE id = 1;UPDATE accounts SET balance = balance + 100 WHERE id = 2;COMMIT; 使用BEGIN开启一个事务，COMMIT是指提交事务，即试图把事务内的所有SQL所做的修改永久保存。如果COMMIT语句执行失败了，整个事务也会失败。 数据库的四大特性（ACID） 原子性 Atomicity 原子性指数据库事务是执行SQL语句的最小单位，不可以再分割，即指事务包含的所有操作要么全部成功，要么全部失败回滚。 一致性 Consistency 一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。例如A给B汇款，A的存款少了多少，B的存款就会多多少。 隔离性 Isolation 数据库事务的操作是相互独立的，不能相互影响。即并发执行的数据库事务必须相互隔离。 持久性 Durability 数据库事务在执行之后产生的影响是永久的，即指事务的操作，一旦提交，对于数据库中数据的改变是永久性的。 数据库事务的隔离级别 读未提交 Read Uncommitted 读已提交 Read Committed 可重复读 Repeatable Read 串行化 Serializable 假设不存在任何隔离级别，若有多个线程同时读写数据库，会出现数据不一致的情况。 读未提交 Read Uncommitted写数据的时候添加一个X锁（排他锁），也就是在写数据的时候不允许其他事务进行写操作，但是读不受限制，读不加锁。这样可以解决多个线程同时写数据导致的数据丢失问题。但是会引起脏读。 个人理解就是在读未提交的等级下排他锁的释放时间没有放到事务提交时，也可以理解为在读未提交的等级下排他锁限制不了读操作。 脏读：若线程A的一个事务将某个数据从100修改为120，但没有提交，同时另一个线程B读到了数据为120，若线程A执行的事务回滚，数据被恢复为100，但是线程B读到的数据依旧为120，即出现了脏读。 读已提交 Read Uncommitted写数据的时候加上X锁（排他锁），读数据的时候添加S锁（共享锁），而且有约定：如果一个数据加了X锁就没法加S锁；同理如果加了S锁就没法加X锁，但是一个数据可以同时存在多个S锁（因为只是读数据），并且规定S锁读取数据，一旦读取完成就立刻释放S锁（不管后续是否还有很多其他的操作，只要是读取了S锁的数据后，就立刻释放S锁）。 个人理解就是排他锁是在事务结束进行释放，而共享锁是在读操作结束后立刻释放，不会等到事务的结束。 从字面理解“读已提交”就是在数据库事务A已经提交（或者回滚）之后，另一个事务B才能进行读操作，这样可以防止读到没有提交的数据，但是会引起不可重复读的问题。 不可重复读：假设存在数据项x为100，事务A对x加共享锁，读取完后释放排他锁（注意事务A没有提交），此时事务B改写数据项B为120并提交，事务A再次对x加共享锁，结果读取出x为120，导致前后读取不一致。 可重复读 Repeatable Read对S锁进行修改，之前的S锁是：读取了数据之后就立刻释放S锁，现在修改是：在读取数据的时候加上S锁，但是要直到事务准备提交了才释放该S锁，X锁还是一致。 即所有的锁都等到事务要提交了才释放。 但是会出现幻读的情况。 用一个例子解释幻读： 有一次旺财对一个“学生表”进行操作，选取了年龄是18岁的所有行， 用X锁锁住， 并且做了修改。 改完以后旺财再次选择所有年龄是18岁的行， 想做一个确认， 没想到有一行竟然没有修改！ 这是怎么回事？ 出了幻觉吗？ 原来就在旺财查询并修改的的时候， 小强也对学生表进行操作， 他插入了一个新的行，其中的年龄也是18岁！ 即幻读是另一个事务的插入操作引起的。 串行化 Serializable要解决幻读则必须所有事务都串行化执行，即所有事务都一件一件执行，不能并行化。 一些数据库支持的隔离级别mysql默认的隔离级别是：可重复读。 oracle中只支持2个隔离级别：读已提交和串行化，默认是读已提交。","categories":[],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://believebest35.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"CRUD_boy","slug":"CRUD-boy","date":"2020-11-19T06:53:44.000Z","updated":"2020-11-20T09:09:14.532Z","comments":true,"path":"2020/11/19/CRUD-boy/","link":"","permalink":"http://believebest35.github.io/2020/11/19/CRUD-boy/","excerpt":"我还不是一个合格的CRUD boy。","text":"我还不是一个合格的CRUD boy。 查询假设后续要使用的两张表模式为： students： id class_id name gender score 自增整型 整型 字符串 字符串 整型 classes： id name 自增整型 字符串 基本查询12select * from students;select * from classes; 查询students和classes所有的数据。 1select * from &lt;表名&gt; 条件查询1select * from students where score &gt; 80 and gender == 'F'; 查询分数在80以上的女同学。 1select * from &lt;表名&gt; where &lt;条件表达式&gt; 常用： 12345678910and 与or 或not 非&gt; 大于&lt; 小于&#x3D;&#x3D;, &#x3D; 等于!&#x3D;, &lt;&gt; 不等&gt;&#x3D; 大于等于&lt;&#x3D; 小于等于like 相似 name like &quot;ab%&quot; 投影查询选择某些列 1select class_id, name, gender from students; 重命名列 1select class_id c_id, name, gender from students; 查询结果对class_id重命名。 1select &lt;列名1&gt; [别名1], &lt;列名2&gt; [别名2], ... , &lt;列名n&gt; [别名n] from &lt;表名&gt; 同样可在最后加上where进行条件查询。 排序顺序排列 1select name, score from students order by score asc; 按照分数的递增顺序对结果进行排序，asc可以省略。 倒序排序 1select name, score from students order by score desc; 根据多行进行排列 1select name, score, gender from students order by score desc, gender; 根据分数进行倒序排序，再根据性别（字符串）进行顺序排序。 1234select ...from ...where ...order by ... 分页1select * from students limit 3 offset 3; 从第3个记录（offset，注意记录是从0开始编号的）开始，最多选择3条记录（limit）。 聚合查询count 1select count(*) from students; 使用count同时重命名 1select count(*) num from students; 函数 说明 SUM 计算某一列的合计值，该列必须为数值类型 AVG 计算某一列的平均值，该列必须为数值类型 MAX 计算某一列的最大值 MIN 计算某一列的最小值 分组统计 1select count(*) from students group by class_id; 按班级统计人数，以上看不出班级号，可以加入班级号进行统计 1select class_id, count(*) num from students group by class_id; 按多个分组进行统计： 1select class_id, gender, count(*) num from students group by class_id, gender; 多表查询1select * from students, classes; 会对两个表算笛卡尔积，没有实际意义。 取别名 1select s.class_id c_id, c.name class_name from students s, classes c; 连接查询内连接 1select ... from students s inner join classes c on s.class_id == c.id; INNER JOIN查询的写： 先确定主表，仍然使用FROM &lt;表1&gt;的语法； 再确定需要连接的表，使用INNER JOIN &lt;表2&gt;的语法； 然后确定连接条件，使用ON &lt;条件...&gt;，这里的条件是s.class_id = c.id，表示students表的class_id列与classes表的id列相同的行需要连接； 可选：加上WHERE子句、ORDER BY等子句。 另外存在 full outer join left outer join right outer join 增加1INSERT INTO &lt;表名&gt; (字段1, 字段2, ...) VALUES (值1, 值2, ...); 例如 1insert into students (class_id, name, gender, score) values (2, \"法外狂徒张三\", \"M\", 100); 可以一次添加多条记录 123insert into students (class_id, name, gender, score) values (2, \"法外狂徒张三\", \"M\", 100),(2, \"疾风剑豪亚索\", \"M\", 0); 修改1UPDATE &lt;表名&gt; SET 字段1=值1, 字段2=值2, ... WHERE ...; 不加where则全部记录都会被修改。 1update students set score = 100 where name == \"法外狂徒张三\"; 删除1DELETE FROM &lt;表名&gt; WHERE ...; 不加where则全部记录都会被删除。 1delete from students where name == \"法外狂徒张三\";","categories":[],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://believebest35.github.io/tags/SQL/"}]},{"title":"设计模式基础(Java描述)","slug":"design-pattern","date":"2020-11-10T11:43:44.000Z","updated":"2020-11-18T03:08:50.033Z","comments":true,"path":"2020/11/10/design-pattern/","link":"","permalink":"http://believebest35.github.io/2020/11/10/design-pattern/","excerpt":"一些关于设计模式的文章： 图说设计模式 廖雪峰Java设计模式教程 Java 23种设计模式全归纳 LeetBook 深入浅出设计模式 Java设计模式 …","text":"一些关于设计模式的文章： 图说设计模式 廖雪峰Java设计模式教程 Java 23种设计模式全归纳 LeetBook 深入浅出设计模式 Java设计模式 … 设计模式分类 创建型模式 结构型模式 行为型模式 六大设计原则 开闭原则：一个软件实体如类、模块和函数应该对修改封闭，对扩展开放。 单一职责原则：一个类只做一件事，一个类应该只有一个引起它修改的原因。 里氏替换原则：子类应该可以完全替换父类。也就是说在使用继承时，只扩展新功能，而不要破坏父类原有的功能。 依赖倒置原则：细节应该依赖于抽象，抽象不应依赖于细节。把抽象层放在程序设计的高层，并保持稳定，程序的细节变化由低层的实现层来完成。 迪米特法则：又名“最少知道原则”，一个类不应知道自己操作的类的细节，换言之，只和朋友谈话，不和朋友的朋友谈话。 接口隔离原则：客户端不应依赖它不需要的接口。如果一个接口在实现时，部分方法由于冗余被客户端空实现，则应该将接口拆分，让实现类只需依赖自己需要的接口方法。 创建型模式工厂模式 Factory一般创建新对象是使用构造函数直接new一个新对象出来，但这样把对象的构造过程暴露了出来，并且重载的构造函数的区别只能在体现在参数上，工厂模式便可以封装对象的构造过程。 简单工厂模式一个简单的栗子： 1234567891011121314151617181920212223242526272829303132333435363738394041public class Main &#123; public static void main(String[] args) throws Exception &#123; MaskFactory factory = new MaskFactory(); // 输出：这是医用口罩 System.out.println(factory.create(\"Surgfical\")); // 输出：这是 N95 口罩 System.out.println(factory.create(\"N95\")); &#125;&#125;abstract class Mask &#123;&#125;class SurgicalMask extends Mask &#123; @Override public String toString() &#123; return \"这是医用口罩\"; &#125;&#125;class N95Mask extends Mask &#123; @Override public String toString() &#123; return \"这是 N95 口罩\"; &#125;&#125;class MaskFactory &#123; public Mask create(String type)&#123; if (type.equals(\"Surgical\")) return new SurgicalMask(); else if (type.equals(\"N95\")) return new N95Mask(); else throw new IllegalArgumentException(\"Unsupported mask type\"); &#125;&#125; 即使用一个超级工厂类用来封装所有的对象构造细节，特别是当一个对象构造过程特别复杂时十分好用，这样使得调用者不需要关心对象的构造细节，只需要和工厂类进行交互。 其实可以将工厂类中方法统一改写为静态方法，这样就可以省去构造工厂类的一个实例。即 123456public static Mask create(String type) &#123; // ...&#125;Mask mask = MaskFactory.create(\"N95\");// ... 优点 隐藏构造过程，当构造过程出现变化时调用者也无需关心。 缺点 如果需要生产的产品过多，此模式会导致工厂类过于庞大，承担过多的职责，变成超级类。就是说这个类不止一个引起修改的原因，违背了单一职责原则。 当要生产新的产品时，必须在工厂类中添加新的分支。而开闭原则告诉我们：类应该对修改封闭。我们希望在添加新功能时，只需增加新的类，而不是修改既有的类，所以这就违背了开闭原则。 工厂方法模式为了避免工厂类过于庞大，可以给每一类产品单独设计一个工厂类。 123456789101112131415161718192021222324252627282930313233343536373839public class Main &#123; public static void main(String[] args) throws Exception &#123; // 输出：这是医用口罩 System.out.println(SurgicalMaskFactory.create()); // 输出：这是 N95 口罩 System.out.println(N95MaskFactory.create()); &#125;&#125;abstract class Mask &#123;&#125;class SurgicalMask extends Mask &#123; @Override public String toString() &#123; return \"这是医用口罩\"; &#125;&#125;class N95Mask extends Mask &#123; @Override public String toString() &#123; return \"这是 N95 口罩\"; &#125;&#125;class N95MaskFactory &#123; public static Mask create() &#123; // 设置为静态方法，无需new工厂实例 return new N95Mask(); &#125;&#125;class SurgicalMaskFactory &#123; public static Mask create() &#123; return new SurgicalMask(); &#125;&#125; 对于每个产品都设计工厂类虽然看上去并没有降低耦合度，甚至使得代码量增加了，但是工厂方法模式依旧封装了产品的具体构造细节。 两个优点 当生产的产品种类越来越多时，工厂类不会变成超级类。工厂类会越来越多，保持灵活。不会越来越大、变得臃肿。如果N95的生产过程需要修改时，只需修改N95工厂。外科口罩的生产过程需要修改时，只需修改外科口罩工厂。符合单一职责原则。 当需要生产新的产品时，无需更改既有的工厂，只需要添加新的工厂即可。保持了面向对象的可扩展性，符合开闭原则。 抽象工厂模式 Abstract factory以上的工厂方法可以提取出公共的工厂接口。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Main &#123; public static void main(String[] args) throws Exception &#123; IFactory factory_1 = new SurgicalMaskFactory(); IFactory factory_2 = new N95MaskFactory(); // 输出：这是医用口罩 System.out.println(factory_1.create()); // 输出：这是 N95 口罩 System.out.println(factory_2.create()); &#125;&#125;abstract class Mask &#123;&#125;class SurgicalMask extends Mask &#123; @Override public String toString() &#123; return \"这是医用口罩\"; &#125;&#125;class N95Mask extends Mask &#123; @Override public String toString() &#123; return \"这是 N95 口罩\"; &#125;&#125;interface IFactory &#123; // 抽象出的公共工厂接口 Mask create();&#125;class SurgicalMaskFactory implements IFactory&#123; @Override public Mask create() &#123; return new SurgicalMask(); &#125;&#125;class N95MaskFactory implements IFactory &#123; @Override public Mask create() &#123; return new N95Mask(); &#125;&#125; 抽象工厂模式在创建工厂实例时指定了具体的工厂类后，在使用时就无需再关心是哪个工厂类，只需要将此工厂当作抽象的 IFactory 接口使用即可。 由于客户端只和 IFactory 打交道了，调用的是接口中的方法，使用时根本不需要知道是在哪个具体工厂中实现的这些方法，这就使得替换工厂变得非常容易。 抽象工厂模式很好的发挥了开闭原则、依赖倒置原则，但缺点是抽象工厂模式太重了，如果 IFactory 接口需要新增功能，则会影响到所有的具体工厂类。使用抽象工厂模式，替换具体工厂时只需更改一行代码，但要新增抽象方法则需要修改所有的具体工厂类。所以抽象工厂模式适用于增加同类工厂这样的横向扩展需求，不适合新增功能这样的纵向扩展。 单例模式 Singleton单例模式保证一个类在全局中仅有一个实例，对象不会被重复创建，其实现分为饿汉式和懒汉式。 饿汉式：变量在声明时便初始化。 懒汉式：先声明一个空变量，需要用时才初始化。 关于懒汉式的实现由于Java，C++语言特性的原因，在多线程时会出现线程安全的问题（重复创建实例），具体可以参见这一篇文档 懒汉式具体实现参见其它文章。 饿汉式实现： 12345678910public class Singleton &#123; private static Singleton instance = new Singleton(); private Singleton() &#123; &#125; public static Singleton getInstance() &#123; return instance; &#125;&#125; 构造函数定义为私有成员，通过getInstance()方法获取实例。 建造者模式 Builder 将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。 建造者模式一般用于创建一个复杂的对象，其创建过程需要许多配置。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class MilkTea &#123; private final String type; private final String size; private final boolean pearl; private final boolean ice; private MilkTea() &#123;&#125; private MilkTea(Builder builder) &#123; this.type = builder.type; this.size = builder.size; this.pearl = builder.pearl; this.ice = builder.ice; &#125; public String getType() &#123; return type; &#125; public String getSize() &#123; return size; &#125; public boolean isPearl() &#123; return pearl; &#125; public boolean isIce() &#123; return ice; &#125; public static class Builder &#123; private final String type; private String size = \"中杯\"; private boolean pearl = true; private boolean ice = false; public Builder(String type) &#123; this.type = type; &#125; public Builder size(String size) &#123; this.size = size; return this; &#125; public Builder pearl(boolean pearl) &#123; this.pearl = pearl; return this; &#125; public Builder ice(boolean cold) &#123; this.ice = cold; return this; &#125; public MilkTea build() &#123; return new MilkTea(this); &#125; &#125;&#125; MilkTea 的构造方法设置为私有的，所以外部不能通过 new 构建出 MilkTea 实例，只能通过 Builder 构建。对于必须配置的属性，通过 Builder 的构造方法传入，可选的属性通过 Builder 的链式调用方法传入，如果不配置，将使用默认配置，也就是中杯、加珍珠、不加冰。根据不同的配置可以制作出不同的奶茶。 123456789101112131415161718192021222324252627282930313233343536public class User &#123; private void buyMilkTea() &#123; MilkTea milkTea = new MilkTea.Builder(\"原味\").build(); show(milkTea); MilkTea chocolate =new MilkTea.Builder(\"巧克力味\") .ice(false) .build(); show(chocolate); MilkTea strawberry = new MilkTea.Builder(\"草莓味\") .size(\"大杯\") .pearl(false) .ice(true) .build(); show(strawberry); &#125; private void show(MilkTea milkTea) &#123; String pearl; if (milkTea.isPearl()) pearl = \"加珍珠\"; else pearl = \"不加珍珠\"; String ice; if (milkTea.isIce()) &#123; ice = \"加冰\"; &#125; else &#123; ice = \"不加冰\"; &#125; System.out.println(\"一份\" + milkTea.getSize() + \"、\" + pearl + \"、\" + ice + \"的\" + milkTea.getType() + \"奶茶\"); &#125;&#125; 原型模式 Prototype 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。 原型模式是指根据已经有的对象，复制一个新的完全相同的对象，但是这两个对象在内存中占不一样的内存。 1234567891011public class MilkTea &#123; public String type; public boolean ice; public MilkTea clone() &#123; MilkTea milktea = new Milktea(); milktea.type = this.type; milktea.ice = this.ice; return milktea; &#125;&#125; Java中有Cloneable接口的语法糖，因此可以免去自行编写clone()。 12345678910public class MilkTea implements Cloneable&#123; public String type; public boolean ice; @NonNull @Override protected MilkTea clone() throws CloneNotSupportedException &#123; return (MilkTea) super.clone(); &#125;&#125; 注意对于引用类型的拷贝是浅拷贝，若需要深拷贝还是需要自行实现clone()。 结构型模式适配器模式 Adapter 将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 适配器模式相当于把一些不兼容的函数接口再做一层封装，封装层将外部不兼容的参数转换为被封装函数可以接受的类型，类似手机电源适配器，将220V电压转换为手机的充电电压，教程中给出的示例较为简单，就不再给出。 一般来说，适配器模式并不推荐大范围使用，优良的系统设计可以避免接口不兼容情况的出现，只有当后期开发遇到接口不兼容的情况才考虑使用适配器模式。 桥接模式 Bridge桥接模式的目的是为了避免子类继承带来的继承爆炸。考虑示例： 1234567891011121314151617181920212223242526interface IShape &#123; public void draw();&#125;class Rectangle implements IShape &#123; @Override public void draw() &#123; System.out.println(\"绘制矩形\"); &#125;&#125;class Round implements IShape &#123; @Override public void draw() &#123; System.out.println(\"绘制圆形\"); &#125;&#125;class Triangle implements IShape &#123; @Override public void draw() &#123; System.out.println(\"绘制三角形\"); &#125;&#125; 假设需要给每一种形状添加颜色属性，假设再单独设置一个颜色类，并通过继承的方式实现会出现继承爆炸的问题，因此需要通过桥接的方式来解决。 定义颜色类： 123456789101112131415161718192021222324interface Color &#123; public String getColor();&#125;class Red implements Color &#123; @Override public String getColor() &#123; return \"Red\"; &#125;&#125;class Green implements Color &#123; @Override public String getColor() &#123; return \"Green\"; &#125;&#125;class Blue implements Color &#123; @Override public String getColor() &#123; return \"Blue\"; &#125;&#125; 使用桥接： 12345678910111213class Rectangle implements IShape &#123; private Color color; void setColor(Color color) &#123; this.color = color; &#125; @Override public void draw() &#123; System.out.println(\"绘制矩形\"); &#125;&#125;// ... 组合模式 Composite组合模式 装饰模式 Decorator对于装饰模式理解这个图即可： 123456789101112131415 ┌───────────┐ │ Component │ └───────────┘ ▲ ┌────────────┼─────────────────┐ │ │ │┌───────────┐┌───────────┐ ┌───────────┐│ComponentA ││ComponentB │... │ Decorator │└───────────┘└───────────┘ └───────────┘ ▲ ┌──────┴──────┐ │ │ ┌───────────┐ ┌───────────┐ │DecoratorA │ │DecoratorB │... └───────────┘ └───────────┘ Component是接口，ComponentA和ComponentB属于具体的子类，后面便是单独的装饰器类，可以增强原有子类的功能。 外观模式 Facade外观模式就是封装，即可以将一系列类似的工作封装在一个统一的方法里面进行。 12345678910111213public class Facade &#123; public void open() &#123; Browser.open(); IDE.open(); Wechat.open(); &#125; public void close() &#123; Browser.close(); IDE.close(); Wechat.close(); &#125;&#125; 以上将类似的工作封装在了一个类中。 享元模式 Flyweight享元模式指的是程序应该尽可能的复用，其核心思想很简单，如果一个对象实例一经创建就不可变，那么反复创建相同的实例就没有必要，直接向调用方返回一个共享的实例就行，这样即节省内存，又可以减少创建对象的过程，提高运行速度。 代理模式 Proxy代理模式 代理模式通过封装一个已有接口，并向调用方返回相同的接口类型，能让调用方在不改变任何代码的前提下增强某些功能（例如，鉴权、延迟加载、连接池复用等）。一个简单的示例： 1234567891011121314151617public AProxy implements A &#123; private A a; public AProxy(A a) &#123; this.a = a; &#125; public void a() &#123; if (getCurrentUser().isRoot()) &#123; this.a.a(); &#125; else &#123; throw new SecurityException(\"Forbidden\"); &#125; &#125;&#125; 代理类便能实现权限的鉴定。 使用Proxy模式要求调用方持有接口，作为Proxy的类也必须实现相同的接口类型。 行为型模式责任链模式 Chain of responsibility责任链模式 责任链模式（Chain of Responsibility）是一种处理请求的模式，它让多个对象都有机会处理该请求，直到其中某个处理成功为止。责任链模式把多个对象串成链，然后让请求在链上传递： 1234567891011121314151617181920212223 ┌─────────┐ │ Request │ └─────────┘ │┌ ─ ─ ─ ─ ┼ ─ ─ ─ ─ ┐ ▼│ ┌─────────────┐ │ │ ProcessorA ││ └─────────────┘ │ ││ ▼ │ ┌─────────────┐│ │ ProcessorB │ │ └─────────────┘│ │ │ ▼│ ┌─────────────┐ │ │ ProcessorC ││ └─────────────┘ │ │└ ─ ─ ─ ─ ┼ ─ ─ ─ ─ ┘ │ ▼ A、B、C的处理能力依次增强，负责的责任范围依次扩大。 示例： 新建一个程序员抽象类： 123456789public abstract class Programmer &#123; protected Programmer next; public void setNext(Programmer next) &#123; this.next = next; &#125; abstract void handle(Bug bug);&#125; 在这个抽象类中： next 对象表示如果自己解决不了，需要将责任传递给的下一个人； handle 方法表示自己处理此 bug 的逻辑，在这里判断是自己解决或者继续传递。 新建菜鸟程序员类： 123456789101112131415public class NewbieProgrammer extends Programmer &#123; @Override public void handle(Bug bug) &#123; if (bug.value &gt; 0 &amp;&amp; bug.value &lt;= 20) &#123; solve(bug); &#125; else if (next != null) &#123; next.handle(bug); &#125; &#125; private void solve(Bug bug) &#123; System.out.println(\"菜鸟程序员解决了一个难度为 \" + bug.value + \" 的 bug\"); &#125;&#125; 新建普通程序员类： 123456789101112131415public class NormalProgrammer extends Programmer &#123; @Override public void handle(Bug bug) &#123; if (bug.value &gt; 20 &amp;&amp; bug.value &lt;= 50) &#123; solve(bug); &#125; else if (next != null) &#123; next.handle(bug); &#125; &#125; private void solve(Bug bug) &#123; System.out.println(\"普通程序员解决了一个难度为 \" + bug.value + \" 的 bug\"); &#125;&#125; 新建优秀程序员类： 123456789101112131415public class GoodProgrammer extends Programmer &#123; @Override public void handle(Bug bug) &#123; if (bug.value &gt; 50 &amp;&amp; bug.value &lt;= 100) &#123; solve(bug); &#125; else if (next != null) &#123; next.handle(bug); &#125; &#125; private void solve(Bug bug) &#123; System.out.println(\"优秀程序员解决了一个难度为 \" + bug.value + \" 的 bug\"); &#125;&#125; 客户端测试： 1234567891011121314151617181920212223import org.junit.Test;public class Client4 &#123; @Test public void test() &#123; NewbieProgrammer newbie = new NewbieProgrammer(); NormalProgrammer normal = new NormalProgrammer(); GoodProgrammer good = new GoodProgrammer(); Bug easy = new Bug(20); Bug middle = new Bug(50); Bug hard = new Bug(100); // 组成责任链 newbie.setNext(normal); normal.setNext(good); // 从菜鸟程序员开始，沿着责任链传递 newbie.handle(easy); newbie.handle(middle); newbie.handle(hard); &#125;&#125; 责任链的建立需要客户端来保证，因此客户端的责任链建立容易出错，导致出现循环调用。 命令模式 Command命令模式指的是将请求封装为命令。示例： 1234567891011121314151617181920212223242526public class TextEditor &#123; private StringBuilder buffer = new StringBuilder(); public void copy() &#123; ... &#125; public void paste() &#123; String text = getFromClipBoard(); add(text); &#125; public void add(String s) &#123; buffer.append(s); &#125; public void delete() &#123; if (buffer.length() &gt; 0) &#123; buffer.deleteCharAt(buffer.length() - 1); &#125; &#125; public String getState() &#123; return buffer.toString(); &#125;&#125; 以上模拟了一个文本编辑器的操作，客户端直接调用类接口提供的代码如下： 12345TextEditor editor = new TextEditor();editor.add(\"Command pattern in text editor.\\n\");editor.copy();editor.paste();System.out.println(editor.getState()); 调用方需要了解TextEditor的所有接口信息。 使用命令模式则可以对使用的接口进行封装，以命令类对象的形式进行调用。 引入一个Command接口： 123public interface Command &#123; void execute();&#125; 从中派生具体的命令类： 123456789101112131415161718192021222324public class CopyCommand implements Command &#123; // 持有执行者对象: private TextEditor receiver; public CopyCommand(TextEditor receiver) &#123; this.receiver = receiver; &#125; public void execute() &#123; receiver.copy(); &#125;&#125;public class PasteCommand implements Command &#123; private TextEditor receiver; public PasteCommand(TextEditor receiver) &#123; this.receiver = receiver; &#125; public void execute() &#123; receiver.paste(); &#125;&#125; 客户端可以改写为： 12345678910TextEditor editor = new TextEditor();editor.add(\"Command pattern in text editor.\\n\");// 执行一个CopyCommand:Command copy = new CopyCommand(editor);copy.execute();editor.add(\"----\\n\");// 执行一个PasteCommand:Command paste = new PasteCommand(editor);paste.execute();System.out.println(editor.getState()); 倘若需求很简单，则不需要命令模式，但若需要支持Undo、Redo的功能时，就需要使用命令模式，因为可以给每个命令增加undo()， 1234public interface Command &#123; void execute(); void undo();&#125; 在将使用的一系列命令对象用list保存起来，就可以支持undo，redo操作。 1234567891011121314151617181920212223┌─────────────┐│ Client │└─────────────┘ │ │ ▼┌─────────────┐│ Invoker │├─────────────┤ ┌───────┐│List commands│─ ─&gt;│Command││invoke(c) │ └───────┘│undo() │ │ ┌──────────────┐└─────────────┘ ├─&gt;│ CopyCommand │ │ ├──────────────┤ │ │editor.copy() │─ ┐ │ └──────────────┘ │ │ ┌────────────┐ │ ┌──────────────┐ ─&gt;│ TextEditor │ └─&gt;│ PasteCommand │ │ └────────────┘ ├──────────────┤ │editor.paste()│─ ┘ └──────────────┘ 解释器模式 Interpreter解释器模式相对比较复杂，感觉使用相对较少，一般需要自己设定一套文法规则，然后实现具体的解释器来解析按照文法规则排列的字符串，即解释器是用来解决一种特定问题的模式。例如正则表达式，需要对应的正则引擎。 迭代器模式 Iterator迭代器模式在Java的List等类型以及C++的stl提供的标准容器中十分常见，主要目的是隐藏底层容器的具体实现细节，并向上层提供一个遍历容器的方法。 一般的迭代器模式为了限制外部类对容器类元素的修改，只会给出两个接口，next()和hasNext()，用来访问下一个元素以及查询是否有下一个元素。 C++中对于vector的遍历： 123456vector&lt;int&gt; nums;// ...for (auto num : nums)&#123; // ...&#125; 以上即可遍历vector内部的所有元素，如果以引用方式进行访问，还可以对内部元素进行修改。 中介模式 Mediator中介者模式 中介者模式 备忘录模式 Memento备忘录模式 备忘录模式 将对象某个时刻的状态保存起来，以便某个时刻进行恢复，这就是备忘录模式。 备忘录模式（Memento），主要用于捕获一个对象的内部状态，以便在将来的某个时候恢复此状态。 观察者模式 Observer观察者模式 观察者模式 状态模式 State 允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。 策略模式 Strategy 策略模式（Strategy Pattern）：定义了一系列算法，并将每一个算法封装起来，而且使它们还可以相互替换。策略模式让算法独立于使用它的客户而独立变化。 模板方法模式 Template method 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 访问者模式 Visitor访问者模式 访问者模式 访问者模式的核心就是将对数据的访问与数据的结构进行解耦， 访问者模式（Visitor Pattern）：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。 需要注意单分派和多分派的问题。 1234567891011121314151617181920public class Food &#123; public String name() &#123; return \"food\"; &#125;&#125;public class Watermelon extends Food &#123; @Override public String name() &#123; return \"watermelon\"; &#125;&#125;public class Client &#123; @Test public void test() &#123; Food food = new Watermelon(); System.out.println(food.name()); //根据多态性质输出watermelon &#125;&#125; 根据多态，以上代码输出watermelon。 123456789101112131415public class Client &#123; @Test public void test() &#123; Food food = new Watermelon(); eat(food); &#125; public void eat(Food food) &#123; System.out.println(\"eat food\"); &#125; public void eat(Watermelon watermelon) &#123; System.out.println(\"eat watermelon\"); &#125;&#125; 以上代码输出eat food 这是由于 Java 在调用重载方法时，只会根据方法签名中声明的参数类型来判断调用哪个方法，不会去判断参数运行时的具体类型是什么。 Java 对重写方法和重载方法的调用方式是不同的。 调用重写方法时，与对象的运行时类型有关； 调用重载方法时，只与方法签名中声明的参数类型有关，与对象运行时的具体类型无关。 单分派、双重分派的定义： 方法的接收者和方法的参数统称为方法的宗量。 根据分派基于多少个宗量，可以将分派分为单分派和多分派。单分派是指根据一个宗量就可以知道应该调用哪个方法，多分派是指需要根据多个宗量才能确定调用目标。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://believebest35.github.io/tags/Java/"},{"name":"设计模式","slug":"设计模式","permalink":"http://believebest35.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Java多线程基础","slug":"Java-4","date":"2020-11-03T08:23:28.000Z","updated":"2020-11-06T03:28:27.822Z","comments":true,"path":"2020/11/03/Java-4/","link":"","permalink":"http://believebest35.github.io/2020/11/03/Java-4/","excerpt":"进程和线程一个典型示例： 123456789101112131415 ┌──────────┐ │Process │ │┌────────┐│ ┌──────────┐││ Thread ││┌──────────┐ │Process ││└────────┘││Process │ │┌────────┐││┌────────┐││┌────────┐│┌──────────┐││ Thread ││││ Thread ││││ Thread │││Process ││└────────┘││└────────┘││└────────┘││┌────────┐││┌────────┐││┌────────┐││┌────────┐│││ Thread ││││ Thread ││││ Thread ││││ Thread │││└────────┘││└────────┘││└────────┘││└────────┘│└──────────┘└──────────┘└──────────┘└──────────┘┌──────────────────────────────────────────────┐│ Operating System │└──────────────────────────────────────────────┘","text":"进程和线程一个典型示例： 123456789101112131415 ┌──────────┐ │Process │ │┌────────┐│ ┌──────────┐││ Thread ││┌──────────┐ │Process ││└────────┘││Process │ │┌────────┐││┌────────┐││┌────────┐│┌──────────┐││ Thread ││││ Thread ││││ Thread │││Process ││└────────┘││└────────┘││└────────┘││┌────────┐││┌────────┐││┌────────┐││┌────────┐│││ Thread ││││ Thread ││││ Thread ││││ Thread │││└────────┘││└────────┘││└────────┘││└────────┘│└──────────┘└──────────┘└──────────┘└──────────┘┌──────────────────────────────────────────────┐│ Operating System │└──────────────────────────────────────────────┘ 多个进程并行，拥有的资源相互独立。进程内部多个线程并行，共享进程所拥有的资源。 Java提供多线程支持多任务。 创建新线程Java程序启动后，JVM从主线程执行main()方法，main()方法执行中又可以启动新的线程。主要有两种方式 继承Thread继承Thread类，并覆写run()方法。 1234567891011121314151617public class Main&#123; public static void main(String[] args) &#123; Thread t = new MyThread(); t.start(); // 启动新线程 &#125;&#125;class MyThread extends Thread&#123; @Override public void run() &#123; System.out.println(\"start new thread!\"); &#125;&#125; 注意需要通过调用start()来启动新线程，如果通过run()，则是函数调用，依旧只有一个线程。 传入Runnable实例创建Thread实例时，传入一个Runnable实例 1234567891011121314151617public class Main&#123; public static void main(String[] args) &#123; Thread t = new Thread(new MyRunnable()); t.start(); // 启动新线程 &#125;&#125;class MyRunnable implements Runnable&#123; @Override public void run() &#123; System.out.println(\"start new thread!\"); &#125;&#125; 设定线程优先级 1Thread.setPriority(int n) // 1~10, 默认值5 当前线程暂停 1Thread.sleep(20); // 当前线程暂停20ms 线程状态123456789101112131415161718 ┌─────────────┐ │ New │ └─────────────┘ │ ▼┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐ ┌─────────────┐ ┌─────────────┐││ Runnable │ │ Blocked ││ └─────────────┘ └─────────────┘│┌─────────────┐ ┌─────────────┐│ │ Waiting │ │Timed Waiting││└─────────────┘ └─────────────┘│ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ │ ▼ ┌─────────────┐ │ Terminated │ └─────────────┘ New：新创建的线程，尚未执行； Runnable：运行中的线程，正在执行run()方法的Java代码； Blocked：运行中的线程，因为某些操作被阻塞而挂起； Waiting：运行中的线程，因为某些操作在等待中； Timed Waiting：运行中的线程，因为执行sleep()方法正在计时等待； Terminated：线程已终止，因为run()方法执行完毕。 使用join()方法可以使一个进程等待另一个进程结束。 123456789101112131415161718192021public class Main&#123; public static void main(String[] args) throws InterruptedException &#123; System.out.println(\"Main thread begin !!!\"); Thread t = new Thread(new MyRunnable()); t.start(); t.join(); // 等待t线程的结束 System.out.println(\"Main thread end !!!\"); &#125;&#125;class MyRunnable implements Runnable&#123; @Override public void run() &#123; System.out.println(\"Sub thread begin !!!\"); System.out.println(\"Sub thread end !!!\"); &#125;&#125; 输出 1234Main thread begin !!!Sub thread begin !!!Sub thread end !!!Main thread end !!! 如果t线程已经结束，对实例t调用join()会立刻返回。此外，join(long)的重载方法也可以指定一个等待时间，超过等待时间后就不再继续等待。 中断线程在另一个线程中对目标进程调用interrupt()方法，目标线程检测自身状态是否是interrupted状态，如果是，就立刻结束运行。 1234567891011121314151617181920public class Main &#123; public static void main(String[] args) throws InterruptedException &#123; Thread t = new MyThread(); t.start(); Thread.sleep(1); // 暂停1毫秒 t.interrupt(); // 中断t线程 t.join(); // 等待t线程结束 System.out.println(\"end\"); &#125;&#125;class MyThread extends Thread &#123; public void run() &#123; int n = 0; while (!isInterrupted()) &#123; n++; System.out.println(n + \" hello!\"); &#125; &#125;&#125; main()线程中的interrupt()方法只是向目标线程发出中止运行的请求，目标线程的停止需要目标线程代码自身决定。 假设线程a执行了join()方法，自身陷入等待，有线程b对线程a调用interrupt()，则join()方法会立刻抛出InterruptedException。线程只要捕获到join()方法抛出的InterruptedException，就说明有其他线程对其调用了interrupt()方法，通常情况下该线程应该立刻结束运行。 另一个常用的中断线程的方法是设置标志位。用一个running标志位来标识线程是否应该继续运行，在外部线程中，通过把running标志位设置为false，就可以让线程结束。 1234567891011121314151617181920public class Main &#123; public static void main(String[] args) throws InterruptedException &#123; HelloThread t = new HelloThread(); t.start(); Thread.sleep(1); t.running = false; // 标志位置为false &#125;&#125;class HelloThread extends Thread &#123; public volatile boolean running = true; public void run() &#123; int n = 0; while (running) &#123; n++; System.out.println(n + \" hello!\"); &#125; System.out.println(\"end!\"); &#125;&#125; boolean running是一个线程间共享的变量。线程间共享变量需要使用volatile关键字标记，确保每个线程都能读取到更新后的变量值。 守护进程见原文 原文教程关于守护进程的讲解也不细致，以后需要再学习。 线程同步经典栗子（读者与写者问题），若有多个线程同时读写一个变量，会造成数据不一致的问题，因此涉及到数据共享的问题。 12345678910111213141516171819202122232425262728293031323334353637383940public class Main &#123; public static void main(String[] args) throws Exception &#123; Thread add = new AddThread(); Thread dec = new DecThread(); add.start(); dec.start(); add.join(); dec.join(); System.out.println(Counter.count); &#125;&#125;class Counter &#123; public static int count = 0;&#125;class AddThread extends Thread &#123; public void run() &#123; for (int i = 0; i &lt; 10000; i++) &#123; Counter.count += 1; &#125; &#125;&#125;class DecThread extends Thread &#123; public void run() &#123; for (int i = 0; i &lt; 10000; i++) &#123; Counter.count -= 1; &#125; &#125;&#125; 如上add线程对静态变量Counter.count进行10000次自增操作，而dec线程对其进行10000次自减操作，理论上最后`Counter.count的结果应该为0，但是由于线程回写的速度不一致，每次运行的结果均不一致。 通过锁🔒机制来解决临界区资源的读写问题。 未加锁： 1234567891011┌───────┐ ┌───────┐│Thread1│ │Thread2│└───┬───┘ └───┬───┘ │ │ │ILOAD (100) │ │ │ILOAD (100) │ │IADD │ │ISTORE (101) │IADD │ │ISTORE (101)│ ▼ ▼ 加了锁： 123456789101112131415┌───────┐ ┌───────┐│Thread1│ │Thread2│└───┬───┘ └───┬───┘ │ │ │-- lock -- │ │ILOAD (100) │ │IADD │ │ISTORE (101) │ │-- unlock -- │ │ │-- lock -- │ │ILOAD (101) │ │IADD │ │ISTORE (102) │ │-- unlock -- ▼ ▼ 使用关键字synchronized修改原来的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Main &#123; public static void main(String[] args) throws Exception &#123; Thread add = new AddThread(); Thread dec = new DecThread(); dec.start(); add.start(); dec.join(); add.join(); System.out.println(Counter.count); &#125;&#125;class Counter &#123; public static final Object lock = new Object(); // 锁对象？ public static int count = 0;&#125;class AddThread extends Thread &#123; public void run() &#123; for (int i=0; i&lt;10000; i++) &#123; synchronized(Counter.lock) &#123; Counter.count += 1; &#125; &#125; &#125;&#125;class DecThread extends Thread &#123; public void run() &#123; for (int i=0; i&lt;10000; i++) &#123; synchronized(Counter.lock) &#123; Counter.count -= 1; &#125; &#125; &#125;&#125; 程序进入被synchronized包含的代码块时，会自动请求获得锁，退出代码块时会自动释放锁。 123synchronized(Counter.lock) &#123; // 获取锁 ...&#125; // 释放锁 关于synchronized： 找出修改共享变量的线程代码块； 选择一个共享实例作为锁； 使用synchronized(lockObject) { ... }。 一些原子操作不需要加锁： 基本类型（long和double除外）赋值，例如：int n = m； 引用类型赋值，例如：List&lt;String&gt; list = anotherList。 但是，如果是多行赋值语句，就必须保证是同步操作。 同步方法synchronized逻辑可以进行封装。 12345678910111213141516171819public class Counter &#123; private int count = 0; public void add(int n) &#123; synchronized(this) &#123; count += n; &#125; &#125; public void dec(int n) &#123; synchronized(this) &#123; count -= n; &#125; &#125; public int get() &#123; return count; &#125;&#125; 这样当其他线程调用add(), dec()方法时，不必关心同步策略。 以上的类设计说明该类是线程安全的。 下面两种写法是等价的： 123456789public void add(int n) &#123; synchronized(this) &#123; // 锁住this count += n; &#125; // 解锁&#125;public synchronized void add(int n) &#123; // 锁住this count += n;&#125; // 解锁 用synchronized修饰的方法就是同步方法，它表示整个方法都必须用this实例加锁。 可重入锁 Java中的线程锁是可重入锁，即JVM允许同一个线程多次获取同一个锁。 死锁数据库、操作系统课程中常见死锁。 若两个任务互相持有对方所请求的资源但不主动释放，便会形成死锁。 1234567891011121314151617public void add(int m) &#123; synchronized(lockA) &#123; // 获得lockA的锁 this.value += m; synchronized(lockB) &#123; // 获得lockB的锁 this.another += m; &#125; // 释放lockB的锁 &#125; // 释放lockA的锁&#125;public void dec(int m) &#123; synchronized(lockB) &#123; // 获得lockB的锁 this.another -= m; synchronized(lockA) &#123; // 获得lockA的锁 this.value -= m; &#125; // 释放lockA的锁 &#125; // 释放lockB的锁&#125; 以上可能形成死锁。 wait 和 notify以生产者和消费者问题为例： 有问题的代码： 12345678910111213class TaskQueue &#123; Queue&lt;String&gt; queue = new LinkedList&lt;&gt;(); public synchronized void addTask(String s) &#123; this.queue.add(s); &#125; public synchronized String getTask() &#123; while (queue.isEmpty()) &#123; &#125; return queue.remove(); &#125;&#125; 问题在于当队列为空时，getTask线程永远不会释放获取在当前对象上的锁，assTask线程永远无法调用。 修改如下： 1234567891011121314public synchronized String getTask() &#123; // 注意必须在while()循环中调用wait() while (queue.isEmpty()) &#123; // 释放this锁: this.wait(); // 重新获取this锁 &#125; return queue.remove();&#125;public synchronized void addTask(String s) &#123; this.queue.add(s); this.notify(); // 唤醒在this锁等待的线程&#125; notifyAll() 和 notify()使用notifyAll()将唤醒所有当前正在this锁等待的线程，而notify()只会唤醒其中一个（随机），通常来说，notifyAll()更安全。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://believebest35.github.io/tags/Java/"},{"name":"多线程","slug":"多线程","permalink":"http://believebest35.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"Java核心类","slug":"Java-3","date":"2020-10-28T02:21:42.000Z","updated":"2020-10-28T09:06:39.116Z","comments":true,"path":"2020/10/28/Java-3/","link":"","permalink":"http://believebest35.github.io/2020/10/28/Java-3/","excerpt":"StringString是一种引用类型，也是十分重要的类，由于String经常使用，因此Java允许以字面量的形式来表示String。","text":"StringString是一种引用类型，也是十分重要的类，由于String经常使用，因此Java允许以字面量的形式来表示String。 12String s1 = \"Hello!\";String s2 = new String(new char[] &#123;'H', 'e', 'l', 'l', 'o', '!'&#125;); Java内部将String表示为一个char型数组。 字符串比较String为引用类型，关于字符串内容的比较需要使用equals()方法。 12345678public class Main &#123; public static void main(String[] args) &#123; String s1 = \"hello\"; String s2 = \"HELLO\".toLowerCase(); System.out.println(s1 == s2); System.out.println(s1.equals(s2)); &#125;&#125; 第一个输出false（实际在比较所引用内容的地址），第二个输出true（比较引用对象实际的内容）。 一些常用的方法1234567891011121314151617181920212223242526272829303132333435363738// 是否包含子串:\"Hello\".contains(\"ll\"); // true\"Hello\".indexOf(\"l\"); // 2\"Hello\".lastIndexOf(\"l\"); // 3\"Hello\".startsWith(\"He\"); // true\"Hello\".endsWith(\"lo\"); // true// 字串\"Hello\".substring(2); // \"llo\"\"Hello\".substring(2, 4); // \"ll\" 第二个参数指的是结束字符（不包含）的索引，需要与C++中string的substr()相区分// 去空格\" \\tHello\\r\\n \".trim(); // \"Hello\" 移除字符串首尾空白字符。空白字符包括空格，\\t，\\r，\\n\"\\u3000Hello\\u3000\".strip(); // \"Hello\" strip()方法也可以移除字符串首尾空白字符，但类似中文的空格字符\\u3000也会被移除// 判空 是否有空白字符\"\".isEmpty(); // true，因为字符串长度为0\" \".isEmpty(); // false，因为字符串长度不为0\" \\n\".isBlank(); // true，因为只包含空白字符\" Hello \".isBlank(); // false，因为包含非空白字符// 字符串替换String s = \"hello\";s.replace('l', 'w'); // \"hewwo\"，所有字符'l'被替换为'w's.replace(\"ll\", \"~~\"); // \"he~~o\"，所有子串\"ll\"被替换为\"~~\"// 正则表达式替换String s = \"A,,B;C ,D\";s.replaceAll(\"[\\\\,\\\\;\\\\s]+\", \",\"); // \"A,B,C,D\"// 分割字符串String s = \"A,B,C,D\";String[] ss = s.split(\"\\\\,\"); // &#123;\"A\", \"B\", \"C\", \"D\"&#125;// 拼接字符串 静态方法String[] arr = &#123;\"A\", \"B\", \"C\"&#125;;String s = String.join(\"***\", arr); // \"A***B***C\" 格式化字符串 12345678910public class Main &#123; public static void main(String[] args) &#123; String s = \"Hi %s, your score is %d!\"; System.out.println(s.formatted(\"Alice\", 80)); System.out.println(String.format(\"Hi %s, your score is %.2f!\", \"Bob\", 59.5)); &#125;&#125;// Hi Alice, your score is 80!// Hi Bob, your score is 59.50! 常用的占位符有： %s：显示字符串； %d：显示整数； %x：显示十六进制整数； %f：显示浮点数。 类型转换 12345678910111213141516String.valueOf(123); // \"123\"String.valueOf(45.67); // \"45.67\"String.valueOf(true); // \"true\"String.valueOf(new Object()); // 类似java.lang.Object@636be97c// 字符串转换为int类型int n1 = Integer.parseInt(\"123\"); // 123int n2 = Integer.parseInt(\"ff\", 16); // 按十六进制转换，255// 字符串转换为boolean类型boolean b1 = Boolean.parseBoolean(\"true\"); // trueboolean b2 = Boolean.parseBoolean(\"FALSE\"); // false// String和char[]char[] cs = \"Hello\".toCharArray(); // String -&gt; char[]String s = new String(cs); // char[] -&gt; String 字符编码link StringBuilderJava可以使用+直接拼接字符串。 1234String s = \"\";for (int i = 0; i &lt; 1000; i++) &#123; s = s + \",\" + i;&#125; 但上述过程使用+的效率过低。 为了能高效拼接字符串，Java标准库提供了StringBuilder，它是一个可变对象，可以预分配缓冲区，这样，往StringBuilder中新增字符时，不会创建新的临时对象 123456StringBuilder sb = new StringBuilder(1024);for (int i = 0; i &lt; 1000; i++) &#123; sb.append(','); sb.append(i);&#125;String s = sb.toString(); StringJoiner用分隔符拼接数组 123456789101112131415import java.util.StringJoiner;public class Hello&#123; public static void main(String[] args) &#123; String[] names = &#123;\"Bob\", \"Alice\", \"Grace\"&#125;; var sj = new StringJoiner(\", \"); for (String name : names) &#123; sj.add(name); &#125; System.out.println(sj.toString()); &#125;&#125;// Bob, Alice, Grace 还可以指定开头和结尾 123456789101112131415import java.util.StringJoiner;public class Hello&#123; public static void main(String[] args) &#123; String[] names = &#123;\"Bob\", \"Alice\", \"Grace\"&#125;; var sj = new StringJoiner(\", \", \"Hello \", \"!\"); // 以 , 作为分隔符， Hello 作为开头， ! 作为结尾 for (String name : names) &#123; sj.add(name); &#125; System.out.println(sj.toString()); &#125;&#125;// Hello Bob, Alice, Grace! String.join() 静态方法，不需要指定开头和结尾。 12String[] names &#x3D; &#123;&quot;Bob&quot;, &quot;Alice&quot;, &quot;Grace&quot;&#125;;var s &#x3D; String.join(&quot;, &quot;, names); 包装类型可以把Java的基本类型包装为引用类型，Java核心库为每种基本类型都提供了对应的包装类型： 基本类型 对应的引用类型 boolean java.lang.Boolean byte java.lang.Byte short java.lang.Short int java.lang.Integer long java.lang.Long float java.lang.Float double java.lang.Double char java.lang.Character 123456789// 通过静态方法valueOf(int)创建Integer实例:Integer n1 = Integer.valueOf(i);// 通过静态方法valueOf(String)创建Integer实例:Integer n2 = Integer.valueOf(\"100\");// int 和 Integer 互转int i = 100;Integer n = Integer.valueOf(i);int x = n.intValue(); Java可进行自动装/拆箱。 123// Java编译器自动在int和Integer之间转型：Integer n = 100; // 编译器自动使用Integer.valueOf(int)int x = n; // 编译器自动使用Integer.intValue() 所有的包装类型都是不变类。 123public final class Integer &#123; private final int value;&#125; 对于包装类型的比较，需要使用equals()。 JavaBean若一个class的定义都符合这样的规范： 若干private实例字段； 通过public方法来读写实例字段。 12345678910public class Person &#123; private String name; private int age; public String getName() &#123; return this.name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return this.age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 读写方法符合以下这种命名规范： 1234// 读方法:public Type getXyz()// 写方法:public void setXyz(Type value) 那么这种class被称为JavaBean。 boolean字段比较特殊，它的读方法一般命名为isXyz()： 1234// 读方法:public boolean isChild()// 写方法:public void setChild(boolean value) 通常把一组对应的读方法（getter）和写方法（setter）称为属性（property）。例如，name属性： 对应的读方法是String getName() 对应的写方法是setName(String) 只有getter的属性称为只读属性（read-only），例如，定义一个age只读属性： 对应的读方法是int getAge() 无对应的写方法setAge(int) 类似的，只有setter的属性称为只写属性（write-only）。 很明显，只读属性很常见，只写属性不常见。 属性只需要定义getter和setter方法，不一定需要对应的字段。 1234567891011121314public class Person &#123; private String name; private int age; public String getName() &#123; return this.name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return this.age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public boolean isChild() &#123; return age &lt;= 6; &#125;&#125; 了解枚举类、记录类","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://believebest35.github.io/tags/Java/"}]},{"title":"Java面向对象","slug":"Java-2","date":"2020-10-26T08:48:04.000Z","updated":"2020-10-28T02:21:16.144Z","comments":true,"path":"2020/10/26/Java-2/","link":"","permalink":"http://believebest35.github.io/2020/10/26/Java-2/","excerpt":"面向对象即描述类与实例的一类规则。","text":"面向对象即描述类与实例的一类规则。 12345class Person &#123; public String name; public int age; private int height;&#125; 以上定义了类Person以及两个公共数据成员，一个私有数据成员。 123Person tony = new Person();tony.name = \"tony\"; // 通过 . 访问// tony.height = 100; 报错 方法1234567class ClassName &#123; public TypeName1 objname1; private TypeName2 objname2; public ReturnType FuncName(Args) &#123; // ... &#125;&#125; 定义一个公共方法，提供对外的接口，也可以定义私有方法，但只可以在内部调用。 定义模版如下： 1234修饰符 方法返回类型 方法名(方法参数列表) &#123; 若干方法语句; return 方法返回值;&#125; this变量与C++的this指针类似，Java方法内部存在隐含的this变量，始终指向当前的实例，可通过this.field访问具体的字段。 1234567class Person &#123; private String name; public void setName(String name) &#123; this.name = name; // 前面的this不可少，少了就变成局部变量name了 &#125;&#125; 可变参数可变参数用类型...定义，可变参数相当于数组类型： 1234567class Group &#123; private String[] names; public void setNames(String... names) &#123; this.names &#x3D; names; &#125;&#125; 调用时可以传入的参数个数可变。 12345Group g = new Group();g.setNames(\"Xiao Ming\", \"Xiao Hong\", \"Xiao Jun\"); // 传入3个Stringg.setNames(\"Xiao Ming\", \"Xiao Hong\"); // 传入2个Stringg.setNames(\"Xiao Ming\"); // 传入1个Stringg.setNames(); // 传入0个String 当传入0个参数时可保证names是一个空数组而不是null。 构造方法类似C++的构造函数 1234567891011121314151617class Person &#123; private String name; private int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return this.name; &#125; public int getAge() &#123; return this.age; &#125;&#125; 构造方法名称与类名相同，不带返回值，可以重载，若显式定义构造方法则编译器不会生成默认构造方法（即无参数的构造方法），要使用需自己显式定义。 构造函数中没有初始化的引用成员自动初始化为null，其他基本类型按各自类型的初始默认值进行初始化。 可以对字段直接进行初始化 123456789class Person &#123; private String name = \"Unamed\"; private int age = 10; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125;&#125; 最后保留构造方法传入的字段值。 一个构造方法可以调用其他构造方法，便于代码复用。调用其他构造方法的语法是this(…) 1234567891011121314151617class Person &#123; private String name; private int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public Person(String name) &#123; this(name, 18); // 调用另一个构造方法Person(String, int) &#125; public Person() &#123; this(\"Unnamed\"); // 调用另一个构造方法Person(String) &#125;&#125; 方法重载方法同名但是参数不同。 123456789101112131415161718class Hello &#123; public void hello() &#123; System.out.println(\"Hello, world!\"); &#125; public void hello(String name) &#123; System.out.println(\"Hello, \" + name + \"!\"); &#125; public void hello(String name, int age) &#123; if (age &lt; 18) &#123; System.out.println(\"Hi, \" + name + \"!\"); &#125; else &#123; System.out.println(\"Hello, \" + name + \"!\"); &#125; &#125;&#125; 继承基类定义 123456789class Person &#123; private String name; private int age; public String getName() &#123;...&#125; public void setName(String name) &#123;...&#125; public int getAge() &#123;...&#125; public void setAge(int age) &#123;...&#125;&#125; 派生类定义 12345678class Student extends Person &#123; // 不要重复name和age字段/方法, // 只需要定义新增score字段/方法: private int score; public int getScore() &#123; … &#125; public void setScore(int score) &#123; … &#125;&#125; 派生类中成员函数无法访问基类中的私有字段，要访问需改为protected类型成员。（Java的继承类似C++的public型继承） 不同于C++的是，Java不允许多重继承。 protected12345678910class Person &#123; protected String name; protected int age;&#125;class Student extends Person &#123; public String hello() &#123; return \"Hello, \" + name; // OK! &#125;&#125; 基类的protected型成员在派生类仍可访问。 super使用super可以定位到派生类。 12345class Student extends Person &#123; public String hello() &#123; return \"Hello, \" + super.name; // 等价于 this.name 或者 name &#125;&#125; super也可以使用在基类的构造函数中 123456789101112131415161718192021222324public class Main &#123; public static void main(String[] args) &#123; Student s = new Student(\"Xiao Ming\", 12, 89); &#125;&#125;class Person &#123; protected String name; protected int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125;&#125;class Student extends Person &#123; protected int score; public Student(String name, int age, int score) &#123; super(name, age); this.score = score; &#125;&#125; 基类不继承派生类的构造函数，基类构造函数必须首先调用派生类构造函数，通过super()的形式进行调用，不显式调用则编译器会尝试在基类构造函数加上super()，容易导致构造函数参数不匹配。 类型转换 向上转换（派生类转基类） 1Person p = new Student(); 上述行为合法 向下转换（基类转派生类） 1Student s = new Person(); 上述行为不合法 instanceofinstanceof用于判断某实例是否为某类型。 12345678910Person p = new Person();System.out.println(p instanceof Person); // trueSystem.out.println(p instanceof Student); // falseStudent s = new Student();System.out.println(s instanceof Person); // trueSystem.out.println(s instanceof Student); // trueStudent n = null;System.out.println(n instanceof Student); // false 12345Person p = new Student();if (p instanceof Student) &#123; // 只有判断成功才会向下转型: Student s = (Student) p; // 一定会成功&#125; 继承与组合 继承是is关系 组合是has关系，要实现组合将另一个类定义为自己的类成员即可。 多态覆写Java中的普通方法就类似C++中的虚函数，动态绑定（晚捆绑）是Java的默认行为，因此Java中不需要像C++中那样区分重写覆盖以及重写隐藏。 类似于C++多态机制的重写覆盖，Java提供覆写。 123456789101112class Person &#123; public void run() &#123; System.out.println(\"Person.run\"); &#125;&#125;class Student extends Person &#123; @Override public void run() &#123; System.out.println(\"Student.run\"); &#125;&#125; 派生类重新定义了run()方法，并使用@Override显式说明进行覆写（重写覆盖），需要基类和派生类中方法参数、返回类型一致。 多态示例12345678910111213141516171819public class Main &#123; public static void main(String[] args) &#123; Person p = new Student(); p.run(); &#125;&#125;class Person &#123; public void run() &#123; System.out.println(\"Person.run\"); &#125;&#125;class Student extends Person &#123; @Override public void run() &#123; System.out.println(\"Student.run\"); &#125;&#125; 实际打印Person.run，说明Java实例方法调用是基于晚捆绑的。 多态机制指的是针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法。 Java方法参数传递时针对引用类型都传递引用，根据传入引用所指的实际类型调用方法，因此支持多态机制。 重写Object方法Java中所有类均继承于Object类，可以对其中一些公共方法进行重写。 toString()：把instance输出为String； equals()：判断两个instance是否逻辑相等； hashCode()：计算一个instance的哈希值。 1234567891011121314151617181920212223242526class Person &#123; ... // 显示更有意义的字符串: @Override public String toString() &#123; return \"Person:name=\" + name; &#125; // 比较是否相等: @Override public boolean equals(Object o) &#123; // 当且仅当o为Person类型: if (o instanceof Person) &#123; Person p = (Person) o; // 并且name字段相同时，返回true: return this.name.equals(p.name); &#125; return false; &#125; // 计算hash: @Override public int hashCode() &#123; return this.name.hashCode(); &#125;&#125; 调用super()派生类的重写方法使用super()可以调用基类被重写的方法。 1234567891011121314class Person &#123; protected String name; public String hello() &#123; return \"Hello, \" + name; &#125;&#125;Student extends Person &#123; @Override public String hello() &#123; // 调用父类的hello()方法: return super.hello() + \"!\"; &#125;&#125; final使用final可以禁止方法被重写。 12345678910111213class Person &#123; protected String name; public final String hello() &#123; return \"Hello, \" + name; &#125;&#125;Student extends Person &#123; // compile error: 不允许覆写 @Override public String hello() &#123; &#125;&#125; final也可以修饰类定义，表示该类不可以继承。 1234567final class Person &#123; protected String name;&#125;// compile error: 不允许继承自PersonStudent extends Person &#123;&#125; final可以修饰类定义中的字段，表示一旦初始化之后就不可修改。 123456class Person &#123; public final String name = \"Unamed\";&#125;Person p = new Person();p.name = \"New Name\"; // compile error! 也可以在构造函数中进行初始化final字段。 123456class Person &#123; public final String name; public Person(String name) &#123; this.name = name; &#125;&#125; final也可以在定义常量实例的时候使用。 抽象类有时基类中定义的方法不需要实时实现，等待到继承的派生类中实现，可以将基类声明为抽象类，抽象类中再定义抽象方法（类似C++中的纯虚函数），同C++类似，抽象类不可以被实例化。 12345678910111213abstract class Person &#123; public abstract void run();&#125; // 抽象方法和抽象类定义同时被abstract修饰class Student extends Person &#123; @Override public void run() &#123; … &#125;&#125;class Teacher extends Person &#123; @Override public void run() &#123; … &#125;&#125; 抽象类会强迫派生类实现其中的抽象方法。 接口如果一个抽象类没有字段，所有方法全部都是抽象方法，可以将抽象类改为接口。 12345678910abstract class Person &#123; public abstract void run(); public abstract String getName();&#125;// 等价于interface Person &#123; void run(); String getName();&#125; 实现接口 1234567891011121314151617class Student implements Person &#123; // 使用implements private String name; public Student(String name) &#123; this.name = name; &#125; @Override public void run() &#123; System.out.println(this.name + \" run\"); &#125; @Override public String getName() &#123; return this.name; &#125;&#125; Java不支持多重继承，但是支持一次性实现多个接口。 123class Student implements Person, Kid &#123; ...&#125; 接口可以继承接口 12345678interface Hello &#123; void hello();&#125;interface Person extends Hello &#123; void run(); String getName();&#125; default当接口中加了新的方法，所有实现接口的子类必须实现新的方法，使用default可以默认指定一种实现版本，从而避免所有子类去实现新加的方法。 12345678910111213141516171819202122232425public class Main &#123; public static void main(String[] args) &#123; Person p = new Student(\"Xiao Ming\"); p.run(); &#125;&#125;interface Person &#123; String getName(); default void run() &#123; System.out.println(getName() + \" run\"); &#125;&#125;class Student implements Person &#123; private String name; public Student(String name) &#123; this.name = name; &#125; public String getName() &#123; return this.name; &#125;&#125; 接口和抽象类对比 abstract class interface 继承 只能extends一个class 可以implements多个interface 字段 可以定义实例字段 不能定义实例字段 抽象方法 可以定义抽象方法 可以定义抽象方法 非抽象方法 可以定义非抽象方法 可以定义default方法 static与C++类似，Java中静态字段和静态成员函数被整个类的所有实例共享 静态字段 123456789class Person &#123; public String name; public int age; // 定义静态字段number: public static int number;&#125;...Person.number = 100; 可以通过类名进行访问。 静态方法 1234567891011121314public class Main &#123; public static void main(String[] args) &#123; Person.setNumber(99); System.out.println(Person.number); &#125;&#125;class Person &#123; public static int number; public static void setNumber(int value) &#123; number = value; &#125;&#125; 静态方法只能访问静态字段。 接口的静态字段因为interface是一个纯抽象类，所以它不能定义实例字段。但是，interface是可以有静态字段的，并且静态字段必须为final类型： 1234public interface Person &#123; public static final int MALE &#x3D; 1; public static final int FEMALE &#x3D; 2;&#125; 实际上，因为interface的字段只能是public static final类型，所以我们可以把这些修饰符都去掉，上述代码可以简写为： 12345public interface Person &#123; &#x2F;&#x2F; 编译器会自动加上public statc final: int MALE &#x3D; 1; int FEMALE &#x3D; 2;&#125; 编译器会自动把该字段变为public static final类型。 包Java使用包（类似命名空间）来解决类名冲突。 假设包名定义为package，其中类名为class，则完整的类名为package.class，例如Ming.Person等。 1234package ming; // 申明包名mingpublic class Person &#123;&#125; 1234package mr.jun; // 申明包名mr.junpublic class Arrays &#123;&#125; 在Java虚拟机执行的时候，JVM只看完整类名，因此，只要包名不同，类就不同。 包可以是多层结构，用.隔开。例如：java.util。 一般根据包名来组织Java文件，假设以package_sample作为根目录，src作为源码目录 123456789package_sample└─ src ├─ hong │ └─ Person.java │ ming │ └─ Person.java └─ mr └─ jun └─ Arrays.java 编译后的.class文件也需要按照包结构存放。如果使用IDE，把编译后的.class文件放到bin目录下，那么，编译的文件结构就是： 123456789package_sample└─ bin ├─ hong │ └─ Person.class │ ming │ └─ Person.class └─ mr └─ jun └─ Arrays.class 包作用域位于同一个包的类，可以访问包作用域的字段和方法。不用public、protected、private修饰的字段和方法就是包作用域。 12345678package hello;public class Person &#123; // 包作用域: void hello() &#123; System.out.println(\"Hello!\"); &#125;&#125; 12345678package hello;public class Main &#123; public static void main(String[] args) &#123; Person p = new Person(); p.hello(); // 可以调用，因为Main和Person在同一个包 &#125;&#125; import使用其他包的类，可以使用完整包名： 12345678// Person.javapackage ming;public class Person &#123; public void run() &#123; mr.jun.Arrays arrays = new mr.jun.Arrays(); &#125;&#125; 也可以使用import，简化包名。 1234567891011// Person.javapackage ming;// 导入完整类名:import mr.jun.Arrays;public class Person &#123; public void run() &#123; Arrays arrays = new Arrays(); &#125;&#125; 在写import的时候，可以使用*，表示把这个包下面的所有class都导入进来（但不包括子包的class）： 1234567891011/ Person.javapackage ming;// 导入mr.jun包的所有class:import mr.jun.*;public class Person &#123; public void run() &#123; Arrays arrays = new Arrays(); &#125;&#125; import static可以导入一个类的静态字段和静态方法，不过较少使用 1234567891011package main;// 导入System类的所有静态字段和静态方法:import static java.lang.System.*;public class Main &#123; public static void main(String[] args) &#123; // 相当于调用System.out.println(…) out.println(\"Hello, world!\"); &#125;&#125; 实际中，编译器会自动做两个import动作： 默认自动import当前package的其他class； 默认自动import java.lang.*。 建议： 为了避免名字冲突，需要确定唯一的包名。推荐使用倒置的域名： org.apache org.apache.commons.log 子包根据功能自行命名。 不要和java.lang包的类重名，即自己的类不要使用这些名字： String System Runtime … 要注意也不要和JDK常用类重名： java.util.List java.text.Format java.math.BigInteger … 作用域 public private protected package 包作用域 public定义为public的class、interface可以被其他任何类访问。 定义为public的field、method可以被其他类访问，前提是首先有访问class的权限。 private定义为private的field、method无法被其他类访问。 private访问权限被限定在class的内部。 若类中定义了嵌套类，则嵌套类可以访问private成员。 protected定义为protected的字段和方法可以被子类以及子类的子类访问。 包作用域见上。 一些建议若不确定是否需要public，就尽量减少public的使用，减少对外暴露的接口。 方法定义为package访问权限并将测试代码放在同一个包内有助于进行测试。 一个.java文件只能包含一个public类，但可以包含多个非public类。如果有public类，文件名必须和public类的名字相同。 内部类Inner ClassInner Class即是将类定义在另一个类的内部。 12345class Outer &#123; class Inner &#123; // 定义了一个Inner Class &#125;&#125; Inner Class的实例不能单独存在，必须依附于一个Outer Class的实例。 123456789101112131415161718192021public class Main &#123; public static void main(String[] args) &#123; Outer outer = new Outer(\"Nested\"); // 实例化一个Outer Outer.Inner inner = outer.new Inner(); // 实例化一个Inner inner.hello(); &#125;&#125;class Outer &#123; private String name; Outer(String name) &#123; this.name = name; &#125; class Inner &#123; void hello() &#123; System.out.println(\"Hello, \" + Outer.this.name); &#125; &#125;&#125; Inner Class可以修改Outer Class的private字段。 Anonymous ClassAnonymous Class匿名类 123456class OuterClass &#123; // 定义一个匿名类 Type object1 = new Type(parameterList) &#123; // 匿名类代码 &#125;;&#125; 一个具体的实例 123456789101112131415161718192021222324public class Main &#123; public static void main(String[] args) &#123; Outer outer = new Outer(\"Nested\"); outer.asyncHello(); &#125;&#125;class Outer &#123; private String name; Outer(String name) &#123; this.name = name; &#125; void asyncHello() &#123; Runnable r = new Runnable() &#123; @Override public void run() &#123; System.out.println(\"Hello, \" + Outer.this.name); &#125; &#125;; new Thread(r).start(); &#125;&#125; 匿名类可以继承普通类或者接口，并在其中重写成员方法。 匿名类可以访问外部类的私有数据成员。 Static Nested Class静态内部类，依然定义在一个类的内部，但是不需要依附于外部类，可以单独存在。 12345678910111213141516171819202122public class Main &#123; public static void main(String[] args) &#123; Outer.StaticNested sn = new Outer.StaticNested(); sn.hello(); &#125;&#125;class Outer &#123; private static String NAME = \"OUTER\"; private String name; Outer(String name) &#123; this.name = name; &#125; static class StaticNested &#123; void hello() &#123; System.out.println(\"Hello, \" + Outer.NAME); &#125; &#125;&#125; 静态内部类可以访问外部类的私有数据成员。 classpath和jar原出处 classpathclasspath是JVM用到的一个环境变量，它用来指示JVM如何搜索class。 因为Java是编译型语言，源码文件是.java，而编译后的.class文件才是真正可以被JVM执行的字节码。因此，JVM需要知道，如果要加载一个abc.xyz.Hello的类，应该去哪搜索对应的Hello.class文件。 所以，classpath就是一组目录的集合，它设置的搜索路径与操作系统相关。例如，在Windows系统上，用;分隔，带空格的目录用&quot;&quot;括起来，可能长这样： 1C:\\work\\project1\\bin;C:\\shared;\"D:\\My Documents\\project1\\bin\" 在Linux系统上，用:分隔，可能长这样： 1/usr/shared:/usr/local/bin:/home/username/bin 假设classpath是.;C:\\work\\project1\\bin;C:\\shared，当JVM在加载abc.xyz.Hello这个类时，会依次查找： &lt;当前目录&gt;\\abc\\xyz\\Hello.class C:\\work\\project1\\bin\\abc\\xyz\\Hello.class C:\\shared\\abc\\xyz\\Hello.class 如果JVM在某个路径下找到了对应的class文件，就不再往后继续搜索。如果所有路径下都没有找到，就报错。 强烈不推荐在系统环境变量中设置classpath，在启动JVM时设置classpath才是推荐的做法。实际上就是给java命令传入-classpath或-cp参数： 1java -classpath .;C:\\work\\project1\\bin;C:\\shared abc.xyz.Hello 或者使用-cp的简写： 1java -cp .;C:\\work\\project1\\bin;C:\\shared abc.xyz.Hello 没有设置系统环境变量，也没有传入-cp参数，那么JVM默认的classpath为.，即当前目录： 1java abc.xyz.Hello 在IDE中运行Java程序，IDE自动传入的-cp参数是当前工程的bin目录和引入的jar包。 jarjar包可以把package组织的目录层级，以及各个目录下的所有文件（包括.class文件和其他文件）都打成一个jar文件。jar包里的第一层目录，不能是bin。 jar包实际上就是一个zip格式的压缩文件，而jar包相当于目录。如果要执行一个jar包的class，就可以把jar包放到classpath中： 1java -cp .&#x2F;hello.jar abc.xyz.Hello 这样JVM会自动在hello.jar文件里去搜索某个类。 手动创建jar包可以使用zip压缩再更改后缀名为jar，大型工程可以使用Maven等工具来创建jar包。 模块原出处 jar包不能管理包之间的依赖，因此从Java9引入模块。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://believebest35.github.io/tags/Java/"},{"name":"OOP","slug":"OOP","permalink":"http://believebest35.github.io/tags/OOP/"}]},{"title":"Java_基础","slug":"Java-1","date":"2020-10-26T02:25:15.000Z","updated":"2020-10-26T08:42:38.228Z","comments":true,"path":"2020/10/26/Java-1/","link":"","permalink":"http://believebest35.github.io/2020/10/26/Java-1/","excerpt":"参照廖雪峰的Java教程进行学习。 JDK和JRE JDK：Java Development Kit JRE：Java Runtime Environment","text":"参照廖雪峰的Java教程进行学习。 JDK和JRE JDK：Java Development Kit JRE：Java Runtime Environment 1234567891011 ┌─ ┌──────────────────────────────────┐ │ │ Compiler, debugger, etc. │ │ └──────────────────────────────────┘JDK ┌─ ┌──────────────────────────────────┐ │ │ │ │ │ JRE │ JVM + Runtime Library │ │ │ │ │ └─ └─ └──────────────────────────────────┘ ┌───────┐┌───────┐┌───────┐┌───────┐ │Windows││ Linux ││ macOS ││others │ └───────┘└───────┘└───────┘└───────┘ JAVA_HOME的bin目录 java：这个可执行程序其实就是JVM，运行Java程序，就是启动JVM，然后让JVM执行指定的编译后的代码； javac：这是Java的编译器，它用于把Java源码文件（以.java后缀结尾）编译为Java字节码文件（以.class后缀结尾）； jar：用于把一组.class文件打包成一个.jar文件，便于发布； javadoc：用于从Java源码中自动提取注释并生成文档； jdb：Java调试器，用于开发阶段的运行调试。 第一个Java程序1234567public class Hello&#123; public static void main(String[] args) &#123; System.out.println(\"hello world\"); &#125;&#125; 定义了一个公开类Hello（为了规范，类名首字母一般大写）。 程序从名为main()的公开静态方法开始进入（一般成员函数名称首字母小写）。 System.out.println()向终端进行打印。 一些Java程序基础以第一个Java程序为例，定义了名为Hello的公开类，定义了名为main的公开静态方法，即程序入口。 注释Java的三种注释 1234567891011// 单行注释/* 多行注释...*/ /** 用于自动创建文档的注释**/ 其中最后的一种特殊的多行注释格式一般写在类和方法的定义处，用于自动创建文档。 Mac下eclipse按⌘+⇧+F（Windows下按Ctrl+Shift+F）可以格式化代码。 变量基本类型 整数类型：byte，short，int，long 浮点数类型：float，double 字符类型：char 布尔类型：boolean 大小 123456789101112131415161718192021 ┌───┐ byte │ │ └───┘ ┌───┬───┐ short │ │ │ └───┴───┘ ┌───┬───┬───┬───┐ int │ │ │ │ │ └───┴───┴───┴───┘ ┌───┬───┬───┬───┬───┬───┬───┬───┐ long │ │ │ │ │ │ │ │ │ └───┴───┴───┴───┴───┴───┴───┴───┘ ┌───┬───┬───┬───┐ float │ │ │ │ │ └───┴───┴───┴───┘ ┌───┬───┬───┬───┬───┬───┬───┬───┐double │ │ │ │ │ │ │ │ │ └───┴───┴───┴───┴───┴───┴───┴───┘ ┌───┬───┐ char │ │ │ └───┴───┘ 整型，与C++不同，Java只有带符号的整型数，最高位为为符号位（0正1负），表示范围： byte：-128 ~ 127 （1字节） short: -32768 ~ 32767 （2字节） int: -2147483648 ~ 2147483647 （4字节） long: -9223372036854775808 ~ 9223372036854775807 （8字节） 1234int a = 2_000_000; // 下划线分割，实际为2000000int b = 0xff001; // 16进制int c = 0b10101; // 二进制long d = 9000000000000000000L; // long型结尾需要加L 浮点型 float：4字节，结尾加f进行标志 double：8字节 12float a = 1.0f;double b = 1.0; 字符型 使用单引号 boolean型 只表示true或者false。JVM一般将其用4个字节进行存储。（同C++，和int互相转）。 引用类型引用类似C++中的引用，实际记录的是某个对象在内存的位置。最为常用的： 1String str = \"hello world\"; 需要注意引用类型的比较，需要使用equals成员函数进行比较，使用==仅是在判断所引用的对象是否一致。 12345String s1 = \"hello\";String s2 = \"Hello\".toLowerCase();boolean res1 = s1 == s2; // falseboolean res2 = s1.equals(s2); // true final和var使用final可以定义常量类型，不可以被修改（类似C++ const），使用var可进行自动类型推断（类似C++ auto）。 12final int a = 1;var b = new StringBuilder(); 运算 + - * / % ++ -- += -= /= *= &gt; &lt; == &gt;= &lt;= != &amp;&amp; || ! &gt;&gt; &lt;&lt; &gt;&gt;&gt; 最后一个为无符号右移，最高位补0 &amp; | ! ^ = b ? x : y 类型转换自动的类型转换都是从小范围到大范围，强转类似C++。 StringJava提供了自带的字符串类型，引用类型。 12345String s1 = \"test\";String s2 = s1 + \" \" + \"test\"; // 拼接String s3 = \"\"; // 空串String s4 = null; // 空引用String s5; // 空引用 数组与C++数组类型不同，Java的数组类型需要动态声明大小，为引用类型。 采用类型[] 数组名的形式进行声明。 12345678int[] arr = new int[10];arr[0] = 1;// ...int size = 100;int[] arr_2 = new int[size];int size_2 = arr_2.length;String[] str_arr = new String[size]; // 字符串数组每个元素都是引用类型 流程控制输入输出1System.out.println();// 简单的输出 输出可使用格式化参数。 输出相对C++而言更复杂，一般使用Scanner类。 123456import java.util.Scanner;Scanner scanner = new Scanner(System.in); // 新建Scanner对象String str = scanner.nextLine(); // 读一行字符串String str_2 = scanner.next(); // 读字符串直到遇到空格、换行等int a = scanner.nextInt(); // 读整数 if else, switch case, while, do while, for, continue, break同C++ 类似C++11，Java也有基于范围（for each）的循环。 12345678int[] arr = &#123;1, 2, 3, 4, 5, 6&#125;;for (var num : arr) &#123; System.out.println(num);&#125;for (int num : arr) &#123; System.out.println(num);&#125; for each循环也适用于其他的可迭代类型。 数组操作 遍历 排序 JDK提供Arrays.sort()进行排序 1234import java.util.Arrays;int[] nums = &#123;5, 3, 4, 2, 1&#125;;Arrays.sort(nums); 多维数组 123int[][] arr = new int[3][5];System.out.println(arr.length); // 3System.out.println(arr[1].length); // 5","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://believebest35.github.io/tags/Java/"}]},{"title":"一些Linux的基础知识","slug":"Linux","date":"2020-10-19T08:55:19.000Z","updated":"2020-10-26T02:24:51.598Z","comments":true,"path":"2020/10/19/Linux/","link":"","permalink":"http://believebest35.github.io/2020/10/19/Linux/","excerpt":"由于自己薄弱的Linux基础，需要快速的补充一下自己有关Linux知识，以下内容简单总结于鸟叔的Linux私房菜。","text":"由于自己薄弱的Linux基础，需要快速的补充一下自己有关Linux知识，以下内容简单总结于鸟叔的Linux私房菜。 日期的指令 date 显示日期 cal 显示日历 12345678910111213--- ~ » date2020年10月19日 星期一 17时12分03秒 CST--- ~ » cal 十月 2020日 一 二 三 四 五 六 1 2 3 4 5 6 7 8 9 1011 12 13 14 15 16 1718 19 20 21 22 23 2425 26 27 28 29 30 31--- ~ » cal 2020# ......--- ~ » cal 10 2020 ls ls 显示当前目录下文件 12345678910111213141516--- ~ » ls -ltotal 8drwxr-xr-x 5 xinrui_tang staff 160 10 5 16:26 Applicationsdrwxr-xr-x 3 xinrui_tang staff 96 3 21 2019 Cloud Drivedrwx------@ 44 xinrui_tang staff 1408 10 19 09:27 Desktopdrwx------+ 8 xinrui_tang staff 256 8 3 15:53 Documentsdrwx------@ 6 xinrui_tang staff 192 10 19 09:26 Downloadsdrwx------@ 82 xinrui_tang staff 2624 7 20 12:16 Librarydrwx------+ 6 xinrui_tang staff 192 11 26 2019 Moviesdrwx------+ 8 xinrui_tang staff 256 10 10 2019 Musicdrwx------+ 5 xinrui_tang staff 160 8 10 2019 Picturesdrwxr-xr-x+ 5 xinrui_tang staff 160 9 14 2019 Publicdrwxr-xr-x 4 xinrui_tang staff 128 10 15 20:54 eclipsedrwxr-xr-x 3 xinrui_tang staff 96 10 15 20:17 javasharedresourcesdrwxr-xr-x 3 xinrui_tang staff 96 6 28 20:23 nltk_data-rw-rw-rw- 1 xinrui_tang staff 18 6 16 2019 sockets.log 第一个字符可以为 1234d 表示为目录- 表示为文件| 表示为链接文件... 接下来三个均为”rwx”的字符组合，r表示可读，w表示可写，x表示可执行，若没有权限则用 ‘-‘ 代替 第一组为文件拥有者可具备的权限。 第二组为加入此群组的帐号的权限。 第三组为非本人且没有加入本群组的其他帐号的权限。 第二栏的数字表示有多少文件名链接到此节点 第三栏表示拥有者 第四栏表示所属群组 第五栏为这个文件的容量大小，默认单位为Bytes 第六栏为这个文件的创建日期或者是最近的修改日期 第七栏是文件名 改变文件属性和权限 chown 改变文件拥有者 chmod 改变文件权限 chgrp 改变群组 以上三个命令请另行查阅文档。 目录处理 cd 变换目录 pwd 显示当前路径 mkdir 创建文件夹 rmdir 删除空文件夹 复制移动和删除 cp 复制 rm 删除 mv 移动 查阅文件内容 cat od 可显示文件的二进制编码 head [-n, number] filename 指定显示文件的前几行 tail 同head，指定显示文件的后几行 to do","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://believebest35.github.io/tags/Linux/"}]},{"title":"面向对象_STL进阶","slug":"OOP-THU-8","date":"2020-10-14T02:52:25.000Z","updated":"2020-10-14T14:06:43.358Z","comments":true,"path":"2020/10/14/OOP-THU-8/","link":"","permalink":"http://believebest35.github.io/2020/10/14/OOP-THU-8/","excerpt":"stringSTL提供string类型用以替代C语言自带的char型数组。","text":"stringSTL提供string类型用以替代C语言自带的char型数组。 12345678910111213141516171819202122232425262728293031323334353637383940string first_name = \"xinrui\", last_name = \"tang\";string full_name = first_name + \" \" + last_name; // string拼接//初始化string s0(\"Hello World!\");string s1(); // 空串//转换为C风格字符串s0.c_str(); // 返回的是字符串常量string s;// 与vector类似s[i]; // 下标访问int len = s.size();int len = s.length(); // 求长度，vector没有s.clear(); // 清空bool is_empty = s.empty(); // 查询是否为空for (auto ch : s)&#123; // ... 迭代，同vector&#125;s.push_back('a'); // 尾部加字符s.append(\"aa\"); // 尾部加字符串s += 'a';s += \"aa\"; // += 运算符进行拼接cin &gt;&gt; s; // 遇到空格停止读入getline(cin, s); // 读一行getline(cin, s, '#'); // 读到遇见指定分隔符s0 &lt; s1; // 比较字典序s = to_string(123); // 整型数转strings = to_string(3.14); // 浮点数转strings = to_string(3.1415926); // 3.141593 损失精度int a = stoi(\"123\"); // string转intdouble b = stod(\"3.14\"); // string转double iostream 输入输出流ostream输出流，重载了所有基础类型的”&lt;&lt;”运算，将printf相对混乱的输入格式统一做了简化，”&lt;&lt;”运算左结合。 12345678910111213141516171819202122class my_ostream // 定义自己的输出流&#123;public: my_ostream&amp; operator&lt;&lt; (char c) &#123; printf(\"%c\", c); return *this; &#125; my_ostream&amp; operator&lt;&lt; (const char *str) &#123; printf(\"%s\", str); return *this; &#125;&#125;;int main()&#123; my_ostream my_cout; my_cout &lt;&lt; 'a' &lt;&lt; \"aaa\"; // 运算为左结合 return 0;&#125; 格式化输出，借助流操纵算子： 123456789101112131415#include&lt;iomanip&gt;cout &lt;&lt; fixed &lt;&lt; 2018.0 &lt;&lt; \" \" &lt;&lt; 0.0001 &lt;&lt; endl; //浮点数，小数有效6位 -&gt; 2018.000000 0.000100cout &lt;&lt; scientific &lt;&lt; 2018.0 &lt;&lt; \" \" &lt;&lt; 0.0001 &lt;&lt; endl; //科学计数法 -&gt; 2.018000e+03 1.000000e-04cout &lt;&lt; defaultfloat; //还原默认输出格式cout &lt;&lt; setprecision(2) &lt;&lt; 3.1415926 &lt;&lt; endl; //输出精度设置为2，包括整数+小数 -&gt; 3.1cout &lt;&lt; oct &lt;&lt; 12 &lt;&lt; \" \" &lt;&lt; hex &lt;&lt; 12 &lt;&lt; endl; //八进制输出 -&gt; 14 十六进制输出 -&gt; ccout &lt;&lt; dec; //还原十进制cout &lt;&lt; setw(3) &lt;&lt; setfill('*') &lt;&lt; 5 &lt;&lt; endl; //设置对齐长度为3，对齐字符为* -&gt; **5 endl基本等于输出’\\n’后再刷新缓冲区，是一个函数，同时也是流操纵算子。 cout无法复制，是一个全局对象。 注意重载流运算符的方式: 12ostream&amp; operator&lt;&lt;(const char &amp;c)friend ostream&amp; operator&lt;&lt;(ostream&amp; os, MyClass obj) 重载 ‘&lt;&lt;’ 返回引用以防进行复制。 观察ostream的拷贝构造函数 12ostream (const ostream&amp;) = delete;ostream (ostream&amp;&amp; x); 拷贝构造函数被删除，只允许移动，防止复制。 文件输入输出流以ifstream为例，是istream子类。 打开文件 123456ifstream ifs(\"input.txt\");ifstream ifs(\"binary.bin\", ifstream::binary);//以二进制形式打开文件ifstream ifs;ifs.open(\"file_path\")//do somethingifs.close() 字符串输入输出流stringstream对象内部维护了一个buffer，使用流输出函数可以将数据写入buffer，使用流输入函数可以从buffer中读出数据。 123456789101112stringstream ss; //空字符串流stringstream ss(str); //以字符串初始化流// ...stringstream ss;ss &lt;&lt; \"10\";ss &lt;&lt; \"0 200\";int a, b;ss &gt;&gt; a &gt;&gt; b; //a=100 b=200ss.str(); //返回一个string对象,内容为stringstream的buffer 需要注意buffer内容并不是未读取的内容 123456stringstream ss;ss &lt;&lt; \"100 200\";cout &lt;&lt; ss.str() &lt;&lt; endl; //\"100 200\"int a;ss &gt;&gt; a; // a = 100cout &lt;&lt; ss.str() &lt;&lt; endl; //\"100 200\" sort12345std::sort(); // STL提供的排序算法，默认从小到大排序，时间复杂度O(nlogn)// 原型template&lt;class Iterator&gt; void sort(Iterator first, Iterator last); 若想从大到小排序，则 123456789101112131415161718// sort还重载了另一套参数template &lt;class Iterator, class Compare&gt;void sort(Iterator first, Iterator last, Compare comp);// 对于整型bool cmp(int a, int b)&#123; return a &gt; b;&#125;sort(a.begin(), a.end(), cmp); // 从大到小排序// STL提供了预定义的排序函数// 从小到大sort(a.begin(), a.end(), less&lt;int&gt;());// 从大到小sort(a.begin(), a.end(), greater&lt;int&gt;()); 对于自定义的类型，使用sort排序需要自己定义比较规则，可以重载 ‘&lt;’ , ‘&gt;’ 运算符或者定义cmp比较函数。 智能指针与引用计数 shared_ptr 来自memory头文件 1234#include &lt;memory&gt;shared_ptr&lt;int&gt; p1(new int(1));shared_ptr&lt;int&gt; p2; //空指针 通过引用计数知道何时销毁资源 123456789shared_ptr&lt;int&gt; p1(new int(4));cout &lt;&lt; p1.use_count() &lt;&lt; ' ';&#123; shared_ptr&lt;int&gt; p2 = p1; cout &lt;&lt; p1.use_count() &lt;&lt; ' '; cout &lt;&lt; p2.use_count() &lt;&lt; ' ';&#125; //p2出作用域cout &lt;&lt; p1.use_count() &lt;&lt; ' ';// 输出 1 2 2 1 其他用法： 1234p.get() //获取裸指针p.reset() //清除指针并减少引用计数static_pointer_cast&lt;int&gt;(p)dynamic_pointer_cast&lt;Base&gt;(p) 注意不能使用同一裸指针同时初始化多个智能指针 123int* p = new int(); shared_ptr&lt;int&gt; p1(p); shared_ptr&lt;int&gt; p2(p); // wrong !! 关于智能指针的详细介绍需要另外查资料。 weak_ptr 指向对象但不计数 1234567shared_ptr&lt;int&gt; sp(new int(3));weak_ptr&lt;int&gt; wp1 = sp;wp.use_count() //获取引用计数wp.reset() //清除指针wp.expired() //检查对象是否无效sp = wp.lock() //从弱引用获得一个智能指针 栗子： 123456789101112std::weak_ptr&lt;int&gt; wp;&#123; auto sp1 = std::make_shared&lt;int&gt;(20); wp = sp1; cout &lt;&lt; wp.use_count() &lt;&lt; endl; //1 auto sp2 = wp.lock(); //从弱引用中获得一个shared_ptr cout &lt;&lt; wp.use_count() &lt;&lt; endl; //2 sp1.reset(); //sp1释放指针 cout &lt;&lt; wp.use_count() &lt;&lt; endl; //1&#125; //sp2销毁cout &lt;&lt; wp.use_count() &lt;&lt; endl; //0cout &lt;&lt; wp.expired() &lt;&lt; endl; //检查弱引用是否失效：True unique_ptr shared_ptr涉及到共享计数，性能相对较差，使用unique_ptr可以保证每个对象只被唯一的一个指针所引用。 12345auto up1 = std::make_unique&lt;int&gt;(20);unique_ptr&lt;int&gt; up2 = up1; //错误，不能复制unique指针unique_ptr&lt;int&gt; up2 = std::move(up1); //可以移动unique指针int *p = up2.release(); //放弃指针控制权，返回裸指针delete p; lambda表达式C++11引入lambda表达式以创建匿名函数。 语法定义 1[捕获参数] (函数参数列表) mutable 或 exception 声明 -&gt; 返回值类型 &#123;函数体&#125; 一个栗子： 1234567int a = 1;auto func = [a] (int x) -&gt; int &#123;return a + x&#125;; // -&gt; int 显式指定了返回类型，当返回void或者编译器可以自动推断时，可以省略cout &lt;&lt; func(3) &lt;&lt; endl; // 按值捕获输出4auto func_2 = [&amp;a] (int x) &#123;return a + x&#125;;a = 2;cout &lt;&lt; func_2(3) &lt;&lt; endl; // 按引用捕获输出5 [捕获参数] 标志lambda表达式的开始，不捕获时为空。可以按照值捕获也可以按引用捕获。一些例子： [] 不捕获变量 [a, &amp;b] 按值捕获a，引用捕获b [this] 按值捕获this指针 [=] 按值捕获所有外部变量 [&amp;] 按引用捕获所有外部变量 [=, &amp;a] 按引用捕获a，其余变量按值捕获 [&amp;, =a] 按值捕获a，其余变量按引用捕获 mutable 或 exception 声明可以省略。按值传递函数对象参数时，加上 mutable 修饰符后，可以修改传递进来的拷贝（注意是能修改拷贝，而不是值本身），exception 声明用于指定函数抛出的异常，如抛出整数类型的异常，可以使用 throw(int)。 正则表达式正则表达式是文本搜索时进行匹配的一种规则。 单独字符，匹配字符本身。 转义字符，例如 ‘\\n’ 匹配换行符， ‘\\t’ 匹配制表符。 特殊字符，’^’ 匹配开头，’$’匹配结尾， ‘^hello$’就可匹配只含有hello的内容 [abc] 匹配其中的任意单个字符 [a-z] 匹配所有小写字母 [0-9] 匹配所有单个数字 []中的内容加 ‘^’ 可以取反，即表示不匹配。 12[^abc] 表示不匹配a，b，c[^a-z] 表示不匹配小写字母 []]可以连用，例如 1[a-z][0-9] 特殊字符 1234567&#39;.&#39; 可以匹配除换行符以外的任意字符\\d 等价于 [0-9]\\D 等价于 [^0-9]\\s 匹配所有空白字符\\S 匹配所有非空白字符\\w 匹配字母数字和下划线\\W 匹配非字母数字和下划线 x{n,m}代表前面内容出现次数重复n~m次 12345678a&#123;4&#125; 匹配aaaaa&#123;2,4&#125; 匹配aa或aaa或aaaaa&#123;2,&#125; 匹配长度大于等于2的[a-z]&#123;5,12&#125; 代表为长度为5~12的英文字母组合.&#123;5&#125; 所有长度为5的字符? 等价&#123;0,1&#125;+ 等价&#123;1,&#125;* 等价&#123;0,&#125; 或连接符 匹配模式可以使用 ‘|’ 进行连接 12(Chapter|Section) [1-9][0-9]? 可以匹配Chapter 1、Section 10等0\\d&#123;2&#125;-\\d&#123;8&#125;|0\\d&#123;3&#125;-\\d&#123;7&#125; 可以匹配010-12345678、0376-2233445 使用 ()改变优先级 12m|food 可以匹配m 或者 food(m|f)ood 可以匹配mood 或者 food 以()标识的部分被称作分组 123456* 正则表达式匹配后，每个分组的内容将被捕获* 用于提取关键信息，例如version(\\d+)即可捕获版本号* 分组会按顺序标号* 0号永远是匹配的字符串本身* (a)(pple) 0号为apple 1号为a 2号为pple使用(?:pattern)可以不捕获该分组 预查 后向引用 贪婪与懒惰 to do 原生字符串 12345正则表达式中往往会有很多\\，字符串表示时应写成\\\\原生字符串可以取消转义，保留字面值语法：R&quot;(str)&quot; 表示str的字面值&quot;\\\\d+&quot; &#x3D; R&quot;(\\d+)&quot; &#x3D; \\d+ 正则表达式库regex正则表达式匹配的三种模式 匹配 询问字符串是否能匹配正则表达式，并捕获相应分组 regex_match 替换 替换字符串中匹配的子串，并替换成相应内容 regex_replace 搜索 搜索字符串中匹配的子串，并捕获相应分组 regex_search 栗子 123456789string s(\"subject\");regex e(R\"(sub)(.*)\");smatch sm;regex_match(s,sm,e);cout &lt;&lt; sm.size() &lt;&lt; \" matches\\n\";cout &lt;&lt; \"the matches were: \";for (unsigned i=0; i&lt;sm.size(); ++i) &#123; cout &lt;&lt; \"[\" &lt;&lt; sm[i] &lt;&lt; \"] \"；&#125; 输出：3 matchesthe matches were: [subject] [sub] [ject] 关于regex库更详细的用法需要参考专业资料。","categories":[],"tags":[{"name":"OOP","slug":"OOP","permalink":"http://believebest35.github.io/tags/OOP/"}]},{"title":"面向对象_模版和STL初步","slug":"OOP-THU-7","date":"2020-10-13T02:31:17.000Z","updated":"2020-10-13T12:14:52.676Z","comments":true,"path":"2020/10/13/OOP-THU-7/","link":"","permalink":"http://believebest35.github.io/2020/10/13/OOP-THU-7/","excerpt":"函数模板和类模板继承和组合提供了重用对象代码的方法，而模板特征则提供了重用源代码的方法。 首先考虑下面的一个问题： 1234void sort(int *data, int len);void sort(float *data, int len);void sort(my_class *data, int len);// ...","text":"函数模板和类模板继承和组合提供了重用对象代码的方法，而模板特征则提供了重用源代码的方法。 首先考虑下面的一个问题： 1234void sort(int *data, int len);void sort(float *data, int len);void sort(my_class *data, int len);// ... 以上的排序算法的实现细节是一致的，仅仅只有数据（对象）的类型不同，因此有必要通过某种方式来重用代码。因此需要引入模板特征。模板可以分为： 函数模板 类模板 成员函数模板 函数模板有些函数的实现与类型无关，因此可以将类型设置为一种特殊的“参数”，这样就可以得到函数模板。 定义函数模板的方法： 12template&lt;typename T&gt; returnTypeFunc(Args) returnType表示函数模板将会返回的类型，也可以写成template表示的，说明返回的类型也不确定。 简单的相加函数模板就可以定义如下： 12345template&lt;typename T&gt;T sum(T a, T b)&#123; return a + b;&#125; 函数模板在实际调用时会根据调用参数的实际类型实例化为一个普通函数，但是需要实际的类型能够满足函数的运算要求，例如上例中要求对象类型可以进行加法运算。 也可以同时指定多个模版参数，例如： 12345template&lt;typename T1, typename T2&gt;T1 sum(T1 a, T2, b)&#123; return a + b;&#125; 以上要求两个类型之间可以进行相加并可进行类型转换。 可以手动指定调用类型 1cout &lt;&lt; sum&lt;int&gt;(1 + 2) &lt;&lt; endl; 类模版在定义类时也可以用一些模板参数使得类更具有通用性，示例如下： 12345678910111213141516171819202122template&lt;typename T&gt;class A&#123;private: T data;public: void func_1() &#123; cout &lt;&lt; data &lt;&lt; endl; &#125; void func_2();&#125;;template&lt;typename T&gt;void A&lt;T&gt;::func_2() // 模版类成员函数的类外定义，模版声明必须加上，否则编译报错&#123; cout &lt;&lt; data &lt;&lt; endl;&#125;int main()&#123; A&lt;int&gt; a; a.func_1(); // ...&#125; 类模版的参数： 类型参数：使用typename或class进行标记 非类型参数：整数，枚举，指针（指向对象或函数），引用（引用对象或引用函数）等，其中整数用的比较多。示例： 1234567891011template&lt;typename T, unsigned size&gt;class array&#123; T data[size]; // ...&#125;;int main()&#123; array&lt;int, 10&gt; arr;&#125; 成员函数模板普通类的成员函数也可以定义函数模，示例： 12345678910111213141516171819class normal_class&#123;public: int value; /// 在类内定义 template&lt;typename T&gt; void set(T const&amp; v) &#123; value = int(v); &#125; template&lt;typename T&gt; T get();&#125;;template&lt;typename T&gt; /// 在类外定义T normal_class::get()&#123; return T(value); &#125; 既可以在类中定义，也可以在类外进行定义。 普通类模板的成员函数，也可有额外的模板参数。示例： 123456789101112131415161718192021222324252627282930template&lt;typename T0&gt;class A&#123; T0 value; public: /// 在类内定义 template&lt;typename T1&gt; void set(T1 const&amp; v) &#123; value = T0(v); &#125; template&lt;typename T1&gt; T1 get();&#125;;/// 类外定义template&lt;typename T0&gt; template&lt;typename T1&gt; // 后面的template&lt;typename T1&gt;表示该函数的返回类型不确定T1 A&lt;T0&gt;::get()&#123; return T1(value);&#125;/// 注意以下写法是错误的/*template&lt;typename T0, typename T1&gt; T1 A&lt;T0&gt;::get()&#123; return T1(value);&#125;*/ 总结： 多个参数的类模板： 12template&lt;typename T0, typename T1&gt; class A &#123;&#125; 多个参数的函数模板 12template&lt;typename T0, typename T1&gt; void func( T0 a1, T1 a2 ) &#123;&#125; 函数模板特化有些类型当前的函数模板不能进行处理，因此需要对模版进行特殊化处理，这称为函数模板特化。函数模板特化需要提供所有模板参数的具体类型，不能进行部分特化，若要部分特化，则需要另开模板并重载。下面举一个栗子： 12345678// 泛型版本template &lt;class T&gt; int compare(const T &amp;v1, const T &amp;v2)&#123; if(v1 &lt; v2) return -1; if(v2 &gt; v1) return 1; return 0;&#125; 当实际参数为两个char型指针时，若要求比较的是char型指针指向内容的大小而不是地址大小，需要对上述函数模板进行特化。 123456// 特化版本template &lt;&gt; int compare&lt;const char *&gt;(const char * const &amp;v1, const char * const &amp;v2)&#123; return strcmp(v1, v2);&#125;// 远离C风格字符串。。。 函数特化的另外一个栗子： 1234567891011template&lt;typename T&gt;T div2(const T &amp;val)&#123; return val / 2;&#125;template&lt;&gt;int div2&lt;int&gt;(const int &amp;val)&#123; return val &gt;&gt; 1; // 整型除法&#125; 类模板特化对于类模板，允许部分特化，即部分限制模板的通用性，如通用模板为： 1template&lt;typename T1, typename T2&gt; class A &#123; ... &#125;; 部分特化 1template&lt;typename T1&gt; class A&lt;T1, int&gt; &#123;...&#125;; //指定第二个参数为int 全部特化 1template&lt;&gt; class A&lt;int, int&gt; &#123; ... &#125;; // 指定了所有参数 模板原理对于模板的处理是在编译时进行的，编译器每发现一个模板示例，就生成对应的代码。 需要注意的是，模板库必须在头文件中进行实现，不可以分开进行编译，因为若分开，则编译器不知道具体的函数模板实例如何初始化，会产生链接错误。 命名空间为了避免在大规模程序的设计中，以及在程序员使用各种各样的C++库时，标识符的命名发生冲突，标准C++引入了关键字namespace（命名空间），可以更好地控制标识符的作用域。 标准C++库（不包括标准C库）中所包含的所有内容（包括常量、变量、结构、类和函数等）都被定义在命名空间std（standard标准）中。 123456789101112131415161718// 定义命名空间namespace A&#123; int x, y;&#125;// 使用命名空间A::x = 3;A::y = 4;// 直接使用部分元素using A::x;x = 3;// 使用整个命名空间using namespace A;x = 3;y = 4; STL标准模板库，其中包含4个组件，分别为算法、容器、函数、迭代器。基于模板进行编写。 关键理念：将“在数据上执行的操作”与“要执行操作的数据”分离。 STL的命名空间为std。 关于STL中具体容器的介绍可直接查看文档。","categories":[],"tags":[{"name":"OOP","slug":"OOP","permalink":"http://believebest35.github.io/tags/OOP/"}]},{"title":"面向对象_虚函数与多态","slug":"OOP-THU-6","date":"2020-10-11T11:08:48.000Z","updated":"2020-10-13T12:16:44.553Z","comments":true,"path":"2020/10/11/OOP-THU-6/","link":"","permalink":"http://believebest35.github.io/2020/10/11/OOP-THU-6/","excerpt":"函数调用捆绑首先明确C++中捆绑的概念，捆绑（binding）指的是将函数的调用与函数的实现部分（函数体）相联系起来，即将函数体实现代码的入口地址与调用的函数名相绑定，程序执行到函数调用时会直接进入到函数实现代码。 捆绑可分为早捆绑和晚捆绑两个类别。","text":"函数调用捆绑首先明确C++中捆绑的概念，捆绑（binding）指的是将函数的调用与函数的实现部分（函数体）相联系起来，即将函数体实现代码的入口地址与调用的函数名相绑定，程序执行到函数调用时会直接进入到函数实现代码。 捆绑可分为早捆绑和晚捆绑两个类别。 早捆绑（early binding） 在程序运行之前（即编译时）已经确定了函数调用与具体的函数体之间的绑定关系，运行之前可以知道函数调用将会进入哪个函数体，这会导致如下的问题： 12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;class Instrument&#123;public: void play() &#123; cout &lt;&lt; \"Instrument::play\" &lt;&lt; endl; &#125;&#125;;class Wind : public Instrument&#123;public: void play() &#123; cout &lt;&lt; \"Wind::play\" &lt;&lt; endl; &#125; /// 重写隐藏&#125;;void tune(Instrument&amp; i)&#123; i.play();&#125;int main()&#123; Wind flute; tune(flute); /// 向上类型转换&#125; 以上的程序运行后实际会输出“Instrument::play”，这就是由于tune()中的i.play()和Instrument::play()的早捆绑所导致的。 晚捆绑（late binding） 与早捆绑相对应，晚捆绑发生在程序运行时，即程序运行之后才知道函数调用的所关联的具体函数体。晚捆绑只针对类中的虚函数起作用。 虚函数对于被派生类重新定义的成员函数，若它在基类中被声明为虚函数，则通过基类指针或引用调用该成员函数时，编译器将根据所指（或引用）对象的实际类型决定是调用基类中的函数，还是调用派生类重写的函数。虚函数定义说明如下： 123456class base&#123;public: virtual returnType Func(argument); // 虚函数定义 // ...&#125; 只要某成员函数在基类中被声明为虚函数，其派生类中的同名同参数成员函数（重写覆盖）也会是虚函数（不论在派生类中是否声明为虚函数）。 使用虚函数，早捆绑的问题即可解决，示例如下： 12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;class Instrument&#123;public: virtual void play() &#123; cout &lt;&lt; \"Instrument::play\" &lt;&lt; endl; &#125;&#125;;class Wind : public Instrument&#123;public: void play() &#123; cout &lt;&lt; \"Wind::play\" &lt;&lt; endl; &#125; /// 重写覆盖&#125;;void tune(Instrument&amp; i)&#123; i.play(); // 函数运行到这时根据i的实际类型调用对应的函数，实现了动态多态。&#125;int main()&#123; Wind flute; tune(flute); /// 向上类型转换&#125; 实际会输出“wind::play”。 注意晚捆绑只对指针或者引用类型有效。 虚函数表程序运行时对象要保存自身实际类型的信息，这些信息存储在虚函数表里。 虚函数表：每个包含虚函数的类用于存储虚函数地址的表。 每个包含虚函数的类的对象均有一个指向该类虚函数地址的指针（虚函数指针，vpointer/VPTR），当发生虚函数调用的时候通过虚函数指针获取虚函数表地址，然后在虚函数表中查询对应的虚函数实现代码的地址，以实现晚绑定。 若派生类中某虚函数fun()没有进行重写覆盖，则派生类和基类中的虚函数表fun()指向同一个虚函数体。 虚函数与构造函数包含虚函数的对象初始化时需要设置虚指针，虚函数指针的初始化由构造函数自动的进行，不需要程序员显式写出。需要注意的是，构造函数不能也不必要声明为虚函数。 讲义之中有说明在构造函数中调用虚函数的情况，实际运行的函数会是虚函数的本地版本（当前类的版本），即虚函数多态的机制失效。因为派生类中最先进行初始化的是基类的成员，若调用实际类的虚函数可能会使用到未初始化的派生类成员，导致未定义的行为。 若不理解上述原因也无所谓，尽量不要在构造函数中调用虚函数，这时虚函数的机制失效，没有实际的意义。 虚函数与析构函数析构函数能声明为虚函数，且常常是虚的。 虚析构函数的作用在于当删除基类类型的指针时，编译器将根据指针所指对象的实际类型来调用对应的析构函数，防止出现内存泄漏的错误。 同样的，尽量不要在析构函数中调用虚函数。 重要原则：总是将基类的析构函数设置为虚析构函数。 重写覆盖重写覆盖（override）：派生类重新定义基类中的虚函数，函数名必须相同，函数参数必须相同，返回值一般情况应相同。派生类的虚函数表中原基类的虚函数指针会被派生类中重新定义的虚函数指针覆盖掉。 重写隐藏（redefining）：派生类重新定义基类中的函数，函数名相同，但是参数不同或者基类的函数不是虚函数(参数相同+虚函数-&gt;不是重写隐藏)。虚函数表不会发生覆盖。 重写覆盖和重写隐藏： 相同点： 都要求派生类定义的函数与基类同名。 都会屏蔽基类中的同名函数，即派生类的实例无法调用基类的同名函数。 不同点： 重写覆盖要求基类的函数是虚函数，且函数参数相同，返回值一般情况应相同；重写隐藏要求基类的函数不是虚函数或者函数参数不同。 重写覆盖会使派生类虚函数表中基类的虚函数的指针被派生类的虚函数指针覆盖。重写隐藏不会。 重写覆盖与重写隐藏的示例如下： 12345678910111213141516171819class Base&#123;public: virtual void foo() &#123; cout&lt;&lt;\"Base::foo()\"&lt;&lt;endl; &#125;; virtual void foo(int )&#123; cout&lt;&lt;\"Base::foo(int )\"&lt;&lt;endl; &#125;; ///重载 void bar() &#123;&#125;;&#125;;class Derived1 : public Base&#123;public: void foo(int ) &#123; cout&lt;&lt;\"Derived1::foo(int )\"&lt;&lt;endl; &#125;; /// 重写覆盖&#125;;class Derived2 : public Base &#123;public: void foo(float ) &#123; cout&lt;&lt;\"Derived2::foo(float )\"&lt;&lt;endl; &#125;; /// 参数不一致，不是重写覆盖，是重写隐藏&#125;; Override关键字重写覆盖要求的条件很多，首先必须是重定义基类中的虚函数，并且要求参数相同，可以使用override关键字显式的告诉编译器进行重写覆盖，编译器将对重写覆盖要满足的条件进行检查，正确的重写覆盖才能通过编译。 1234567class Derived2 : public Base&#123;public: void foo(int ) override &#123; // ... &#125;; 是Base中的虚函数，并且参数一致 //void foo(float ) override &#123;&#125;; /// 参数不同，不是重写覆盖，编译错误 //void bar() override &#123;&#125;; /// bar 非虚函数，编译错误 &#125; 以上是使用override关键字的示例。 final关键字有些时候不希望虚函数在派生类中被重写，或者不希望有些类被继承，这时可以使用final关键字。 final关键字在虚函数声明或者虚函数定义时使用可以确保后续的派生类中不可以重写派生类，final关键字在类定义的时候使用会指定该类不可以被继承。示例如下： 12345678910111213141516171819202122232425262728class Base&#123;public: virtual void func() &#123;&#125;; // 基类中声明为虚函数 // ...&#125;;class A : public Base&#123;public: void func() final &#123; /* ... */ &#125; // 在类A中用final指定func()， 则func()不可以被类A的派生类进行改写 // void func_2() final &#123; /* ... */ &#125; /// func_2()不是虚函数，因此不能被final指定 // ...&#125;;class B final : public A // 将类B声明为final，即类B不能作为基类被继承&#123;public: // void func() &#123;&#125; /// func()已经在类A中声明为final了，不允许后续的类进行改写&#125;;/*class C : public B&#123; // ...&#125;;*///类B已经声明为final了，不允许后续的类对类B进行继承 纯虚函数虚函数可以通过如下的形式声明为纯虚函数。 1virtual returnType func(argument) = 0; 含有纯虚函数的类被称为抽象类，抽象类不允许定义具体的对象，定义抽象类的主要目的是为后续的派生类规定共性的接口。 纯虚函数可以在类外提供默认实现，示例如下： 123456789class Base&#123;public: virtual void func() = 0;&#125;;void Base::func()&#123; // ...&#125; 抽象类不允许定义对象，但允许定义抽象类的指针和引用并指向派生类对象，这样就保证只有指针和引用可以被向上类型转换。 当继承一个抽象类时，必须实现所有的纯虚函数，否则派生类仍然是一个抽象类，纯虚析构函数除外。 纯虚析构函数纯虚析构函数必须有函数体，即必须在抽象类的定义之外显式说明函数体。 定义纯虚析构函数的目的在于使基类成为抽象类，但若基类中有其他纯虚函数，则析构函数不必定义为虚的。 派生类中不需要显式实现纯虚析构函数，因为编译器可以自动合成析构函数。 1234567891011121314class Base&#123;public: virtual ~Base() = 0;&#125;;Base::~Base() &#123;&#125; // 纯虚析构函数必须显式说明函数体class A : public Base &#123;&#125;;int main()&#123; // Base b; /// 报错 A a; // 没有报错，但若没有显式说明基类中纯虚析构函数的函数体，则无法通过编译（编译阶段不会报错，错误在链接阶段产生）&#125; 向下类型转换基类指针或者引用转换为派生类指针或者引用被称为向下类型转换。要确保转换的正确性则必须借助虚函数表进行动态类型检查。示例如下： 1234567891011121314151617181920212223242526272829303132333435363738class Pet &#123; public: virtual ~Pet() &#123;&#125; &#125;;class Dog : public Pet&#123; public: void run() &#123; cout &lt;&lt; \"dog run\" &lt;&lt; endl; &#125;&#125;;class Bird : public Pet&#123;public: void fly() &#123; cout &lt;&lt; \"bird fly\" &lt;&lt; endl; &#125;&#125;;void action(Pet* p)&#123; auto d = dynamic_cast&lt;Dog*&gt;(p); /// 向下类型转换 auto b = dynamic_cast&lt;Bird*&gt;(p); /// 向下类型转换 if (d) /// 运行时根据实际类型表现特性 d-&gt;run(); else if(b) b-&gt;fly();&#125;int main()&#123; Pet* p[2]; p[0] = new Dog; /// 向上类型转换 p[1] = new Bird; /// 向上类型转换 for (int i = 0; i &lt; 2; ++i) &#123; action(p[i]); &#125;&#125; C++提供了一种安全的向下类型转换，即dynamic_cast，使用dynamic_cast必须有虚函数，因为它使用了存储在虚函数表中的信息判断实际的类型。 使用方法为： 1234// T1* obj_p = .....// T1&amp; obj_r = .....T2* pObj = dynamic_cast&lt;T2*&gt;(obj_p); //转换为T2指针，运行时失败返回nullptrT2&amp; refObj = dynamic_cast&lt;T2&amp;&gt;(obj_r); //转换为T2引用，运行时失败抛出bad_cast异常 要注意的是T1必须是带有虚函数（声明或者继承而来的）的类（T1必须是多态类型），否则编译会报错，T2不必是带有虚函数的类。T1，T2没有继承关系时转换会出错。 如果知道要转换的类型种类，可以使用static_ cast，static_cast在编译时静态浏览类层次，只检查继承关系。没有继承关系的类之间，必须具有转换途径才能进行转换（要么自定义，要么是语言语法支持），否则不过编译。运行时无法确认是否正确转换。 使用方法为： 1234// T1* obj_p = .....// T1&amp; obj_r = .....T2* pObj = static_cast&lt;T2*&gt;(obj_p); //转换为T2指针T2&amp; refObj = static_cast&lt;T2&amp;&gt;(obj_r); //转换为T2引用 static_cast不会做类型检查，因此不能保证转换后实际指向的对象类型为T2。 一般来说，建议使用dynamic_cast来进行向下类型转换。 几条重要的原则 指针或者引用的向上类型转换总是安全的。 向下类型转换时尽量使用dynamic_cast。 尽量不做对象的转换。 向上向下类型转换与虚函数表若基类中含有虚函数： 对于向上类型转换，派生类指针或者引用转换为基类指针或者引用，其虚函数表仍然绑定为派生类的虚函数表（晚绑定）。派生类对象转换为基类对象，则其虚函数表绑定为基类的虚函数表。 对于向下类型转换则可以通过检查虚函数表来判断是否可以进行向下类型转换。 多态以上所说的概念均是为多态所服务的，多态指的是：按照基类的接口定义，调用指针或引用所指对象的接口函数，函数执行过程因对象实际所属派生类的不同而呈现不同的效果（表现）。 当利用指针或者引用调用函数时，虚函数在运行时才确定具体的函数实现代码，取决于所指向对象的真实类型（晚绑定）。非虚函数在编译时就已进行绑定（早绑定）。 当利用对象作为参数直接调用函数时，无论什么函数均在编译时进行绑定。 所以产生多态的效果为：继承 &amp;&amp; 虚函数 &amp;&amp; （引用或指针） 多态使得C++语言可以用一段相同的代码，在运行时完成不同的任务，这些不同运行结果的差异由派生类之间的差异决定。好处在于通过基类定好接口后，不必对每一个派生类特殊处理，只需要调用抽象基类的接口即可。大大提高程序的可复用性。不同派生类对同一接口的实现不同，能达到不同的效果，提高了程序可拓展性和可维护性。 一个多态的示例如下： 123456789101112131415161718192021222324252627282930313233343536373839class Animal&#123; public: void action() &#123; speak(); motion(); &#125; virtual void speak() &#123; cout &lt;&lt; \"Animal speak\" &lt;&lt; endl; &#125; virtual void motion() &#123; cout &lt;&lt; \"Animal motion\" &lt;&lt; endl; &#125;&#125;;class Bird : public Animal&#123;public: void speak() &#123; cout &lt;&lt; \"Bird singing\" &lt;&lt; endl; &#125; void motion() &#123; cout &lt;&lt; \"Bird flying\" &lt;&lt; endl; &#125;&#125;;class Fish : public Animal&#123;public: void speak() &#123; cout &lt;&lt; \"Fish cannot speak ...\" &lt;&lt; endl; &#125; void motion() &#123; cout &lt;&lt; \"Fish swimming\" &lt;&lt; endl; &#125;&#125;;int main()&#123; Fish fish; Bird bird; fish.action(); ///不同调用方法 bird.action(); Animal *pBase1 = new Fish; Animal *pBase2 = new Bird; pBase1-&gt;action(); ///同一调用方法，根据 pBase2-&gt;action(); ///实际类型完成相应动作 return 0;&#125; 多态的一个典型应用就是TEMPLATE METHOD设计模式。 在接口的一个方法中定义算法的骨架。 将一些步骤的实现延迟到子类中。 使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。 多重继承一个类同时继承多个类称为多重继承。多重继承会有多个虚函数表，几重继承，就会有几个虚函数表。这些表按照派生的顺序依次排列。 如果子类改写了父类的虚函数，那么就会用子类自己的虚函数覆盖虚函数表的相应位置，如果子类有新的虚函数，那么就添加到第一个虚函数表的末尾。 多重继承的可以同时结合多个接口，但会导致二义性的问题，即派生类继承的两个基类若含有同名成员，则会导致编译器无法判断。另外一个问题则是钻石型继承带来的数据冗余问题。 实践中，最好只继承一个非抽象类，可以继承多个抽象类。 OOP核心思想OOP的核心思想是数据抽象、继承与动态绑定。 数据抽象：类的接口与实现分离 继承：建立相关类型的层次关系（基类与派生类）函数重写，虚函数 动态绑定：统一使用基类指针，实现多态行为类型转换，模板","categories":[],"tags":[{"name":"OOP","slug":"OOP","permalink":"http://believebest35.github.io/tags/OOP/"}]},{"title":"面向对象_组合与继承","slug":"OOP-THU-5","date":"2020-10-09T12:31:17.000Z","updated":"2020-10-13T12:17:07.990Z","comments":true,"path":"2020/10/09/OOP-THU-5/","link":"","permalink":"http://believebest35.github.io/2020/10/09/OOP-THU-5/","excerpt":"组合小的对象组合起来可以形成更大的对象，若对象a是对象b的一个组成部分，则可以说对象b是对象a的整体对象，对象a是对象b的部分对象。对象组合一般有两种实现方法： 将已有的类（对象a）定义为新定义的类（对象b）的公有成员，则可以通过访问原有的类提供旧的接口。 将已有的类定义为新定义的类的私有成员，这样新的类就必须提供新的接口用以访问旧的类，相当于对接口做了变换。","text":"组合小的对象组合起来可以形成更大的对象，若对象a是对象b的一个组成部分，则可以说对象b是对象a的整体对象，对象a是对象b的部分对象。对象组合一般有两种实现方法： 将已有的类（对象a）定义为新定义的类（对象b）的公有成员，则可以通过访问原有的类提供旧的接口。 将已有的类定义为新定义的类的私有成员，这样新的类就必须提供新的接口用以访问旧的类，相当于对接口做了变换。 以上的实现形式如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940class A&#123;private: int i;public: void set_i(int x) &#123; i = x; &#125;&#125;;class B&#123;private: int i;public: void set_i(int x) &#123; i = x; &#125;&#125;;class C&#123;private: A a;public: B b; void setA(int x) &#123; a.set_i(x); &#125;&#125;;int main()&#123; C c; c.b.set(0); c.setA(0);&#125; 子对象构造时若需要参数，则应在当前类的构造函数的初始化列表中进行初始化。 继承继承即是从一般到特殊的过程，若类A具有类B全部的数据成员以及对应的接口函数，除此之外还拥有一些自己独有的某些数据成员以及接口函数，则称类A继承与类B。 被继承的已有的类，被称为基类（base class），或者叫做父类。 继承定义出的新的类，被称为派生类（derived class），亦称作子类、扩展类。 常见的继承方式： public继承，定义形式如下所示： 1234class derived_class: public base_class&#123; // ...&#125; private继承，定义形式如下所示： 1234class derived_class: private base_class&#123; // ...&#125; private继承也是默认的继承方式。 protected继承，定义形式如下所示： 1234class derived_class: protected base_class&#123; // ...&#125; 最后一种继承方式很少使用。 派生类对象的构造和析构派生类对象的构造过程中首先初始化的是原属于基类的数据成员，需要调用原属于基类的构造函数来进行初始化。若没有显式调用则会自动调用属于基类的默认构造函数，若显式调用则只能在派生类的构造函数的初始化成员列表中进行调用。基类的数据成员初始化完毕之后再执行派生类的的构造函数。 对象析构时，派生类析构函数先执行，后续再执行基类的析构函数。 1234567891011121314class base&#123;private: int x;public: base(): x(0) &#123;&#125; base(int i): x(i) &#123;&#125;&#125;;class derived: public base&#123;public: derived(int i): base(i) &#123;&#125;&#125; 如上所示，派生类构造函数中显式调用基类的构造函数必须在初始化列表中进行。 继承基类构造函数在派生类中使用using Base::Base; 来继承基类构造函数，相当于给派生类“定义”了相应参数的构造函数。示例如下： 1234567891011121314151617181920class Base&#123; int data;public: Base(int i) : data(i) &#123;&#125; //Base(int i, int j) : data(i + j) &#123;&#125;&#125;;class Derive : public Base&#123;public: using Base::Base; ///相当于 Derive(int i):Base(i)&#123;&#125;; ///当基类存在多个构造函数时，使用using也会给派生类生成多个对应的构造函数，相当于 Derive(int i, int j):Base(i + j)&#123;&#125;&#125;;int main()&#123; Derive obj(356); return 0;&#125; 上述代码在c++11的情况下通过编译，mac自带的clang似乎不能通过编译。。 继承方式的选择 public继承 基类中的公有成员在派生类中仍然能保持公有，原有的接口仍能使用，是最为常用的一种继承方式。 private继承 通常很少使用，可通过组合替代。 protected继承 基本不使用，存在只是为了语言的完备性。 基类成员访问权限与三种继承方式 public继承 基类的公有成员，保护成员，私有成员作为派生类的成员时，都保持原有的状态。 private继承 基类的公有成员，保护成员，私有成员作为派生类的成员时，都作为私有成员。 protected继承 基类的公有成员，保护成员作为派生类的成员时，都成为保护成员，基类的私有成员仍然是私有的。 重写隐藏重写隐藏指的是在派生类中重新定义基类的函数，这样会屏蔽掉基类中的同名函数。 重写隐藏发生时基类中该同名函数的所有重载函数都会被屏蔽掉。可以在派生类中通过using 类名::成员函数名; 在派生类中“恢复”指定的基类成员函数（即去掉屏蔽），使之重新可用。 向上类型转换派生类对象/引用/指针转换成基类对象/引用/指针，称为向上类型转换，只对public继承有效。 凡是接受基类对象/引用/指针的地方（如函数参数），都可以使用派生类对象/引用/指针，编译器会自动将派生类对象转换为基类对象以便使用。 当派生类的对象(不是指针或引用)被转换为基类的对象时，派生类的对象被切片为对应基类的子对象，即会产生派生类对象数据的丢失。","categories":[],"tags":[{"name":"OOP","slug":"OOP","permalink":"http://believebest35.github.io/tags/OOP/"}]},{"title":"面向对象_引用与复制","slug":"OOP-THU-4","date":"2020-10-07T02:36:23.000Z","updated":"2020-10-13T12:17:47.854Z","comments":true,"path":"2020/10/07/OOP-THU-4/","link":"","permalink":"http://believebest35.github.io/2020/10/07/OOP-THU-4/","excerpt":"引用 引用是对于某个具体变量或者对象的别名，定义为：类型 &amp; 引用名 = 变量名，一个引用的定义示例如下： 12int a;int &amp;ra = a; 上述定义了一个指向变量a的引用ra，ra和a都是内存中统一单元的不同名字。引用在定义时必须进行初始化（即赋初值）。","text":"引用 引用是对于某个具体变量或者对象的别名，定义为：类型 &amp; 引用名 = 变量名，一个引用的定义示例如下： 12int a;int &amp;ra = a; 上述定义了一个指向变量a的引用ra，ra和a都是内存中统一单元的不同名字。引用在定义时必须进行初始化（即赋初值）。 函数的返回值也可以是引用类型，但是不能返回函数类的临时变量，否则编译器会抛出警告。 引用的优势： 更加灵活的支持运算符的重载。 创建时必须初始化，不存在空引用。 参数中的常量和常量引用某些函数在运行中仅仅需要用到参数的值而并不需要修改，因此可以通过传入常量引用的形式，限制子程序对传入的参数进行修改，示例如下： 12345void f(const int &amp;a, const int &amp;b)&#123; // a = 1; wrong // ...&#125; 上述函数中仅能读取参数a，b的值，并不允许修改。 拷贝构造函数拷贝构造函数是一类特殊的构造函数，其参数为同类对象的常量引用（不一定是常量引用？），一个典型的拷贝构造函数示例如下： 1234567891011121314class Sample&#123;private: int x, y; // ...public: Sample(const Sample &amp;S) &#123; x = S.x; y = S.y; // ... &#125; // ...&#125;; 拷贝构造函数一般在如下情况会被调用： 用一个类对象定义一个新的类对象，例如 123Sample s1;Sample s2(s1);Sample s3 = s1; 函数调用时以对象而不是引用作为参数。 函数返回类对象。 若类在定义时没有显式定义拷贝构造函数，编译器在需要时会自行产生拷贝构造函数，采用的形式为“位拷贝”（浅拷贝），即拷贝成员的地址而非内容，这就容易导致内存泄漏，特别是当数据成员之中含有指针类型的时候。 因此，程序设计中应该尽量减少使用拷贝构造函数。主要的解决方法有： 尽量使用引用/常量引用作为函数参数和函数返回类型。 将拷贝构造函数声明为private成员。 使用delete显式删除拷贝构造函数。 右值引用为此需要先说明左值和右值。 左值：可以取地址、有名字的值。 右值：不能取地址、没有名字的值，常见于常值、函数返回值以及表达式等。 举一个简单的栗子： 12345int a = 0, b = 0;int &amp;ra = a; // rightint *pa = &amp;a; // rightint &amp;ra_b = a + b; // wrongint *pa_b = &amp;(a + b); // wrong 后两个语句编译器会抛出错误，说明右值不能取地址以及被左值引用（&amp;）。 C++11中引入了右值引用的概念。右值引用的形式如下所示： 123int a = 0, b = 0;int &amp;&amp;ra_b = a + b; // rightint &amp;&amp;ra = a; // wrong 如示例所示，右值引用可以绑定到右值上，但不能绑定到左值上，即左值引用绑定左值，右值引用绑定右值，例外是左值常量引用可以绑定右值。 补充一个示例： 123456789void f(const int &amp;a)&#123; // ...&#125;int main()&#123; f(3);&#125; 以上示例不会抛出错误，说明常引用可以绑定到右值上（因为const保证了参数不会被修改）。 右值引用可以延长即将销毁变量的生命周期。 移动构造函数使用右值引用作为参数的构造函数叫做移动构造函数。 移动构造函数与拷贝构造函数最大的区别在于移动构造函数直接利用了原来临时对象中的堆内存，新的对象无需开辟内存，临时对象无需释放内存。 举一个简单的栗子： 12345678910111213141516171819202122232425262728class demo&#123;public: demo():num(new int(0)) &#123; cout&lt;&lt;\"construct!\"&lt;&lt;endl; &#125; //拷贝构造函数 demo(const demo &amp;d):num(new int(*d.num)) &#123; cout&lt;&lt;\"copy construct!\"&lt;&lt;endl; &#125; ~demo() &#123; cout&lt;&lt;\"class destruct!\"&lt;&lt;endl; &#125;private: int *num;&#125;;demo get_demo()&#123; return demo();&#125;int main()&#123; demo a = get_demo(); return 0;&#125; 以上的过程会多次调用拷贝构造函数，临时对象所占用的资源被浪费。 下面的示例引入了移动构造函数： 12345678910111213141516171819202122232425262728293031public: demo():num(new int(0)) &#123; cout&lt;&lt;\"construct!\"&lt;&lt;endl; &#125; demo(const demo &amp;d):num(new int(*d.num)) &#123; cout&lt;&lt;\"copy construct!\"&lt;&lt;endl; &#125; //添加移动构造函数 demo(demo &amp;&amp;d):num(d.num) &#123; d.num = NULL; cout&lt;&lt;\"move construct!\"&lt;&lt;endl; &#125; ~demo() &#123; cout&lt;&lt;\"class destruct!\"&lt;&lt;endl; &#125;private: int *num;&#125;;demo get_demo()&#123; return demo();&#125;int main()&#123; demo a = get_demo(); return 0;&#125; 移动构造函数采用了浅拷贝的方式，直接接管临时对象所占用的资源，避免了无谓的销毁以及申请资源的开销。 右值引用：移动语义有时候需要对左值调用移动构造函数，std提供了move() move可以解引用，即将左值转化为右值，原变量转化为未初始化状态。示例如下： 123Sample a;// ...Sample b = std::move(a); // a之后不会被使用 赋值运算符不同对象之间的赋值可通过重载赋值运算符来实现，示例如下： 12345678910111213141516class_name&amp; operator= (const class_name &amp;right)&#123; if (this != &amp;right) &#123; // ... 具体的赋值操作 &#125; return *this;&#125;int main()&#123; class_name a, b; // ... a = b; // 调用赋值运算 class_name c = a; // 拷贝构造&#125; 自动类型转换当出现对象类型不匹配的时候，需要进行类型转换，即实现从源类到目标类的转换，两个类之间的自动类型转换有如下两种实现方式： 在源类中定义目标类转换运算符，示例如下： 123456789101112class Src&#123;private: // ...public: operator Dst() const &#123; // ... return Dst(); &#125; &#125; 在目标类中定义以源类为参数的构造函数，示例如下： 12345678910class Dst&#123;private: // ...public: Dst(const Src &amp;s) &#123; // ... &#125;&#125; 以上方法只能同时使用一种，个人偏向于使用第二种。 使用关键字explicit可以禁止自动类型转换，即用explicit修饰类型转换运算符或类型转换构造函数，具体如下： 123explicit operator Dst() const;// or explicit Dst(const Src &amp;s); 强制类型转换C++提供了四种类型的强制类型转换。 const_cast，去除类型的const或volatile属性。 static_cast，类似于C风格的强制转换。无条件转换，静态类型转换。 dynamic_cast，动态类型转换。如子类和父类之间的多态类型转换。 reinterpret_cast，仅仅重新解释类型，但没有进行二进制的转换。 对于C++提供的强制类型转换详解需要另查资料。","categories":[],"tags":[{"name":"OOP","slug":"OOP","permalink":"http://believebest35.github.io/tags/OOP/"}]},{"title":"面向对象_创建与销毁","slug":"OOP-THU-3","date":"2020-10-06T11:29:33.000Z","updated":"2020-10-13T12:18:10.475Z","comments":true,"path":"2020/10/06/OOP-THU-3/","link":"","permalink":"http://believebest35.github.io/2020/10/06/OOP-THU-3/","excerpt":"构造函数对象的初始化工作是由对象的构造函数来完成的。构造函数没有返回值类型，函数名和类名一致，并且允许重载，一个典型的构造函数的定义示例如下： 1234567891011class Student&#123; long ID;public: Student(long id) &#123; ID = id; &#125; Student(int year, int order) &#123; ID = year * 10000 + order; &#125; // ...&#125;;","text":"构造函数对象的初始化工作是由对象的构造函数来完成的。构造函数没有返回值类型，函数名和类名一致，并且允许重载，一个典型的构造函数的定义示例如下： 1234567891011class Student&#123; long ID;public: Student(long id) &#123; ID = id; &#125; Student(int year, int order) &#123; ID = year * 10000 + order; &#125; // ...&#125;; 构造函数也可以类外进行定义。不带任何参数的构造函数被称为默认构造函数，或是缺省构造函数。 构造函数的初始化列表构造函数可以使用初始化列表来对类成员进行初始化。位置出现在函数体左花括号之前、函数参数列表圆括号之后，以冒号作开头，使用数据成员(初始值)的形式。示例如下： 1234567891011class Student&#123; long ID;public: Student(long id) ID(id) &#123;&#125; Student(int year, int order) &#123; ID = year * 10000 + order; &#125; // ...&#125;; 委派构造函数构造函数的初始化列表中还可以调用其他构造函数，被称为委派构造函数。 123456789101112class Info&#123;public: Info() &#123; Init(); &#125; Info(int i) : Info() &#123; id = i; &#125; Info(char c) : Info() &#123; gender = c; &#125;private: void Init() &#123; .... &#125;// 其他初始化 int id &#123;2016&#125;; char gender &#123;'M'&#125;; ...&#125;; 就地初始化C++11支持对于类中非静态成员变量进行如下的初始化： 12345678910class A&#123;private: int a = 1; double b &#123;2.0&#125;; public: A() &#123;&#125; A(int i):a(i) &#123;&#125; A(int i, double j): a(i),b(j) &#123;&#125;&#125;; 显式删除构造函数可以使用delete显式的删除的某些构造函数，以防止出现某些未预期的未定义行为。举一个栗子： 12345678910111213class A&#123;private: int a = 1; double b &#123;2.0&#125;; char c = 'c';public: A() = default; // 显式声明默认构造函数 A(int i):a(i) &#123;&#125; A(char ch) = delete; &#125;;A a('c'); //删除了以char进行初始化的构造函数，可以避免一些工程上的二义性问题，因为char型可以被转为int型，删除之后编译器将禁止这样的未定义行为。 析构函数对象的销毁是由对象的析构函数来完成的，析构函数只有一个，并且不需要任何参数，在对象的生命期结束时自动调用。定义形式为： ~&lt;类名&gt; 具体示例如下： 123456789101112class ClassRoom&#123; int num; long* ID_list;public: ClassRoom() : num(0), ID_list(0); &#123; &#125; // ... ~ClassRoom() &#123; // 析构函数 if (ID_list) delete[] ID_list; // 释放内存 &#125;&#125;; 对于申请动态内存的变量需要显式定义析构函数来释放空间。 类中的静态成员 staticstatic修饰的类成员变量被称为静态数据成员，为属于该类的所有对象所共有，即所有对象中的这个数据域处在同一内存位置。一个简单的示例如下： 12345678910class Sample&#123;private: int x, y; static int count;public: // ...&#125;;int Sample::count = 0; 如上定义了一个属于所有Sample类对象的静态数据成员count，其必须在类外进行初始化。在工程中更为规范的做法是将类的静态数据成员的声明放在.h（头文件）中，具体的初始化放在.cpp（实现文件）中。 成员函数也可以被static修饰，在返回值前面添加static修饰的成员函数，称为类的静态成员函数，一个简单的示例如下： 1234567891011121314class Sample&#123;private: int x, y; static int count;public: static int show_count() &#123; return count; &#125; // ...&#125;;int Sample::count = 0; 类的静态成员既可以通过类名进行访问，也可以通过具体的对象进行访问。 需要注意的是类的静态成员函数不能访问类的非静态数据成员，因为静态成员函数在对象进行初始化之前已经分配了内存空间，并且为所有对象所共有，而非静态数据成员只有在对象进行实例化时才分配具体的空间。 类中的常量成员 const使用const修饰的数据成员称为类的常量数据成员，在一个对象的生命期中不可以被修改。常量数据成员的初始化可以通过以下形式进行： 构造函数的初始化列表进行初始化 就地初始化（C++11的新特性） 注意，不能在构造函数的函数体中对对象的常量数据成员进行赋值。 类的成员函数也可以使用const进行修饰，被称为类的常量成员函数，该成员函数不能改变类的数据成员。 123456789101112class Sample&#123;private: const int x;public: Sample(): x(0) &#123;&#125; const int show_x() &#123; // x = 1; wrong，const修饰的函数不允许修改数据成员 return x; &#125;&#125;; 常量静态数据成员类的数据成员既可以定义为常量，也可以定义为静态的，常量静态数据成员需要在类外进行初始化（int 类型和enum类型除外）。 对象的构造与析构 局部对象的构造与析构 局部对象在程序执行到该局部对象的便进行构造，在其作用域结束时进行析构。 全局对象的构造与析构 全局对象在main函数调用之前进行构造，在main函数执行return之后进行析构。 一般来说程序中需要尽量少使用全局对象。 函数静态对象的构造与析构 函数静态对象是指在函数内部定义的static对象。在程序执行到该局部静态对象的代码时被初始化，离开作用域不析构，第二次执行到该对象代码时，不再初始化，直接使用上一次的对象，在main函数结束后被析构。 参数对象的构造与析构 若传递的是形参，在进入子函数时形参对象进行构造，在离开子函数时进行析构，若传递的是引用，在进入子函数时不进行构造，离开也不进行析构，因为传递的是一个变量的“别名”。 因此函数参数尽可能使用引用传递，可以避免大对象的拷贝。","categories":[],"tags":[{"name":"OOP","slug":"OOP","permalink":"http://believebest35.github.io/tags/OOP/"}]},{"title":"面向对象_封装与接口","slug":"OOP-THU-2","date":"2020-10-05T13:03:07.000Z","updated":"2020-10-13T12:25:52.667Z","comments":true,"path":"2020/10/05/OOP-THU-2/","link":"","permalink":"http://believebest35.github.io/2020/10/05/OOP-THU-2/","excerpt":"函数重载同一名称的函数，有两个以上不同的函数实现，被称为“函数重载”，例如 123456789void print(const char *msg)&#123; cout &lt;&lt; \"message: \" &lt;&lt; msg &lt;&lt; endl;&#125;void print(int score)&#123; cout &lt;&lt; \"score = \" &lt;&lt; score &lt;&lt; endl;&#125;","text":"函数重载同一名称的函数，有两个以上不同的函数实现，被称为“函数重载”，例如 123456789void print(const char *msg)&#123; cout &lt;&lt; \"message: \" &lt;&lt; msg &lt;&lt; endl;&#125;void print(int score)&#123; cout &lt;&lt; \"score = \" &lt;&lt; score &lt;&lt; endl;&#125; 编译器将根据函数调用语句的实际参数来决定哪一个函数被调用，多个同名的函数实现之间必须保证至少有一个参数的类型不一样。 函数在定义时可以指定参数的默认值，程序在调用时若不提供参数则会使用默认的参数值，例如： 1234void print(const char *msg = \"hello world\")&#123; cout &lt;&lt; msg &lt;&lt; endl;&#125; 一些基础知识autoauto类型可以根据变量的上下文自动推断变量的类型。例如： 12auto i = 3; // i为整型auto a = 4.0f; // a为浮点数类型 追踪返回类型的函数可以将函数返回类型的声明信息放到函数参数列表的后面进行声明，如： 12345// 普通函数声明形式int func(char* ptr, int val);// 追踪返回类型的函数声明形式auto func(char* ptr, int val) -&gt; int; 追踪返回类型在原本函数返回值的位置使用auto关键字。 decltypedecltype可以对变量或表达式结果的类型进行推导，可以用来重用匿名类型，在泛型编程中结合auto，可用于追踪函数的返回值类型，如： 12345678struct &#123; int a;&#125; s;int main()&#123; decltype(s) s1; // 定义了一个与s同类型的结构体变量&#125; 结合auto和decltype可以推到函数的返回类型，一般用在泛型编程之中。 12345template &lt;typename _Tx, typename _Ty&gt;auto multiply(_Tx x, _Ty y) -&gt; decltype(_Tx * _Ty)&#123; return x * y;&#125; new / deletenew和delete运算符可以在程序运行过程中动态的申请和释放内存空间，如下： 1234int *a = new int; // 申请一个整型变量的空间int *arr = new int[10]; // 申请大小为10的整型数组空间delete a; //删除申请的单个变量delete[] arr; //删除申请的连续内存区域 nullptrC++11引入了nullptr，之前使用NULL表示空指针，NULL被定义为0，可以被视为一个整型变量，因此如下的代码会出现问题： 12345678910111213141516void f(int x, int y)&#123; //...&#125;void f(int x, double *y)&#123; //...&#125;int main()&#123; //... f(2, NULL); // wrong f(2, nullptr); // right&#125; 以上的代码会出现错误，因为在使用NULL表示空指针的时候常常容易忽略NULL也是一个int型常量，而nullptr表示严格意义上的空指针，因此不会出现二义性的错误。 基于范围的for循环举例说明： 12345678void f(vector&lt;int&gt; &amp;nums)&#123; for (auto num : nums) &#123; //... &#125; // 以上可以自动的遍历vector，同理可以推广到其他可迭代类型&#125; 对象对象具有静态特性以及动态特性。 静态特征：可以用某种数据来描述的属性 动态特征：对象表现的行为或具有的功能 用户自定义类型class一个class的定义示例如下： 123456789101112// matrix.h#ifndef __MATRIX_H__#define __MATRIX_H__class Matrix&#123;private: int data[6][6];public: void fill(char dir);&#125;;#endif 成员函数的声明一般放在类定义中，具体实现一般放在实现文件中，例如： 1234567// matrix.cpp#include \"matrix.h\"void Matrix::fill(char dir) //类外需要类名限定&#123; ... // 函数实现&#125; 成员函数的实现也可以放在类定义中，放在类定义中的成员函数会自动内联。 类的成员（数据、函数）可以根据需要分成组，不同组设置不同的访问权限。 public public修饰的成员可以在类外用“.”操作符访问。 private private是不指定成员访问权限时的默认权限，不可以在类外使用“.”运算符进行访问。 protected 有关继承时再进行讨论。 this指针所有成员函数的参数中，隐含着一个指向当前对象的指针变量，其名称为this。 12345678910class Matrix&#123;public: void fill(char dir) &#123; //... this -&gt; data[0][0] = 1; //等价于 data[0][0] = 1; &#125; ...&#125;; 类的运算符重载以一个例子进行说明，类定义如下： 12345678910111213141516171819202122232425class Sample&#123;private: int x, y; static int count;public: Sample(); Sample(int x1, int x2, int y1, int y2): x(x1 + x2), y(y1 + y2) &#123;&#125; Sample(int x1, int y1); ~Sample(); void change_x_y(int x1, int y1); friend Sample operator+ (const Sample &amp;s1, const Sample &amp;s2); // +的重载 声明为友元函数 Sample&amp; operator+= (Sample &amp;s); // += 的重载 friend istream&amp; operator&gt;&gt; (istream &amp;in, Sample &amp;dst); // &gt;&gt;的重载 声明为友元函数 friend ostream&amp; operator&lt;&lt; (ostream &amp;out, Sample &amp;src); // &lt;&lt;的重载 声明为友元函数 void display(); void display_cnt() &#123; count++; cout &lt;&lt; count &lt;&lt; endl; &#125;&#125;;int Sample::count = 0; 运算符+和+=的重载实现如下： 1234567891011121314Sample&amp; Sample::operator+=(Sample &amp;s)&#123; this -&gt; x += s.x; this -&gt; y += s.y; return *this;&#125;Sample operator+ (const Sample &amp;s1, const Sample &amp;s2)&#123; Sample sum; sum.x = s1.x + s2.x; sum.y = s1.y + s2.y; return sum;&#125; 流运算符的重载（&gt;&gt; , &lt;&lt;） 1234567891011istream&amp; operator&gt;&gt; (istream &amp;in, Sample &amp;dst)&#123; in &gt;&gt; dst.x &gt;&gt; dst.y; return in;&#125;ostream&amp; operator&lt;&lt; (ostream &amp;out, Sample &amp;src)&#123; out &lt;&lt; src.x &lt;&lt; \" \" &lt;&lt; src.y; return out;&#125; 关于更多的特殊运算符重载可以查询资料 友元在上面的运算符重载声明中出现了friend关键字，friend可以将外部的一些函数或者类声明为友元，声明为友元的函数或者类可以访问该类的一切成员，不受private关键字的影响。 友元不传递，即朋友的朋友不是你的朋友。 友元不继承，即朋友的孩子不是你的朋友。 友元声明不能定义新的class。 内联函数使用内联函数，编译器在编译时会自动生成与函数等价的表达式语句，从而减少函数调用的开销。例如； 123456789101112inline int max(int a, int b)&#123; return a &gt; b ? a : b;&#125;int main()&#123; int a, b; // ... // cout &lt;&lt; max(a, b) &lt;&lt; endl; 实际会被优化为如下语句 cout &lt;&lt; a &gt; b ? a : b &lt;&lt; endl;&#125;","categories":[],"tags":[{"name":"OOP","slug":"OOP","permalink":"http://believebest35.github.io/tags/OOP/"}]},{"title":"面向对象_编程环境基础","slug":"OOP-THU-1","date":"2020-10-05T08:34:31.000Z","updated":"2020-10-13T12:26:23.740Z","comments":true,"path":"2020/10/05/OOP-THU-1/","link":"","permalink":"http://believebest35.github.io/2020/10/05/OOP-THU-1/","excerpt":"以下关于面向对象课程资料的内容来源于清华大学刘知远老师开设的面向对象程序设计基础课程， 课程资料 编译和链接C++源程序变为目标平台上的可执行程序需要经过编译器以及链接器。 编译器：首先将源代码解析为语法分析树，再根据语法分析树生成对应的中间代码或直接生成对应平台的汇编码、机器码，即生成目标文件。 链接器：将目标模块链接为可执行程序。","text":"以下关于面向对象课程资料的内容来源于清华大学刘知远老师开设的面向对象程序设计基础课程， 课程资料 编译和链接C++源程序变为目标平台上的可执行程序需要经过编译器以及链接器。 编译器：首先将源代码解析为语法分析树，再根据语法分析树生成对应的中间代码或直接生成对应平台的汇编码、机器码，即生成目标文件。 链接器：将目标模块链接为可执行程序。 g++ -c 只编译不链接 g++ -o 链接目标程序 12345678910111213141516171819202122--- Desktop/oop_test » lsmain.cpp--- Desktop/oop_test » cat main.cpp#include&lt;iostream&gt;using namespace std;int main()&#123; cout &lt;&lt; \"hello world\" &lt;&lt; endl; return 0;&#125;--- Desktop/oop_test » lsmain.cpp--- Desktop/oop_test » g++ -c main.cpp--- Desktop/oop_test » lsmain.cpp main.o--- Desktop/oop_test » g++ -o main.out main.o--- Desktop/oop_test » lsmain.cpp main.o main.out--- Desktop/oop_test » ./main.outhello world--- Desktop/oop_test » 宏定义 简单的宏定义：#define &lt;宏名&gt; &lt;字符串&gt; 如 1#define PI 3.14 // 不建议使用宏定义，建议使用const定义常量 带参数的宏定义：#define &lt;宏名&gt; (&lt;参数表&gt;) &lt;字符串&gt; 如 1#define sqr(x) ((x) * (x)) 防止头文件的重复包含 1234#ifndef __BODYDEF_H__#define __BODYDEF_H__// 头文件#endif 防止头文件的重复包含也可以采用如下方式： 1#pragma once 以上保证所有文件不会被编译两次 用于Debug输出 12345#ifdef 标识符 // 程序段1#else // 程序段2#endif MAKE工具MAKE工具是使得大型工程编译工程自动化的一种工具，相当于一个脚本集合。 关于Make命令的具体教程可以参见Make命令教程 格式： 12&lt;target&gt;: prerequisites&lt;tab&gt; command 其中target表示目标文件，target不能为空。prerequisites表示target所依赖的文件，可以为空。 prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。 一个简单的栗子，假设makefile文件编写如下 12345678910source: a.txt b.txt c.txtb.txt: echo \"this is a test\" &gt; b.txtc.txt: echo \"this is a test2\" &gt; c.txta.txt: b.txt c.txt cat b.txt c.txt &gt; a.txt 终端中输入make便会执行第一条命令，即make source 123456789--- Desktop/oop_test » lsmain.cpp main.o main.out makefile--- Desktop/oop_test » make sourceecho \"this is a test\" &gt; b.txtecho \"this is a test2\" &gt; c.txtcat b.txt c.txt &gt; a.txt--- Desktop/oop_test » lsa.txt b.txt c.txt main.cpp main.o main.out makefile--- Desktop/oop_test » 也可以显式指定要执行的命令，例如make b.txt 1234567--- Desktop/oop_test » lsmain.cpp main.o main.out makefile--- Desktop/oop_test » make b.txtecho \"this is a test\" &gt; b.txt--- Desktop/oop_test » lsb.txt main.cpp main.o main.out makefile--- Desktop/oop_test » 常常利用make来管理大型工程的编译过程，更多关于make的高级过程可查询教程。 C++程序命令行参数main函数可接受来自命令行的参数，例如 12345int main(int argc, char** argv)&#123; // .. return 0;&#125; 其中argc中存储的是命令行参数的个数，argv则以C风格字符串的形式保存参数，其中包含了可执行程序文件的名称本身，举一个栗子：main函数如下： 123456789#include&lt;iostream&gt;using namespace std;int main(int a, char ** b)&#123; cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; b[0] &lt;&lt; endl; cout &lt;&lt; \"hello world\" &lt;&lt; endl;&#125; 终端执行结果如下 12345678910--- Desktop/oop_test » lsmain.cpp main.o main.out--- Desktop/oop_test » g++ main.cppls% --- Desktop/oop_test » lsa.out main.cpp main.o main.out--- Desktop/oop_test » ./a.out 1 1 1 1 16./a.outhello world--- Desktop/oop_test »","categories":[],"tags":[{"name":"OOP","slug":"OOP","permalink":"http://believebest35.github.io/tags/OOP/"}]},{"title":"数据结构基础","slug":"data-structure-post-1","date":"2020-09-15T07:16:12.000Z","updated":"2020-10-13T12:28:17.751Z","comments":true,"path":"2020/09/15/data-structure-post-1/","link":"","permalink":"http://believebest35.github.io/2020/09/15/data-structure-post-1/","excerpt":"数据结构基础绪论数据结构数据结构描绘数据元素以及数据元素之间的关系。 算法的特性 有穷性 确定性 可行性 有输入（不一定） 有输出","text":"数据结构基础绪论数据结构数据结构描绘数据元素以及数据元素之间的关系。 算法的特性 有穷性 确定性 可行性 有输入（不一定） 有输出 线性表线性表是具有相同特性的数据元素的的一个有限序列，一般实现方式有两种： 顺序实现，c++中的数组类型就是对于线性表的顺序实现。 链表实现，即各个元素之间的不是连续的，需要额外存储下一个元素的所在位置。 单链表 双链表 循环链表 … 有序表有序表指的是元素以递增或者递减的方式排列的线性表，需要注意两个有序表的归并排序，即分别使用两个指针扫描两个子线性表，选择其中较小（假设递增排序）的元素归并到新的有序表中。 vectorc++的标准模版库中封装了vector类型，可十分方便的操作线性排列的元素。 123456789101112131415#include &lt;vector&gt;vector&lt;int&gt; v(10); // 初始化具有10个空间的线性表vector&lt;int&gt; v_2(10, 1) //初始化具有10个空间的线性表，每个元素的初始值为1int a = v[1]; //下标访问v.push_back(1);v.pop_back();v.clear(); // 清除所有元素v.erase(v.begin() + 1); // 删除一个元素v.erase(v.begin() + 1, v.begin() + 5) // 删除一段元素v.back();v.front();v.empty();v.size();// ... 栈只能在一端进行插入和删除的线性表，后进先出（FILO） 主要操作： 123456789#include &lt;stack&gt;stack&lt;int&gt; st;st.push(10);st.top();st.pop();st.empty();st.size(); 栈的一些应用 中缀表达式转后缀表达式 后缀表达式求值 … 队列只能在一端进行插入，另外一段进行删除的线性表，先进先出（LILO） 主要操作 12345678910#include &lt;queue&gt;queue&lt;int&gt; que;que.push(1);que.front();que.back();que.pop();que.size();que.empty(); 队列相关的应用 约瑟夫环问题 … 双端队列两端都可以进行插入和删除的线性表 123456789101112131415#include &lt;deque&gt;deque&lt;int&gt; deq; // vector加强版deq.empty();deq.push_front(1);deq.pop_front();deq.push_back(1);deq.pop_back(;deq.back();deq.front();deq.size();deq.clear();deq.insert(); // 同vector的插入deq.erase(deq.begin() + 4); 串的模式匹配 KMP串的模式匹配指的是给定两个字符串T和P，在主串T中找出第一次出现完整子串P的位置，一般的暴力解法如下： 1234567891011121314151617181920212223int brute_force_match(string T, string P)&#123; if (T == \"\" || P == \"\") return -1; int i = 0, j = 0; while (i &lt; T.size() &amp;&amp; j &lt; P.size()) &#123; if (T[i] == P[j]) &#123; i++; j++; &#125; else &#123; i = i - j + 1; j = 0; &#125; &#125; if (j == P.size()) return i - j; else return -1;&#125; 假设T串长m，P串长n，则暴力算法时间复杂度为O(m * n)。 KMP算法则可以将以上的匹配过程加速至O(m + n), KMP算法的核心在于保持匹配过程中i指针的位置不变，修改j指针，使得模式串尽量移动到有效的位置。 具体的讲解可见KMP算法讲解 举一个栗子，以主串ABCABCDHIJK和模式串ABCABB的匹配为例： A B C A B C D H I J K i A B C A B B j 当i指向T中第5个（以0开始标记）元素，j指向P中第5个元素，发生冲突，注意到已经匹配的部分ABCAB的前缀AB和后缀AB是一致的，因此可以跳过再次匹配这一部分的过程，维持i不变，将j移动到P中的第二个位置继续进行匹配。 以上的过程需要求已经匹配部分的前缀和后缀的最长公共部分的长度，并保存在next数组中，next[j]即表示发生冲突时j指针应该移动到的位置。 next数组的具体求法如下： 123456789101112131415161718vector&lt;int&gt; get_next(string P)&#123; vector&lt;int&gt; next(P.size()); next[0] = -1; // 规定next数组的第0位为-1 int j = 0, k = -1; while (j &lt; P.size() - 1) &#123; if (k == -1 || P[k] == P[j]) &#123; j++; k++; next[j] = k; &#125; else k = next[k]; &#125; return next;&#125; 求出next数组之后即可应用KMP算法 1234567891011121314151617181920212223int KMP_match(string T, string P)&#123; if (T == \"\" || P == \"\") return -1; vector&lt;int&gt; next = get_next(P); int i = 0, j = 0; while (i &lt; T.size() &amp;&amp; j &lt; P.size()) &#123; if (j == -1 || T[i] == P[j]) &#123; i++; j++; &#125; else &#123; j = next[j]; &#125; &#125; if (j == P.size()) return i - j; else return -1;&#125; 二叉树二叉树是一种树状的数据结构，二叉树的递归遍历相对比较简单 递归遍历的统一模版如下：12345678910void treeTravel(ListNode *node)&#123; if (node == nullptr) return; cout &lt;&lt; node -&gt; val; // 前序遍历 treeTravel(node -&gt; left); // cout &lt;&lt; node -&gt; val; // 中序遍历 treeTravel(node -&gt; right); // cout &lt;&lt; node -&gt; val; // 后序遍历&#125; 对于二叉树的非递归遍历，前中后序遍历实现形式不同，但也可以统一为一个形式,采用记号进行标记 先给出前序以及中序遍历的非统一非递归实现 前序遍历的非递归实现：1234567891011121314151617void pre_travel(ListNode *node)&#123; if (node == nullptr) return; stack&lt;ListNode*&gt; st; st.push(node); while (!st.empty()) &#123; ListNode *temp = st.top(); cout &lt;&lt; temp -&gt; val; st.pop(); if (temp -&gt; right != nullptr) st.push(temp -&gt; right); if (temp -&gt; left != nullptr) st.push(temp -&gt; left); &#125;&#125; 中序遍历的非递归实现：1234567891011121314151617void in_travel(ListNode *node)&#123; ListNode *cur = node; stack&lt;ListNode*&gt; st; while (cur != nullptr || !st.empty()) &#123; while (cur != nullptr) &#123; st.push(cur); cur = cur -&gt; left; &#125; cur = st.top(); st.pop(); cout &lt;&lt; cur -&gt; val; cur = cur -&gt; right; &#125;&#125; 后序遍历的非递归实现相较于前序以及中序的较为麻烦，不过可以将前两者的代码统一为一个形式 后续遍历的非递归实现：1234567891011121314151617181920212223void post_travel(ListNode *node)&#123; if (node == nullptr) return; stack&lt;pair&lt;ListNode*, int&gt;&gt; st; st.push(make_pair(node, 0)); while (!st.empty()) &#123; ListNode *temp = st.top().first; int flag = st.top().second; st.pop(); if (flag == 0) &#123; st.push(make_pair(temp, 1)); if (temp -&gt; right != nullptr) st.push(make_pair(temp -&gt; right, 0)); if (temp -&gt; left != nullptr) st.push(make_pair(temp -&gt; left, 0)); &#125; else cout &lt;&lt; temp -&gt; val; &#125;&#125; 调整以上的入栈顺序即可实现前序以及中序遍历。 二叉树的层次遍历比较简单，结合队列进行广搜即可。 并查集并查集是一种用于解决元素分组的数据结构，主要用于解决元素分组以及合并的问题，支持的操作包括find以及union。 find 查询两个元素是否在同一个集合中 union 将两个不相交的集合进行合并 初始化1234567int fa[MAX];inline void init(int n)&#123; for (int i = 1; i &lt;= n; i++) fa[i] = i;&#125; 即最开始每个元素分别所属不同的集合。 查询1234567int find(int x)&#123; if(fa[x] == x) return x; else return find(fa[x]);&#125; 合并1234inline void merge(int i, int j)&#123; fa[find(i)] = find(j);&#125; 其中合并可以进行优化，即进行路径压缩 123456789101112131415int find(int x)&#123; if(x == fa[x]) return x; else&#123; fa[x] = find(fa[x]); //父节点设为根节点 return fa[x]; //返回父节点 &#125;&#125;// 简化为一行的写法int find(int x)&#123; return x == fa[x] ? x : (fa[x] = find(fa[x]));&#125; 并查集的按秩合并优化初始化（按秩合并） 12345678inline void init(int n)&#123; for (int i = 1; i &lt;= n; ++i) &#123; fa[i] = i; rank[i] = 1; &#125;&#125; 合并（按秩合并） 12345678910inline void merge(int i, int j)&#123; int x = find(i), y = find(j); //先找到两个根节点 if (rank[x] &lt;= rank[y]) fa[x] = y; else fa[y] = x; if (rank[x] == rank[y] &amp;&amp; x != y) rank[y]++; //如果深度相同且根节点不同，则新的根节点的深度+1&#125; 图图的存储方式 邻接矩阵 邻接表 十字链表 邻接多重表 链式前向星 … 图的遍历 BFS DFS 最小生成树 普里姆算法 克鲁斯卡尔算法 最短路算法 Dijkstra(单源最短路) Floyd 拓扑排序依次寻找入度为0的节点即可 查找顺序查找时间复杂度为O(N),对线性表无特殊限制。 二分查找时间复杂度为O(logN),需要线性表有序。 123456789101112131415int binary_search(vector&lt;int&gt; nums, int target)&#123; int l = 0, r = nums.size() - 1; while (l &lt;= r) &#123; int mid = (l + r) / 2; if (nums[mid] == target) return mid; else if (nums[mid] &lt; target) l = mid + 1; else r = mid - 1; &#125; return -1;&#125; B树 B+树B树和B+树都是一般用于外查找的数据结构。 B树一棵m阶B树(balanced tree of order m)是一棵平衡的m路搜索树。它或者是空树，或者是满足下列性质的树： 根结点至少有两个子女； 每个非根节点所包含的关键字个数 j 满足：┌m/2┐ - 1 &lt;= j &lt;= m - 1； 除根结点以外的所有结点（不包括叶子结点）的度数正好是关键字总数加1，故内部子树个数 k 满足：┌m/2┐ &lt;= k &lt;= m ； 所有的叶子结点都位于同一层。在B-树中，每个结点中关键字从小到大排列，并且当该结点的孩子是非叶子结点时，该k-1个关键字正好是k个孩子包含的关键字的值域的分划。 以上内容摘自百度百科。 B+树to do 排序插入排序1234567891011void insert_sort(vector&lt;int&gt; &amp;nums)&#123; for (int i = 1; i &lt; nums.size(); i++) &#123; int temp = nums[i]; int j; for (j = i - 1; j &gt;= 0 &amp;&amp; nums[j] &gt; temp; j--) nums[j + 1] = nums[j]; nums[j + 1] = temp; &#125;&#125; 时间复杂度为O(n^2) 希尔排序希尔排序需要选择增量对数据进行分组，分完组的各部分分别使用插排，最后直到增量为1 冒泡排序1234567891011121314151617void bubble_sort(vector&lt;int&gt; &amp;nums)&#123; for (int i = 0; i &lt; nums.size() - 1; i++) &#123; bool exchange = false; for (int j = nums.size() - 1; j &gt; i; j--) &#123; if (nums[j] &lt; nums[j - 1]) &#123; swap(nums[j], nums[j - 1]); exchange = true; &#125; &#125; if (!exchange) return; &#125;&#125; 时间复杂度为O(n^2) 选择排序1234567891011void select_sort(vector&lt;int&gt; &amp;nums)&#123; for (int i = 0; i &lt; nums.size(); i++) &#123; int min_pos = i; for (int j = i + 1; j &lt; nums.size(); j++) if (nums[j] &lt; nums[min_pos]) min_pos = j; swap(nums[i], nums[min_pos]); &#125;&#125; 时间复杂度为O(n^2) 快速排序1234567891011121314151617181920212223242526int partition(vector&lt;int&gt; &amp;nums, int l, int r)&#123; int temp = nums[l]; while (l &lt; r) &#123; while (l &lt; r &amp;&amp; nums[r] &gt;= temp) r--; nums[l] = nums[r]; while (l &lt; r &amp;&amp; nums[l] &lt;= temp) l++; nums[r] = nums[l]; &#125; nums[l] = temp; return l;&#125;void quick_sort(vector&lt;int&gt; &amp;nums, int l, int r)&#123; if (l &lt; r) &#123; int i = partition(nums, l, r); quick_sort(nums, l, i - 1); quick_sort(nums, i + 1, r); &#125;&#125; 以上的快速排序没有做随机化处理，更加正统的写法应该随机化选择枢纽元素。平均时间复杂度为O(NlogN) 堆排序利用堆的性质进行排序，stl中提供了优先队列，可直接用于排序。关于具体的堆的实现可以百度。。。 归并排序123456789101112131415161718192021222324252627282930313233343536373839404142434445void merge(int *data,int start,int end,int *result) &#123; int left_length = (end - start + 1) / 2 + 1; int left_index = start; int right_index = start + left_length; int result_index = start; while(left_index&lt;start + left_length &amp;&amp; right_index &lt;end + 1) //store data into new array &#123; if(data[left_index] &lt;= data[right_index]) result[result_index++] = data[left_index++]; else result[result_index++] = data[right_index++]; &#125; while(left_index &lt; start + left_length) result[result_index++] = data[left_index++]; while(right_index &lt;end+1) result[result_index++] = data[right_index++];&#125; void merge_sort(int *data,int start,int end,int *result)&#123; if(1 == end - start) //last only two elements &#123; if(data[start] &gt; data[end]) &#123; int temp = data[start]; data[start] = data[end]; data[end] = temp; &#125; return; &#125; else if (end == start) return; //last one element then there is no need to sort; else&#123; //continue to divide the interval merge_sort(data, start, (end - start + 1) / 2 + start, result); merge_sort(data, (end - start + 1) / 2 + start + 1, end, result); //start to merge sorted data merge(data, start, end, result); for (int i = start; i &lt;= end;++i) &#123; data[i] = result[i]; &#125; &#125;&#125;","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://believebest35.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"leetcode 60 第k个排列","slug":"leetcode-solution-7","date":"2020-09-05T07:14:39.000Z","updated":"2020-10-13T12:26:34.437Z","comments":true,"path":"2020/09/05/leetcode-solution-7/","link":"","permalink":"http://believebest35.github.io/2020/09/05/leetcode-solution-7/","excerpt":"Leetcode 60 第k个排列leetcode 60 题目描述给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下： “123” “132” “213” “231” “312” “321”","text":"Leetcode 60 第k个排列leetcode 60 题目描述给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下： “123” “132” “213” “231” “312” “321” 给定 n 和 k，返回第 k 个排列。 说明： 给定 n 的范围是 [1, 9]。 给定 k 的范围是[1, n!]。 示例输入: n = 3, k = 3输出: “213” 输入: n = 4, k = 9输出: “2314” 解法依次固定每一位的取值即可,注意是从0开始计数的因此k需要减1，当k到0的时候就可以直接将剩下的数字直接接在最后。 123456789101112131415161718192021class Solution&#123;public: string getPermutation(int n, int k) &#123; vector&lt;int&gt; fac = &#123;0, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880&#125;; string s = string(\"123456789\").substr(0, n); k--; string ans = \"\"; while (k &gt; 0) &#123; int id = k / fac[n - 1]; ans += s[id]; s.erase(s.begin() + id); k %= fac[n - 1]; n--; &#125; ans += s; return ans; &#125;&#125;;","categories":[],"tags":[{"name":"leetcode_solution","slug":"leetcode-solution","permalink":"http://believebest35.github.io/tags/leetcode-solution/"}]},{"title":"leetcode 329 矩阵中的最长递增路径","slug":"leetcode-solution-6","date":"2020-07-26T16:02:08.000Z","updated":"2020-10-13T12:26:55.116Z","comments":true,"path":"2020/07/27/leetcode-solution-6/","link":"","permalink":"http://believebest35.github.io/2020/07/27/leetcode-solution-6/","excerpt":"Leetcode 329 矩阵中的最长递增路径leetcode 329 题目描述给定一个整数矩阵，找出最长递增路径的长度。 对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外（即不允许环绕）","text":"Leetcode 329 矩阵中的最长递增路径leetcode 329 题目描述给定一个整数矩阵，找出最长递增路径的长度。 对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外（即不允许环绕） 示例输入: nums = [9,9,4] [6,6,8] [2,1,1]输出: 4解释: 最长递增路径为 [1, 2, 6, 9]。 输入: nums = [3,4,5] [3,2,6] [2,2,1]输出: 4解释: 最长递增路径是 [3, 4, 5, 6]。注意不允许在对角线方向上移动。 方法：DFS这道题明显可以用dfs来写，不过最朴素的dfs（不带剪枝）会超时，因此需要简单的剪枝。或者可以写成记忆化递归的形式。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution&#123;public: int m, n; int ans; void dfs(vector&lt;vector&lt;int&gt;&gt; &amp;matrix, vector&lt;vector&lt;int&gt;&gt; &amp;dp, int x, int y) &#123; if (x &gt;= 1 &amp;&amp; matrix[x - 1][y] &gt; matrix[x][y] &amp;&amp; dp[x - 1][y] &lt; dp[x][y] + 1) &#123; dp[x - 1][y] = dp[x][y] + 1; ans = max(ans, dp[x - 1][y]); dfs(matrix, dp, x - 1, y); &#125; if (x &lt; m - 1 &amp;&amp; matrix[x + 1][y] &gt; matrix[x][y] &amp;&amp; dp[x + 1][y] &lt; dp[x][y] + 1) &#123; dp[x + 1][y] = dp[x][y] + 1; ans = max(ans, dp[x + 1][y]); dfs(matrix, dp, x + 1, y); &#125; if (y &gt;= 1 &amp;&amp; matrix[x][y - 1] &gt; matrix[x][y] &amp;&amp; dp[x][y - 1] &lt; dp[x][y] + 1) &#123; dp[x][y - 1] = dp[x][y] + 1; ans = max(ans, dp[x][y - 1]); dfs(matrix, dp, x, y - 1); &#125; if (y &lt; n - 1 &amp;&amp; matrix[x][y + 1] &gt; matrix[x][y] &amp;&amp; dp[x][y + 1] &lt; dp[x][y] + 1) &#123; dp[x][y + 1] = dp[x][y] + 1; ans = max(ans, dp[x][y + 1]); dfs(matrix, dp, x, y + 1); &#125; &#125; int longestIncreasingPath(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; m = matrix.size(); if (m == 0) return 0; ans = 1; n = matrix[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 1)); for (int i = 0; i &lt; m; i++) for (int j = 0; j &lt; n; j++) dfs(matrix, dp, i, j); return ans; &#125;&#125;;","categories":[],"tags":[{"name":"leetcode_solution","slug":"leetcode-solution","permalink":"http://believebest35.github.io/tags/leetcode-solution/"}]},{"title":"leetcode 322 零钱兑换 and leetcode 410 分割数组的最大值","slug":"leetcode-solution-5","date":"2020-07-25T08:03:33.000Z","updated":"2020-10-13T12:27:06.506Z","comments":true,"path":"2020/07/25/leetcode-solution-5/","link":"","permalink":"http://believebest35.github.io/2020/07/25/leetcode-solution-5/","excerpt":"Leetcode 322 零钱兑换leetcode 322 题目描述给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。 示例输入: coins = [1, 2, 5], amount = 11输出: 3解释: 11 = 5 + 5 + 1 输入: coins = [2], amount = 3输出: -1","text":"Leetcode 322 零钱兑换leetcode 322 题目描述给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。 示例输入: coins = [1, 2, 5], amount = 11输出: 3解释: 11 = 5 + 5 + 1 输入: coins = [2], amount = 3输出: -1 说明你可以认为每种硬币的数量是无限的。 方法一：DFS这是一道典型的可以用dfs来做的题，但。。。他T了 12345678910111213141516171819202122232425262728293031class Solution&#123;public: int ans; void dfs(vector&lt;int&gt; &amp;coins, int amount, int count) &#123; if (amount == 0) &#123; if (ans == -1) ans = count; else ans = min(ans, count); return; &#125; if (amount &lt; 0) return; for (int i = coins.size() - 1; i &gt;= 0; i--) dfs(coins, amount - coins[i], count + 1); &#125; int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123; // sort(coins.begin(), coins.end()); ans = -1; dfs(coins, amount, 0); return ans; &#125;&#125;; 方法二：DPDP状态很好设置，dp[i]即表示组成金额为i的所需最小金币个数，其中初始化如下： dp[0] = 0 若i = 某硬币面值，则dp[i] = 1; 其余均初始化为-1 状态转移过程直接写在代码里了 12345678910111213141516171819202122232425262728class Solution&#123;public: int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123; sort(coins.begin(), coins.end()); if (amount &lt; 0) return -1; vector&lt;int&gt; dp(amount + 1, -1); dp[0] = 0; for (int i = 0; i &lt; coins.size(); i++) if (coins[i] &lt;= amount) dp[coins[i]] = 1; for (int i = 1; i &lt;= amount; i++) &#123; if (dp[i] == 1) continue; for (int j = 0; j &lt; coins.size(); j++) &#123; if (i - coins[j] &gt;= 0 &amp;&amp; dp[i - coins[j]] != -1) dp[i] = (dp[i] == -1) ? (dp[i - coins[j]] + 1) : min(dp[i], dp[i - coins[j]] + 1); &#125; &#125; return dp[amount]; &#125;&#125;; Leetcode 410 分割数组的最大值leetcode 419 题目描述给定一个非负整数数组和一个整数 m，你需要将这个数组分成 m 个非空的连续子数组。设计一个算法使得这 m 个子数组各自和的最大值最小。 注意:数组长度 n 满足以下条件: 1 ≤ n ≤ 1000 1 ≤ m ≤ min(50, n) 示例输入:nums = [7,2,5,10,8]m = 2 输出:18 解释:一共有四种方法将nums分割为2个子数组。其中最好的方式是将其分为[7,2,5] 和 [10,8]，因为此时这两个子数组各自的和的最大值为18，在所有情况中最小。 方法动态规划，dp[i][j]表示前i个数被分为j段后的所有方案中各个子数组和最大值的最小值。。求前缀和比较亮眼。。。 12345678910111213141516171819202122class Solution&#123;public: int splitArray(vector&lt;int&gt;&amp; nums, int m) &#123; int n = nums.size(); vector&lt;long long&gt; pre_sum(n + 1, 0); pre_sum[1] = nums[0]; for (int i = 0; i &lt; n; i++) pre_sum[i + 1] = pre_sum[i] + nums[i]; vector&lt;vector&lt;long long&gt;&gt; dp(n + 1, vector&lt;long long&gt;(m + 1, LLONG_MAX)); //dp[i][j]表示前i个数被分为j段后各个子数组和最大值的最小值。。 dp[0][0] = 0; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= min(m, i); j++) for (int k = 0; k &lt; i; k++) dp[i][j] = min(dp[i][j], max(dp[k][j - 1], pre_sum[i] - pre_sum[k])); return dp[n][m]; &#125;&#125;;","categories":[],"tags":[{"name":"leetcode_solution","slug":"leetcode-solution","permalink":"http://believebest35.github.io/tags/leetcode-solution/"}]},{"title":"leetcode 1025 除数博弈","slug":"leetcode-solution-4","date":"2020-07-24T07:54:08.000Z","updated":"2020-10-13T12:27:17.429Z","comments":true,"path":"2020/07/24/leetcode-solution-4/","link":"","permalink":"http://believebest35.github.io/2020/07/24/leetcode-solution-4/","excerpt":"Leetcode 1025 除数博弈leetcode 1025 题目描述爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。 最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作： 选出任一 x，满足 0 &lt; x &lt; N 且 N % x == 0 。 用 N - x 替换黑板上的数字 N 。如果玩家无法执行这些操作，就会输掉游戏。 只有在爱丽丝在游戏中取得胜利时才返回 True，否则返回 false。假设两个玩家都以最佳状态参与游戏。","text":"Leetcode 1025 除数博弈leetcode 1025 题目描述爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。 最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作： 选出任一 x，满足 0 &lt; x &lt; N 且 N % x == 0 。 用 N - x 替换黑板上的数字 N 。如果玩家无法执行这些操作，就会输掉游戏。 只有在爱丽丝在游戏中取得胜利时才返回 True，否则返回 false。假设两个玩家都以最佳状态参与游戏。 示例输入：2输出：true解释：爱丽丝选择 1，鲍勃无法进行操作。 输入：3输出：false解释：爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。 方法一：动态规划如果不想动脑就无脑动态规划。。。设dp[i]表示数字为i时先手是否必赢。数字为i时的必胜是从先前某一必败态所转移来的，因此转移方程可以写为：dp[i] = true if dp[i - j] = false exists (j为i因子)or dp[i] = false 1234567891011121314151617class Solution&#123;public: bool divisorGame(int N) &#123; vector&lt;bool&gt; dp(N + 1, false); dp[1] = false, dp[2] = true; for (int i = 3; i &lt;= N; i++) for (int j = 1; j &lt; i; j++) if (i % j == 0 &amp;&amp; !dp[i - j]) &#123; dp[i] = true; break; &#125; return dp[N]; &#125;&#125;; 方法二：数学规律额，直接才想N能不能被2整除，能整除就返回true，否则false。证明可用数学归纳法。 12345678class Solution&#123;public: bool divisorGame(int N) &#123; return N % 2 == 0； &#125;&#125;;","categories":[],"tags":[{"name":"leetcode_solution","slug":"leetcode-solution","permalink":"http://believebest35.github.io/tags/leetcode-solution/"}]},{"title":"leetcode 287 寻找重复数","slug":"leetcode-solution-3","date":"2020-07-23T07:10:49.000Z","updated":"2020-10-13T12:27:26.410Z","comments":true,"path":"2020/07/23/leetcode-solution-3/","link":"","permalink":"http://believebest35.github.io/2020/07/23/leetcode-solution-3/","excerpt":"Leetcode 287 寻找重复数leetcode 287 题目描述给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。 示例输入: [1,3,4,2,2]输出: 2 输入: [3,1,3,4,2]输出: 3","text":"Leetcode 287 寻找重复数leetcode 287 题目描述给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。 示例输入: [1,3,4,2,2]输出: 2 输入: [3,1,3,4,2]输出: 3 说明 不能更改原数组（假设数组是只读的）。 只能使用额外的 O(1) 的空间。 时间复杂度小于 O(n^2) 。 数组中只有一个重复的数字，但它可能不止重复出现一次。 解法这道题如果没有说明里的条件的话是非常容易的，可以排序，或者哈希，但是排序修改了原数组，哈希需要O(n)的空间。另外如果没有第一个条件的话可以考虑使用原地哈希。 以上的方法不能使用，因此实际做的时候用的是二分，不过不是对下标进行二分，而是对值域进行二分。最开始范围取到1～n，mid = (1 + n) / 2，每次分别统计小于mid，等于mid以及大于mid的个数，据此缩小空间。 123456789101112131415161718192021222324252627282930class Solution&#123;public: int findDuplicate(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size() - 1; int i = 1, j = n; while (i &lt; j) &#123; int less_k = 0; int large_k = 0; int count_k = 0; int mid = i + (j - i) / 2; for (auto num : nums) if (num == mid) count_k++; else if (num &lt; mid) less_k++; else large_k++; if (count_k &gt;= 2) return mid; if (less_k &gt; mid - 1) j = mid - 1; else i = mid + 1; &#125; return i; // 题目数据保证，不会在这退出。。。 &#125;&#125;;","categories":[],"tags":[{"name":"leetcode_solution","slug":"leetcode-solution","permalink":"http://believebest35.github.io/tags/leetcode-solution/"}]},{"title":"STL常用容器","slug":"stl常用容器","date":"2020-07-23T03:21:30.000Z","updated":"2020-10-13T12:28:30.685Z","comments":true,"path":"2020/07/23/stl常用容器/","link":"","permalink":"http://believebest35.github.io/2020/07/23/stl%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8/","excerpt":"这里记录了一些用c++刷leetcode时可能会用到的stl容器用法 原出处，作者wangdh vector边长数组，倍增思想 系统为某一个程序分配空间时，所需时间和空间大小无关，与申请次数有关。 所以变长数组尽可能减少申请次数。一开始申请一定空间的大小，当超过容量时，申请长度变为二倍的空间，然后将原始空间的元素copy过来。 当初始化的时候不指定空间大小，但是使用的空间有非常大之后需要多次扩容，那么扩容需要的时间复杂度是O(N) 相当于插入一个元素就需要将O(1)的时间。申请空间的次数是O(log n)。","text":"这里记录了一些用c++刷leetcode时可能会用到的stl容器用法 原出处，作者wangdh vector边长数组，倍增思想 系统为某一个程序分配空间时，所需时间和空间大小无关，与申请次数有关。 所以变长数组尽可能减少申请次数。一开始申请一定空间的大小，当超过容量时，申请长度变为二倍的空间，然后将原始空间的元素copy过来。 当初始化的时候不指定空间大小，但是使用的空间有非常大之后需要多次扩容，那么扩容需要的时间复杂度是O(N) 相当于插入一个元素就需要将O(1)的时间。申请空间的次数是O(log n)。 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;int main()&#123; vector&lt;int&gt; a; // 定义一个vecotr vector&lt;int&gt; a(10); // 初始长度为10； vector&lt;int&gt; a(10, 3); // 初始长度为10， 且每个元素初始化为3 for(auto i : a) cout &lt;&lt; i &lt;&lt; \" \"; // 遍历元素的方式 ， auto 关键字，系统自动推断变量类型，变量名比较长的时候可以使用 vector&lt;int&gt; a[10]; // 定义了vector数组，每个元素都是一个vector&lt;int&gt; a.size(); // 返回列表里的元素的个数 a.empty(); // 返回列表是不是空 // size() 和empty() 是所有容器都有的，时间复杂度是o(1) a.clear(); // 清空，不是所有的容器都有 a.front(); // 返回第一个元素 a.back(); // 返回最后一个元素 a.push_back(); // 从最后插入一个元素 a.pop_back(); // 删除最后一个元素 a.begin(); a.end(); // 迭代器。 可以看做指针，可以解引用 a[2]; // 支持随机寻址，与数组相同 // 三种遍历方式 for(int i = 0; i &lt; a.size(); i ++) cout &lt;&lt; a[i] &lt;&lt; \" \"; cout &lt;&lt; endl; for(vector&lt;int&gt;::iterator i = a.begin(); i != a.end(); i ++) cout &lt;&lt; *i &lt;&lt; \" \"; for(auto i = a.begin(); i != a.end(); i ++) cout &lt;&lt; *i &lt;&lt; \" \"; // 迭代器，解引用 cout &lt;&lt; endl; for(auto x : a) cout &lt;&lt; x &lt;&lt; \" \"; // auto关键字自动推断类型 cout &lt;&lt; endl; // vector支持比较，按位进行字典序比较 vector&lt;int&gt; a(4, 3), b(3, 4); cout &lt;&lt; (a &lt; b); return 0;&#125; pair元组类型，相当于Python中的(). 当一个元素有多个属性的时候，可以使用pair来进行存储。当需要按照某个属性来排序的时候，就非常好。 比如合并区间的问题。每个区间有开始和结尾两个属性，然后需要按照区间的开始对区间进行排序。 可以看做实现了一个结构体，且实现了比较器。 12345678910111213141516171819202122232425262728293031// 两种初始化方法pair&lt;int, string&gt; p;p = make_pair(10, \"aa\");p = &#123;q, \"ab\"&#125;;// 支出比较运算，first为第一关键字，second为第二关键字pair&lt;int, string&gt; p = &#123;1, \"aa\"&#125;;pair&lt;int, string&gt; q = &#123;1, \"ab\"&#125;;// first取出第一个字， second取出第二个字cout &lt;&lt; p.first &lt;&lt; endl;cout &lt;&lt; p.second &lt;&lt; endl;cout &lt;&lt; (p &lt; q) &lt;&lt; endl;// 也可以使用pair存储三个属性等; pair 嵌套pairpair&lt;int, pair&lt;int, int&gt;&gt; p;string字符串，substr(), c_str()string s = \"a\"; s += \"ab\"; // 支持增量操作s += 'a';cout &lt;&lt; s &lt;&lt; endl;cout &lt;&lt; s.substr(1, 2) &lt;&lt; endl; // 可以取出某个子串，第一个是起始index，第二个是长度。第二个缺省或者超过范围则返回之后的左右字符串cout &lt;&lt; s.substr(1) &lt;&lt; endl;cout &lt;&lt; s.substr(1, 100) &lt;&lt; endl;printf(\"%s\\n\", s.c_str()); // 使用printf输出的时候，需要找到存储字符串数组的起始地址。c_str()可以返回size() | length() // 返回字符串的长度 s.find('a'); // 返回a在s中的位置,如果没找到，返回一个特别的标志c++中用npos表示(可以用s.npos)来表示 queue队列，push(), front() , pop(),back() 1234567// push() 向队尾插入一个元素// front() 返回队头元素// pop() 返回队尾元素// back() 弹出队头元素// size() // empty()// 没有clear操作 priority_queue优先队列，push(), top(), pop() 123456789101112131415161718192021222324// 内部使用堆维护// 默认是大顶堆，和python相反// 使用小顶对方法// 1. 在插入的时候插入元素的相反数即可// 2. 如下定义#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;iostream&gt;#include&lt;csting&gt;#include&lt;queue&gt;using namespace std;priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; heap;// priority_queue&lt;int&gt; q; // 大顶堆priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q; // 小顶堆q.push(1);q.push(2);q.push(5);q.push(10);while(!q.empty())&#123; cout &lt;&lt; q.top() &lt;&lt; endl; q.pop();&#125; stack栈， push(), top(), pop() 123456#include&lt;stack&gt;// size()// empty()// push() 栈顶加入一个元素// top() 范湖栈顶元素// pop() 弹出栈顶元素 deque双端队列，队头队尾都可以插入删除元素，也可以随机访问，加强版vector。 deque非常厉害，几乎支持其他容器所有的操作，但是速度对应的也比较慢。 12345678910111213#include&lt;deque&gt;size()empty()clear() // 支持清空操作front() // 可以访问头部或尾部元素back()// 能够从头或者尾部插入或删除元素push_back()pop_back()push_front()pop_front()[] // 支持索引操作 set, map multiset, multimap基于平衡二叉树(红黑树), 动态维护有序序列 1234567891011121314151617181920212223242526size();empty();clear();begin()/end(); ++ , -- 迭代器支持自增自减 返回前驱后继 时间复杂度也是log nset/ multiset// multiset可以存储多个相同的元素insert(); // 插入一个元素 log(n)find(x); // 查找一个元素count(x); // 返回某个数的个数erase(); // 输入一个数x，则删除所有x O(k + log n) k是元素个数 输入一个迭代器，则删除这个迭代器lower_bound()/ upper_bound(); // lower_bound(x) 返回大于等于x的最小的数的迭代器 upper_bound(x) 返回大于x的最小的数的迭代器map/ multimap; // 将两个元素做映射， multi_map支持一个key对应多个valueinsert(); // 插入的是一个pairerase(); // 输入的参数是一个pair或者迭代器find(); // []; // 支持索引操作 时间复杂度O(log n)#include&lt;map&gt;map&lt;string, int&gt; a;a[\"wdh\"] = 1;cout &lt;&lt; a[\"wdh\"] &lt;&lt; endl; unordered_set, unordered_map, unordered_multiset, unordered_multimap使用哈希表进行存储 操作和上面的相同，时间复杂度都是O(1)。内部无续，不支持lower_bound, upper_bound。不支迭代器的++ – bitset压位， 进行位运算，如状压DP的对状态的各种位操作。 比如如果开大小为1024的bool数组，那么需要使用1KB内存。 但是如果使用压位，那么只需要使用125B内存。 要开10000 * 10000的bool数组，那么需要大概100MB内存，但是内存限制是64MB， 这个时候使用压位就可以只用 12MB内存。 12345678910111213bitset&lt;10000&gt; s; // 一万位~ &amp; | ^; // 按位逻辑操作&gt;&gt; &lt;&lt; ; // 移位操作==, != ; // 比较操作[]; // 取出某一位count(); // 返回有多少个1any(); // 判断是否至少有一个1none(); // 判断是否全为零set(); // 把所有位置为1set(k, v); // 将第k位变成vreset(); // 将所有位变成零flip(); // 将所有位取反，等价于~flip(k); // 将第k位取反 algorithm实现了一些常用算法 1234567891011121314vector&lt;int&gt; a;sort(a.begin(), a.end()); // 对a进行快速排序reverse(a.begin(), a.end()); // 翻转一个vectorunique(a.begin(), a.end()); // 返回去重之后的尾迭代器(指针), 前闭后开，返回的是去重之后末尾元素的下一个位置int m =unique(a.begin(), a.end()) - a.begin(); // 计算去重之后的元素个数mrandom_shuffle(a.begin(), a.end()); // 随机打乱顺序next_permutation(); // 将两个迭代器(指针)指定的部分看做一个排列，求出这些元素构成的全排列中，字典序排在写一个的全排列。并直接在序列上更新。若不存在，则返回false，否则返回true。同理有prev_permutation函数// 输出1 - n的 n！中全排列int q[3] = &#123;1, 2, 3&#125;;do&#123; for(int i = 0; i &lt; 3; i ++) cout &lt;&lt; q[i] &lt;&lt; \" \"; cout &lt;&lt; endl;&#125;while(next_permutation(q, q+3));","categories":[],"tags":[{"name":"STL常用容器","slug":"STL常用容器","permalink":"http://believebest35.github.io/tags/STL%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8/"}]},{"title":"leetcode 279 完全平方数","slug":"leetcode-solution-2","date":"2020-07-22T14:39:07.000Z","updated":"2020-10-13T12:27:35.868Z","comments":true,"path":"2020/07/22/leetcode-solution-2/","link":"","permalink":"http://believebest35.github.io/2020/07/22/leetcode-solution-2/","excerpt":"Leetcode 279 完全平方数leetcode 279 题目描述给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。 示例输入: n = 12输出: 3解释: 12 = 4 + 4 + 4. 输入: n = 13输出: 2解释: 13 = 4 + 9.","text":"Leetcode 279 完全平方数leetcode 279 题目描述给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。 示例输入: n = 12输出: 3解释: 12 = 4 + 4 + 4. 输入: n = 13输出: 2解释: 13 = 4 + 9. 方法一：暴力拿到题目后想都没想Orz，直接dfs暴力搜索，果然T了。。。TAT 123456789101112131415161718192021222324252627class Solution&#123;public: int ans; void dfs(int left, int base, int count) &#123; if (left &lt; 0) return; if (left == 0) &#123; ans = min(ans, count); return; &#125; for (int i = base; i &gt;= 1; i--) dfs(left - i * i, i, count + 1); &#125; int numSquares(int n) &#123; ans = n; dfs(n, pow(n, 1.0 / 2.0), 0); return ans; &#125;&#125;; 方法二：动态规划设dp[i]表示和为i的最小平方数的个数，转移方程为：dp[i] = min(dp[i], dp[i - j * j] + 1); 123456789101112131415class Solution&#123;public: int numSquares(int n) &#123; vector&lt;int&gt; dp(n + 1, 0); for (int i = 1; i &lt;= n; i++) &#123; dp[i] = i; for (int j = 1; i - j * j &gt;= 0; j++) dp[i] = min(dp[i], dp[i - j * j] + 1); &#125; return dp[n]; &#125;&#125;;","categories":[],"tags":[{"name":"leetcode_solution","slug":"leetcode-solution","permalink":"http://believebest35.github.io/tags/leetcode-solution/"}]},{"title":"leetcode 剑指offer 11 旋转数组的最小数字","slug":"leetcode-solution-1","date":"2020-07-22T13:10:05.000Z","updated":"2020-10-13T12:27:44.518Z","comments":true,"path":"2020/07/22/leetcode-solution-1/","link":"","permalink":"http://believebest35.github.io/2020/07/22/leetcode-solution-1/","excerpt":"Leetcode 剑指offer 11 旋转数组的最小数字剑指offer 11 on leetcode 题目描述把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。 示例输入：[3,4,5,1,2]输出：1 输入：[2,2,2,0,1]输出：0","text":"Leetcode 剑指offer 11 旋转数组的最小数字剑指offer 11 on leetcode 题目描述把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。 示例输入：[3,4,5,1,2]输出：1 输入：[2,2,2,0,1]输出：0 方法一：暴力暴力的方法相对很直观，比较容易想到。但这道题没有说明搬运元素的个数，因此需要特判一下\b是否没有搬运，即比较数组头和数组尾元素大小即可。若nums[0] &lt; nums[n - 1]则说明没有搬运，直接返回第一个元素即可。 若搬运了元素，进行一次遍历即可，返回满足nums[i] &lt; nums[i - 1]的元素即可。 1234567891011121314151617181920class Solution&#123;public: int minArray(vector&lt;int&gt;&amp; numbers) &#123; int n = numbers.size(); if (n == 0) return 0; if (n == 1) return numbers[0]; if (n == 2) return min(numbers[0], numbers[1]); if (numbers[0] &lt; numbers[n - 1]) return numbers[0]; for (int i = 1; i &lt; n; i++) if (numbers[i] &lt; numbers[i - 1]) return numbers[i]; return numbers[n - 1]; &#125;&#125;; 显然时间复杂度为O(n)。 方法二：二分查找暴力的时间复杂度过高，通过二分查找可以将平均时间复杂度降至O(logn)。假定左端元素下标为i，右端元素下标为j，每次二分后得到mid元素可能以下存在三种情况 nums[mid] &lt; nums[j] 说明被找元素位于i和mid之间，因此将j修改为mid nums[mid] &gt; nums[j] 说明被找元素位于j和mid之间，因此将i修改为mid + 1 nums[mid] == nums[j] 由于存在重复元素，因此不能轻易修改i、j，由于mid和j处元素相同，因此不论nums[j]是否为最小元素， j左边应该存在一个“替代品”。。。因此将j–即可。 12345678910111213141516171819202122232425262728class Solution&#123;public: int minArray(vector&lt;int&gt;&amp; numbers) &#123; int n = numbers.size(); if (n == 0) return 0; if (n == 1) return numbers[0]; if (n == 2) return min(numbers[0], numbers[1]); if (numbers[0] &lt; numbers[n - 1]) return numbers[0]; int i = 0, j = n - 1; while (i &lt; j) &#123; int mid = i + (j - i) / 2; if (numbers[mid] &lt; numbers[j]) j = mid; else if (numbers[mid] &gt; numbers[j]) i = mid + 1; else j--; &#125; return numbers[i]; &#125;&#125;; 平均时间复杂度为O(logn)。 这似乎是我开始写的第一篇blog，希望我以后能够将写博客的习惯坚持下去吧，最近发现自己实在是太菜了Orz，无论是科研还是代码能力都菜得抠脚Orz。。。TAT 为此我也希望自己开始改变吧，以后无论是刷leetcode，还是读论文等等，与技术相关的东西我渐渐都会放在这里，希望自己在这两年卷的飞起的环境里还能找到一个还算行的工作吧。。。Orz 这里可能也会放一些吐槽吧。。。","categories":[],"tags":[{"name":"leetcode_solution","slug":"leetcode-solution","permalink":"http://believebest35.github.io/tags/leetcode-solution/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-07-19T15:31:33.751Z","updated":"2020-10-13T12:28:08.020Z","comments":true,"path":"2020/07/19/hello-world/","link":"","permalink":"http://believebest35.github.io/2020/07/19/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"c++","slug":"c","permalink":"http://believebest35.github.io/tags/c/"},{"name":"Java","slug":"Java","permalink":"http://believebest35.github.io/tags/Java/"},{"name":"HTTP","slug":"HTTP","permalink":"http://believebest35.github.io/tags/HTTP/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://believebest35.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"数据库","slug":"数据库","permalink":"http://believebest35.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"SQL","slug":"SQL","permalink":"http://believebest35.github.io/tags/SQL/"},{"name":"设计模式","slug":"设计模式","permalink":"http://believebest35.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"多线程","slug":"多线程","permalink":"http://believebest35.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"OOP","slug":"OOP","permalink":"http://believebest35.github.io/tags/OOP/"},{"name":"Linux","slug":"Linux","permalink":"http://believebest35.github.io/tags/Linux/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://believebest35.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode_solution","slug":"leetcode-solution","permalink":"http://believebest35.github.io/tags/leetcode-solution/"},{"name":"STL常用容器","slug":"STL常用容器","permalink":"http://believebest35.github.io/tags/STL%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8/"}]}