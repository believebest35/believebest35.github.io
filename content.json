{"meta":{"title":"Xinrui Tang","subtitle":"","description":"","author":"Xinrui Tang","url":"http://beloevebest35.github.io","root":"/"},"pages":[{"title":"","date":"2020-07-22T11:24:27.000Z","updated":"2020-07-22T12:12:41.598Z","comments":false,"path":"categories/index.html","permalink":"http://beloevebest35.github.io/categories/index.html","excerpt":"","text":""},{"title":"about me","date":"2020-07-22T11:26:47.000Z","updated":"2020-07-22T12:20:53.959Z","comments":false,"path":"about/index.html","permalink":"http://beloevebest35.github.io/about/index.html","excerpt":"","text":"Hello, this is Xinrui Tang’s blog by hexo."},{"title":"","date":"2020-07-22T11:26:00.000Z","updated":"2020-07-22T12:12:13.920Z","comments":false,"path":"tags/index.html","permalink":"http://beloevebest35.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"leetcode 剑指offer 11 旋转数组的最小数字","slug":"leetcode-solution-1","date":"2020-07-22T13:10:05.000Z","updated":"2020-07-22T14:16:55.927Z","comments":true,"path":"2020/07/22/leetcode-solution-1/","link":"","permalink":"http://beloevebest35.github.io/2020/07/22/leetcode-solution-1/","excerpt":"","text":"Leetcode 剑指offer 11 旋转数组的最小数字剑指offer 11 on leetcode 题目描述把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。 示例输入：[3,4,5,1,2]输出：1 输入：[2,2,2,0,1]输出：0 方法一：暴力暴力的方法相对很直观，比较容易想到。但这道题没有说明搬运元素的个数，因此需要特判一下\b是否没有搬运，即比较数组头和数组尾元素大小即可。若nums[0] &lt; nums[n - 1]则说明没有搬运，直接返回第一个元素即可。 若搬运了元素，进行一次遍历即可，返回满足nums[i] &lt; nums[i - 1]的元素即可。 1234567891011121314151617181920class Solution&#123;public: int minArray(vector&lt;int&gt;&amp; numbers) &#123; int n = numbers.size(); if (n == 0) return 0; if (n == 1) return numbers[0]; if (n == 2) return min(numbers[0], numbers[1]); if (numbers[0] &lt; numbers[n - 1]) return numbers[0]; for (int i = 1; i &lt; n; i++) if (numbers[i] &lt; numbers[i - 1]) return numbers[i]; return numbers[n - 1]; &#125;&#125;; 显然时间复杂度为O(n)。 方法二：二分查找暴力的时间复杂度过高，通过二分查找可以将平均时间复杂度降至O(logn)。假定左端元素下标为i，右端元素下标为j，每次二分后得到mid元素可能以下存在三种情况 nums[mid] &lt; nums[j] 说明被找元素位于i和mid之间，因此将j修改为mid nums[mid] &gt; nums[j] 说明被找元素位于j和mid之间，因此将i修改为mid + 1 nums[mid] == nums[j] 由于存在重复元素，因此不能轻易修改i、j，由于mid和j处元素相同，因此不论nums[j]是否为最小元素， j左边应该存在一个“替代品”。。。因此将j–即可。 12345678910111213141516171819202122232425262728class Solution&#123;public: int minArray(vector&lt;int&gt;&amp; numbers) &#123; int n = numbers.size(); if (n == 0) return 0; if (n == 1) return numbers[0]; if (n == 2) return min(numbers[0], numbers[1]); if (numbers[0] &lt; numbers[n - 1]) return numbers[0]; int i = 0, j = n - 1; while (i &lt; j) &#123; int mid = i + (j - i) / 2; if (numbers[mid] &lt; numbers[j]) j = mid; else if (numbers[mid] &gt; numbers[j]) i = mid + 1; else j--; &#125; return numbers[i]; &#125;&#125;; 平均时间复杂度为O(logn)。 这似乎是我开始写的第一篇blog，希望我以后能够将写博客的习惯坚持下去吧，最近发现自己实在是太菜了Orz，无论是科研还是代码能力都菜得抠脚Orz。。。TAT 为此我也希望自己开始改变吧，以后无论是刷leetcode，还是读论文等等，与技术相关的东西我渐渐都会放在这里，希望自己在这两年卷的飞起的环境里还能找到一个还算行的工作吧。。。Orz 这里可能也会放一些吐槽吧。。。","categories":[],"tags":[{"name":"leetcode_solution","slug":"leetcode-solution","permalink":"http://beloevebest35.github.io/tags/leetcode-solution/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-07-19T15:31:33.751Z","updated":"2020-07-19T15:31:33.751Z","comments":true,"path":"2020/07/19/hello-world/","link":"","permalink":"http://beloevebest35.github.io/2020/07/19/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"leetcode_solution","slug":"leetcode-solution","permalink":"http://beloevebest35.github.io/tags/leetcode-solution/"}]}